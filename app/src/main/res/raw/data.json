{"count":100,"start":0,"total":10286,"books":[{"rating":{"max":10,"numRaters":139,"average":"7.4","min":0},"subtitle":"人人都能学会程序设计","author":["蔡学镛"],"pubdate":"2012-7","tags":[{"count":402,"name":"编程","title":"编程"},{"count":240,"name":"计算机","title":"计算机"},{"count":153,"name":"蔡学镛","title":"蔡学镛"},{"count":103,"name":"IT","title":"IT"},{"count":102,"name":"程序设计","title":"程序设计"},{"count":65,"name":"互联网","title":"互联网"},{"count":65,"name":"计算机科学","title":"计算机科学"},{"count":59,"name":"Programming","title":"Programming"}],"origin_title":"编程ING：人人都能学会程序设计","image":"http:\/\/img3.douban.com\/mpic\/s11161943.jpg","binding":"平装","translator":[],"catalog":"第1篇\n编程原理 2\n第1章 认识编程 3\n第2章 使用交互环境 13\n第3章 脚本文件 27\n第4章 字符编码 37\n第5章 解释器原理 51\n第6章 语境与单字 61\n第7章 多语境的操作 71\n\n第2篇\n语法语义 82\n第8章 一切都是值 83\n第9章 数据类型 95\n第10章 字面值 107","pages":"303","images":{"small":"http:\/\/img3.douban.com\/spic\/s11161943.jpg","large":"http:\/\/img3.douban.com\/lpic\/s11161943.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s11161943.jpg"},"alt":"http:\/\/book.douban.com\/subject\/11442031\/","id":"11442031","publisher":"电子工业出版社","isbn10":"7121175282","isbn13":"9787121175282","title":"编程ING","url":"http:\/\/api.douban.com\/v2\/book\/11442031","alt_title":"编程ING：人人都能学会程序设计","author_intro":"台湾清华大学计算机硕士\n创新工场首席布道架构师\n\n曾任大学讲师、技术总监、\n培训讲师、程序员、译者、\n技术编辑、技术专栏作家\n\n著译多本计算机图书，\n包括《Java夜未眠》","summary":"现在是 IT的时代，工作与生活都离不开IT。许多人都想了解软件原理，甚至编写一些简单的软件。通过《编程 ING：人人都能学会程序设计》一书，你就能拥有这样的能力，甚至培养出对编程的兴趣。\n本书在编写上采用了心理学的一些技巧，每一页都有绘制精美的彩图并配有相应的说明文字，通过图的方式加强说明，而且图片与下面的文字相互呼应，达到重复的效果，可以加深记忆。读者在看图的过程中思考，在阅读文字的过程中加强理解，在动手实践的过程中实际体会，学习效果相当好。\n这本书分成三大篇：第一篇讲述编程原理，第二篇讲述语法细节，第三篇是范例演示。第一篇重点在打破隔阂，让读者对编程有基本的认识，不再感到陌生或恐惧。第二篇详细说明语法，内容安排得深入浅出，不像一般程序设计书籍那般枯燥，而且强调动手做实验。第三篇的范例将前两篇的知识整合起来，并且突破性地设计渐进式的范例，让学习的坡度相当和缓，且讲解了所有的程序要素，包括循环、分支、函数、递归与模块化。\n任何人想学程序设计，这本书都会是一个明智的选择。","price":"68.00元"},{"rating":{"max":10,"numRaters":108,"average":"9.3","min":0},"subtitle":"","author":["宋劲杉"],"pubdate":"2011-3","tags":[{"count":126,"name":"C","title":"C"},{"count":102,"name":"Linux","title":"Linux"},{"count":80,"name":"编程","title":"编程"},{"count":41,"name":"计算机","title":"计算机"},{"count":39,"name":"C语言","title":"C语言"},{"count":29,"name":"国产好书","title":"国产好书"},{"count":20,"name":"programming","title":"programming"},{"count":18,"name":"宋劲彬","title":"宋劲彬"}],"origin_title":"Linux C编程一站式学习","image":"http:\/\/img3.douban.com\/mpic\/s4718504.jpg","binding":"Paperback","translator":[],"catalog":"《一站式学习c编程》\n上篇 c语言入门\n第1章 程序的基本概念 2\n1.1 程序和编程语言 2\n1.2 自然语言和形式语言 6\n1.3 程序的调试 8\n1.4 第一个程序 9\n第2章 常量、变量和表达式 13\n2.1 继续hello world 13\n2.2 常量 16\n2.3 变量 17\n2.4 赋值 19\n2.5 表达式 20\n2.6 字符类型与字符编码 24\n第3章 简单函数 26\n3.1 数学函数 26\n3.2 自定义函数 28\n3.3 形参和实参 34\n3.4 全局变量、局部变量和作用域 38\n第4章 分支语句 44\n.4.1 if语句 44\n4.2 if\/else语句 46\n4.3 布尔代数 48\n4.4 switch语句 52\n第5章 深入理解函数 54\n5.1 return语句 54\n5.2 增量式开发 57\n5.3 递归 61\n第6章 循环语句 67\n6.1 while语句 67\n6.2 do\/while语句 69\n6.3 for语句 70\n6.4 break和continue语句 72\n6.5 嵌套循环 73\n6.6 goto语句和标号 74\n第7章 结构体 78\n7.1 复合类型与结构体 78\n7.2 数据抽象 82\n7.3 数据类型标志 86\n7.4 嵌套结构体 87\n第8章 数组 89\n8.1 数组的基本概念 89\n8.2 数组应用实例：统计随机数 92\n8.3 数组应用实例：直方图 95\n8.4 字符串 98\n8.5 多维数组 100\n第9章 编码风格 104\n9.1 缩进和空白 104\n9.2 注释 108\n9.3 标识符命名 112\n9.4 函数 112\n9.5 indent工具 113\n第10章 gdb 115\n10.1 单步执行和跟踪函数调用 115\n10.2 断点 122\n10.3 观察点 126\n10.4 段错误 130\n第11章 排序与查找 133\n11.1 算法的概念 133\n11.2 插入排序 134\n11.3 算法的时间复杂度分析 136\n11.4 归并排序 138\n11.5 线性查找 143\n11.6 折半查找 144\n第12章 栈与队列 149\n12.1 数据结构的概念 149\n12.2 堆栈 149\n12.3 深度优先搜索 151\n12.4 队列与广度优先搜索 157\n12.5 环形队列 162\n本阶段总结 163\n下篇 c语言本质\n第13章 计算机中数的表示 166\n13.1 为什么计算机用二进制计数 166\n13.2 不同进制之间的换算 168\n13.3 整数的加减运算 170\n13.3.1 sign and magnitude表示法 170\n13.3.2 1's complement表示法 170\n13.3.3 2's complement表示法 172\n13.3.4 有符号数和无符号数 173\n13.4 浮点数 173\n第14章 数据类型详解 176\n14.1 整型 176\n14.2 浮点型 180\n14.3 类型转换 181\n14.3.1 integer promotion 181\n14.3.2 usual arithmetic conversion 182\n14.3.3 由赋值产生的类型转换 183\n14.3.4 强制类型转换 183\n14.3.5 编译器如何处理类型转换 184\n第15章 运算符详解 186\n15.1 位运算 186\n15.1.1 按位与、或、异或、取反运算 186\n15.1.2 移位运算 187\n15.1.3 掩码 188\n15.1.4 异或运算的一些特性 189\n15.2 其他运算符 190\n15.2.1 复合赋值运算符 190\n15.2.2 条件运算符 190\n15.2.3 逗号运算符 191\n15.2.4 sizeof运算符与typedef类型声明 191\n15.3 side effect与sequence point 193\n15.4 运算符总结 196\n第16章 计算机体系结构基础 198\n16.1 内存与地址 198\n16.2 cpu 198\n16.3 设备 201\n16.4 mmu 203\n16.5 memory hierarchy 205\n第17章 x86汇编程序基础 209\n17.1 最简单的汇编程序 209\n17.2 x86的寄存器 212\n17.3 第二个汇编程序 212\n17.4 寻址方式 215\n17.5 elf文件 216\n17.5.1 目标文件 217\n17.5.2 可执行文件 223\n第18章 汇编与c之间的关系 229\n18.1 函数调用 229\n18.2 main函数、启动例程和退出状态 236\n18.3 变量的存储布局 242\n18.4 结构体和联合体 249\n18.5 c内联汇编 254\n18.6 volatile限定符 255\n第19章 链接详解 260\n19.1 多目标文件的链接 260\n19.2 定义和声明 266\n19.2.1 extern和static关键字 266\n19.2.2 头文件 269\n19.2.3 定义和声明的详细规则 274\n19.3 静态库 276\n19.4 共享库 279\n19.4.1 编译、链接、运行 279\n19.4.2 函数的动态链接过程 286\n19.4.3 共享库的命名惯例 288\n19.5 虚拟内存管理 290\n第20章 预处理 296\n20.1 预处理的步骤 296\n20.2 宏定义 297\n20.2.1 函数式宏定义 297\n20.2.2 内联函数 300\n20.2.3 #、##运算符和可变参数 301\n20.2.4 #undef预处理指示 304\n20.2.5 宏展开的步骤 304\n20.3 条件预处理指示 305\n20.4 其他预处理特性 309\n第21章 makefile基础 312\n21.1 基本规则 312\n21.2 隐含规则和模式规则 319\n21.3 变量 322\n21.4 自动处理头文件的依赖关系 327\n21.5 常用的make命令行选项 331\n第22章 指针 334\n22.1 指针的基本概念 334\n22.2 指针类型的参数和返回值 337\n22.3 指针与数组 339\n22.4 指针与const限定符 342\n22.5 指针与结构体 344\n22.6 指向指针的指针与指针数组 344\n22.7 指向数组的指针与多维数组 348\n22.8 函数类型和函数指针类型 349\n22.9 不完全类型和复杂声明 353\n第23章 函数接口 357\n23.1 本章的预备知识 357\n23.1.1 strcpy与strncpy 357\n23.1.2 malloc与free 362\n23.2 传入参数与传出参数 367\n23.3 两层指针的参数 368\n23.4 返回值是指针的情况 370\n23.5 回调函数 373\n23.6 可变参数 376\n第24章 c标准库 380\n24.1 字符串操作函数 381\n24.1.1 给字符串赋初值 381\n24.1.2 取字符串的长度 382\n24.1.3 拷贝字符串 383\n24.1.4 连接字符串 385\n24.1.5 比较字符串 386\n24.1.6 搜索字符串 387\n24.1.7 分割字符串 387\n24.2 标准i\/o库函数 391\n24.2.1 文件的基本概念 391\n24.2.2 fopen\/fclose 392\n24.2.3 stdin\/stdout\/stderr 395\n24.2.4 errno与perror\/strerror函数 396\n24.2.5 以字节为单位的i\/o函数 398\n24.2.6 操作读写位置的函数 401\n24.2.7 以字符串为单位的i\/o函数 403\n24.2.8 以记录为单位的i\/o函数 404\n24.2.9 格式化i\/o函数 406\n24.2.10 c标准库的i\/o缓冲区 413\n24.2.11 本节综合练习 417\n24.3 数值字符串转换函数 418\n24.4 分配内存的函数 420\n第25章 链表、二叉树和哈希表 422\n25.1 链表 422\n25.1.1 单链表 422\n25.1.2 双向链表 428\n25.1.3 静态链表 433\n25.1.4 本节综合练习 433\n25.2 二叉树 434\n25.2.1 二叉树的基本概念 434\n25.2.2 排序二叉树 439\n25.3 哈希表 443\n本阶段总结 445\n附录a 字符编码 449\n参考文献 456\n索引 458","pages":"471","images":{"small":"http:\/\/img3.douban.com\/spic\/s4718504.jpg","large":"http:\/\/img3.douban.com\/lpic\/s4718504.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s4718504.jpg"},"alt":"http:\/\/book.douban.com\/subject\/6025290\/","id":"6025290","publisher":"电子工业出版社","isbn10":"7121129825","isbn13":"9787121129827","title":"一站式学习C编程","url":"http:\/\/api.douban.com\/v2\/book\/6025290","alt_title":"Linux C编程一站式学习","author_intro":"宋劲杉，亚嵌教育资深讲师，清华大学自动化系硕士，6年嵌入式系统开发经验，3年嵌入式行业教学经验，精通Linux内核、POSIX、TCP／IP，擅长ARM平台的Linux系统移植和应用开发，目前关注的方向有分布式系统、动态语言。爱好：开源软件、电子音乐、HomeParty","summary":"《一站式学习c编程》有两条线索，一条线索是以linux平台为载体全面深入地介绍c语言的语法和程序的工作原理，另一条线索是介绍程序设计的基本思想和开发调试方法。本书分为两部分：第一部分讲解编程语言和程序设计的基本思想方法，让读者从概念上认识c语言；第二部分结合操作系统和体系结构的知识讲解程序的工作原理，让读者从本质上认识c语言。\n《一站式学习c编程》适合做零基础的初学者学习c语言的第一本教材，帮助读者打下牢固的基础。有一定的编程经验但知识体系不够完整的读者也可以对照本书查缺补漏，从而更深入地理解程序的工作原理。《一站式学习c编程》最初是为北京亚嵌教育研究中心的嵌入式linux系统工程师就业班课程量身定做的教材之一，也适合作为高等院校程序设计基础课程的教材。本书对于c语言的语法介绍得非常全面，对c99标准做了很多解读，因此也可以作为一本精简的c语言语法参 考书。","price":"59.00元"},{"rating":{"max":10,"numRaters":62,"average":"8.3","min":0},"subtitle":"用编程轻松提升逻辑力","author":["啊哈磊"],"pubdate":"2013-9","tags":[{"count":78,"name":"C语言","title":"C语言"},{"count":57,"name":"编程入门","title":"编程入门"},{"count":36,"name":"编程","title":"编程"},{"count":34,"name":"计算机","title":"计算机"},{"count":24,"name":"逻辑思维","title":"逻辑思维"},{"count":15,"name":"C\/C++","title":"C\/C++"},{"count":14,"name":"科普","title":"科普"},{"count":14,"name":"编程，C","title":"编程，C"}],"origin_title":"小学生坐在马桶上都能读懂的C语言编程入门书","image":"http:\/\/img3.douban.com\/mpic\/s27035682.jpg","binding":"平装","translator":[],"catalog":"第1章  编程改变思维\t1\n第1节  为什么要学习编程\t1\n第2节  本书是讲什么的、写给谁看的\t4\n第2章  梦想起航\t7\n第1节  编程的魔力\t7\n第2节  让计算机开口说话\t9\n第3节  多彩一点\t18\n第4节  让计算机做加法\t21\n第5节  数字的家——变量\t25\n第6节  数据输出——我说咋地就咋地\t30\n第7节  数据输入——我说算啥就算啥\t33\n第8节  究竟有多少种小房子\t36\n第9节  拨开云雾见月明\t39\n第10节  逻辑挑战1：交换小房子中的数\t41\n第11节  天啊！这怎么能看懂\t44\n第3章  较量才刚刚开始\t48\n第1节  大于、小于还是等于\t48\n第2节  判断正数\t49\n第3节  偶数判断\t52\n第4节  神器else\t53\n第5节  请告诉我谁大\t55\n第6节  逻辑挑战2：3个数怎么办\t58\n第7节  逻辑挑战3：我要排序\t62\n第8节  运算符总结\t66\n第9节  1＞2究竟对不对\t67\n第10节  讨厌的嵌套\t69\n第11节  if-else语法总结\t72\n第4章  重量级选手登场\t74\n第1节  永不停止的哭声\t74\n第2节  我说几遍就几遍\t78\n第3节  if对while说：我对你很重要\t82\n第4节  求和！求和！！求和！！！\t85\n第5节  逻辑挑战4：60秒倒计时开始\t89\n第6节  这个有点晕——循环嵌套来了\t93\n第7节  逻辑挑战5：奔跑的字母\t97\n第8节  究竟循环了多少次\t101\n第9节  逻辑挑战6：奔跑的小人\t103\n第10节  for隆重登场\t107\n第5章  好戏在后面\t111\n第1节  程序的3种结构\t111\n第2节  啰嗦一下\t112\n第3节  逻辑挑战7：判读质数很简单\t113\n第4节  更快一点：break\t117\n第5节  continue\t119\n第6节  逻辑挑战8：验证哥德巴赫猜想\t120\n第7节  逻辑挑战9：水仙花数\t123\n第8节  逻辑挑战10：解决奥数难题\t127\n第9节  逻辑挑战11：猜数游戏\t130\n第10节  逻辑挑战12：你好坏，关机啦\t134\n第6章  天啊！一大串数正在接近\t136\n第1节  逆序输出\t136\n第2节  申请100个小房子怎么办\t137\n第3节  100个数的逆序\t139\n第4节  逻辑挑战13：陶陶摘苹果\t140\n第5节  逻辑挑战14：一个萝卜一个坑\t143\n第6节  逻辑挑战15：选择排序\t148\n第7节  二维数组\t151\n第8节  剩下的一些东西\t153\n第7章  有了它你能做更多的事\t157\n第1节  字符的妙用\t157\n第2节  多余的回车键\t159\n第3节  字符的本质\t162\n第4节  人名怎么存储呢\t163\n第5节  逻辑挑战16：字母的排序\t167\n第6节  逻辑挑战17：字典序\t169\n第7节  多行字符\t170\n第8节  存储一个迷宫\t173\n第8章  游戏时间到了\t176\n第1节  走迷宫\t176\n第2节  推箱子\t186\n附录A  标识符命名规则\t188\n附录B  运算符的优先级和结合性\t190","pages":"200","images":{"small":"http:\/\/img3.douban.com\/spic\/s27035682.jpg","large":"http:\/\/img3.douban.com\/lpic\/s27035682.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s27035682.jpg"},"alt":"http:\/\/book.douban.com\/subject\/25716079\/","id":"25716079","publisher":"电子工业出版社","isbn10":"7121213362","isbn13":"9787121213366","title":"啊哈C！思考快你一步","url":"http:\/\/api.douban.com\/v2\/book\/25716079","alt_title":"小学生坐在马桶上都能读懂的C语言编程入门书","author_intro":"啊哈磊，原名纪磊，毕业于武汉大学。曾在中科院玩单片机，在微软亚洲研究院开发“爬虫”，在国际会议上发表论文，也做过老师，是全国青少年信息学奥林匹克金牌教练。非常喜欢小朋友，每天都过得很开心。为什么叫“啊哈磊”呢？因为这是一个很喜庆的名字。新浪微博：@啊哈磊  人人网公共主页：renren.com\/601196462","summary":"这是一本非常有趣的编程启蒙书，全书从中小学生的角度来讲述，没有生涩的内容，取而代之的是生动活泼的漫画和风趣幽默的文字。并配合超萌的编程软件，从开始学习与计算机对话到自己独立制作一个游戏，由浅入深地讲述编程的思维。同时，与计算机展开的逻辑较量一定会让你觉得很有意思。你可以在茶余饭后阅读本书，甚至蹲在马桶上时也可以看得津津有味。编程将会改变我们的思维，教会我们如何思考，让我们的思维插上计算机的翅膀，以一种全新的方式来看世界。现在就让我们一起走进计算机编程的神奇世界，探索和发现计算机编程的魔力吧。","price":"39.00元"},{"rating":{"max":10,"numRaters":1,"average":"0.0","min":0},"subtitle":"JIATING DIANNAO · BIANCHENG FANLI HUICUI","author":["林舒畅","林辉"],"pubdate":"1994-2","tags":[],"origin_title":"家庭电脑 · 编程范例荟萃","image":"http:\/\/img3.douban.com\/mpic\/s25811715.jpg","binding":"平装","translator":[],"catalog":"","pages":"143","images":{"small":"http:\/\/img3.douban.com\/spic\/s25811715.jpg","large":"http:\/\/img3.douban.com\/lpic\/s25811715.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s25811715.jpg"},"alt":"http:\/\/book.douban.com\/subject\/21945796\/","id":"21945796","publisher":"福建科学技术出版社","isbn10":"7533507223","isbn13":"9787533507220","title":"家庭电脑 · 编程范例荟萃","url":"http:\/\/api.douban.com\/v2\/book\/21945796","alt_title":"家庭电脑 · 编程范例荟萃","author_intro":"","summary":"90年代早期的BASIC、数据库、Pascal和C、以及汇编语言的入门范例书籍.","price":"4.40元"},{"rating":{"max":10,"numRaters":2529,"average":"8.4","min":0},"subtitle":"微软技术面试心得","author":["《编程之美》小组 编"],"pubdate":"2008-3","tags":[{"count":1764,"name":"算法","title":"算法"},{"count":1198,"name":"编程之美","title":"编程之美"},{"count":1086,"name":"编程","title":"编程"},{"count":816,"name":"面试","title":"面试"},{"count":666,"name":"计算机","title":"计算机"},{"count":447,"name":"程序设计","title":"程序设计"},{"count":418,"name":"微软","title":"微软"},{"count":351,"name":"思维","title":"思维"}],"origin_title":"","image":"http:\/\/img5.douban.com\/mpic\/s9233126.jpg","binding":"平装","translator":[],"catalog":"第1章 游戏之乐--游戏中碰到的题目\n1.1 让CPU占用率曲线听你指挥\n1.2 中国象棋将帅问题\n1.3 一摞烙饼的排序\n1.4 买书问题\n1.5 快速找出故障机器\n1.6 饮料供货\n1.7 光影切割问题\n1.8 小飞的电梯调度算法\n1.9 高效率地安排见面会\n1.10 双线程高效下载\n1.11 NIM（1）一排石头的游戏\n1.12 NIM（2）“拈”游戏分析\n1.13 NIM（3）两堆石头的游戏\n1.14 连连看游戏设计\n1.15 构造数独\n1.16 24点游戏\n1.17 俄罗斯方块游戏\n1.18 挖雷游戏\n第2章 数字之魅--数字中的技巧\n2.1 求二进制数中1的个数\n2.2 不要被阶乘吓倒\n2.3 寻找发帖“水王”\n2.4 1的数目\n2.5 寻找最大的K个数\n2.6 精确表达浮点数\n2.7 最大公约数问题\n2.8 找符合条件的整数\n2.9 斐波那契（Fibonacci）数列\n2.10 寻找数组中的最大值和最小值\n2.11 寻找最近点对\n2.12 快速寻找满足条件的两个数\n2.13 子数组的最大乘积\n2.14 求数组的子数组之和的最大值\n2.15 子数组之和的最大值（二维）\n2.16 求数组中最长递增子序列\n2.17 数组循环移位\n2.18 数组分割\n2.19 区间重合判断\n2.20 程序理解和时间分析\n2.21 只考加法的面试题\n第3章 结构之法--字符串及链表的探索\n3.1 字符串移位包含的问题\n3.2 电话号码对应英语单词\n3.3 计算字符串的相似度\n3.4 从无头单链表中删除节点\n3.5 最短摘要的生成\n3.6 编程判断两个链表是否相交\n3.7 队列中取最大值操作问题\n3.8 求二叉树中节点的最大距离\n3.9 重建二叉树\n3.10 分层遍历二叉树\n3.11 程序改错\n第4章 数学之趣--数学游戏的乐趣\n4.1 金刚坐飞机问题\n4.2 瓷砖覆盖地板\n4.3 买票找零\n4.4 点是否在三角形内\n4.5 磁带文件存放优化\n4.6 桶中取黑白球\n4.7 蚂蚁爬杆\n4.8 三角形测试用例\n4.9 数独知多少\n4.10 数字哑谜和回文\n4.11 挖雷游戏的概率","ebook_url":"http:\/\/read.douban.com\/ebook\/1523295\/","pages":"327","images":{"small":"http:\/\/img5.douban.com\/spic\/s9233126.jpg","large":"http:\/\/img5.douban.com\/lpic\/s9233126.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s9233126.jpg"},"alt":"http:\/\/book.douban.com\/subject\/3004255\/","id":"3004255","publisher":"电子工业出版社","isbn10":"7121060744","isbn13":"9787121060748","title":"编程之美","url":"http:\/\/api.douban.com\/v2\/book\/3004255","alt_title":"程式之美","author_intro":"","summary":"这本书收集了约60道算法和程序设计题目，这些题目大部分在近年的笔试、面试中出现过，或者是被微软员工热烈讨论过。作者试图从书中各种有趣的问题出发，引导读者发现问题，分析问题，解决问题，寻找更优的解法。本书的内容分为下面几个部分：\n（1）游戏之乐：从游戏和其他有趣问题出发，化繁为简，分析总结。\n（2）数字之魅：编程的过程实际上就是和数字及字符打交道的过程。这一部分收集了一些好玩的对数字进行处理的题目。\n（3）结构之法：汇集了常见的对字符串、链表、队列，以及树等进行操作的题目。\n（4）数学之趣：列举了一些不需要写具体程序的数学问题，锻炼读者的抽象思维能力。\n书中绝大部分题目都提供了详细的解说。 每道题目后面还有一至两道扩展问题，供读者进一步钻研。\n书中还讲述了面试的各种小故事，告诉读者微软需要什么样的技术人才，重视什么样的能力，如何甄别人才。回答读者关于IT业面试，招聘，职业发展的疑问。这本书的很多题目会出现在IT 行业的各种笔试、面试中，但这本书更深层的意义在于引导读者思考，和读者共享思考之乐，编程之美。","ebook_price":"22.00","price":"40.00元"},{"rating":{"max":10,"numRaters":1776,"average":"9.1","min":0},"subtitle":"","author":["Eric S. Raymond"],"pubdate":"2006-2","tags":[{"count":2106,"name":"UNIX","title":"UNIX"},{"count":924,"name":"编程","title":"编程"},{"count":747,"name":"编程艺术","title":"编程艺术"},{"count":541,"name":"计算机","title":"计算机"},{"count":334,"name":"文化","title":"文化"},{"count":329,"name":"programming","title":"programming"},{"count":262,"name":"linux","title":"linux"},{"count":226,"name":"软件开发","title":"软件开发"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s1631790.jpg","binding":"平装","translator":["姜宏","何源","蔡晓俊"],"catalog":"","pages":"525","images":{"small":"http:\/\/img3.douban.com\/spic\/s1631790.jpg","large":"http:\/\/img3.douban.com\/lpic\/s1631790.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s1631790.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1467587\/","id":"1467587","publisher":"电子工业出版社","isbn10":"7121021161","isbn13":"9787121021169","title":"UNIX编程艺术","url":"http:\/\/api.douban.com\/v2\/book\/1467587","alt_title":"","author_intro":"","summary":"本书主要介绍了Unix系统领域中的设计和开发哲学、思想文化体系、原则与经验，由公认的Unix编程大师、开源运动领袖人物之一Eric S. Raymond倾力多年写作而成。包括Unix设计者在内的多位领域专家也为本书贡献了宝贵的内容。本书内容涉及社群文化、软件开发设计与实现，覆盖面广、内容深邃，完全展现了作者极其深厚的经验积累和领域智慧。","price":"59.00元"},{"rating":{"max":10,"numRaters":1426,"average":"9.2","min":0},"subtitle":"","author":["Jon Bentley"],"pubdate":"2008-10","tags":[{"count":1323,"name":"算法","title":"算法"},{"count":1223,"name":"编程","title":"编程"},{"count":674,"name":"编程艺术","title":"编程艺术"},{"count":570,"name":"计算机","title":"计算机"},{"count":454,"name":"程序设计","title":"程序设计"},{"count":286,"name":"算法与数据结构","title":"算法与数据结构"},{"count":258,"name":"programming","title":"programming"},{"count":235,"name":"计算机科学","title":"计算机科学"}],"origin_title":"Programming Pearls Second Edition","image":"http:\/\/img3.douban.com\/mpic\/s4687321.jpg","binding":"平装","translator":["黄倩","钱丽艳"],"catalog":"第一部分　基础\n第1章　开篇\n1.1　一次友好的对话\n1.2　准确的问题描述\n1.3　程序设计\n1.4　实现概要\n1.5　原理\n1.6　习题\n1.7　深入阅读\n第2章　啊哈！算法\n2.1　三个问题\n2.2　无处不在的二分搜索\n2.3　基本操作的威力\n2.4　排序\n2.5　原理\n2.6　习题\n2.7　深入阅读\n2.8　变位词程序的实现（边栏）\n第3章　数据决定程序结构\n3.1　一个调查程序\n.　　3.2　格式信函编程\n3.3　一组示例\n3.4　结构化数据\n3.5　用于特殊数据的强大工具\n3.6　原理\n3.7　习题\n3.8　深入阅读\n第4章　编写正确的程序\n4.1　二分搜索的挑战\n4.2　编写程序\n4.3　理解程序\n4.4　原理\n4.5　程序验证的角色\n4.6　习题\n4.7　深入阅读\n第5章　编程小事\n5.1　从伪代码到c程序\n5.2　测试工具\n5.3　断言的艺术\n5.4　自动测试\n5.5　计时\n5.6　完整的程序\n5.7　原理\n5.8　习题\n5.9　深入阅读\n5.10　调试（边栏）\n第二部分　性能\n第6章　程序性能分析\n6.1　实例研究\n6.2　设计层面\n6.3　原理\n6.4　习题\n6.5　深入阅读\n第7章　粗略估算\n7.1　基本技巧\n7.2　性能估计\n7.3　安全系数\n7.4　little定律\n7.5　原理\n7.6　习题\n7.7　深入阅读\n7.8　日常生活中的速算（边栏）\n第8章　算法设计技术\n8.1　问题及简单算法\n8.2　两个平方算法\n8.3　分治算法\n8.4　扫描算法\n8.5　实际运行时间\n8.6　原理\n8.7　习题\n8.8　深入阅读\n第9章　代码调优\n9.1　典型的故事\n9.2　急救方案集锦\n9.3　大手术——二分搜索\n9.4　原理\n9.5　习题\n9.6　深入阅读\n第10章　节省空间\n10.1　关键在于简单\n10.2　示例问题\n10.3　数据空间技术\n10.4　代码空间技术\n10.5　原理\n10.6　习题\n10.7　深入阅读\n10.8　巨大的节省（边栏）\n第三部分　应用\n第11章　排序\n11.1　插入排序\n11.2　一种简单的快速排序\n11.3　更好的几种快速排序\n11.4　原理\n11.5　习题\n11.6　深入阅读\n第12章　取样问题\n12.1　问题\n12.2　一种解决方案\n12.3　设计空间\n12.4　原理\n12.5　习题\n12.6　深入阅读\n第13章　搜索\n13.1　接口\n13.2　线性结构\n13.3　二分搜索树\n13.4　用于整数的结构\n13.5　原理\n13.6　习题\n13.7　深入阅读\n13.8　一个实际搜索问题（边栏）\n第14章　堆\n14.1　数据结构\n14.2　两个关键函数\n14.3　优先级队列\n14.4　一种排序算法\n14.5　原理\n14.6　习题\n14.7　深入阅读\n第15章　字符串\n15.1　单词\n15.2　短语\n15.3　生成文本\n15.4　原理\n15.5　习题\n15.6　深入阅读\n第1版跋\n第2版跋\n附录a　算法分类\n附录b　估算测试\n附录c　时空开销模型\n附录d　代码调优法则\n附录e　用于搜索的c++类\n部分习题提示\n部分习题答案\n索引","pages":"228","images":{"small":"http:\/\/img3.douban.com\/spic\/s4687321.jpg","large":"http:\/\/img3.douban.com\/lpic\/s4687321.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s4687321.jpg"},"alt":"http:\/\/book.douban.com\/subject\/3227098\/","id":"3227098","publisher":"人民邮电出版社","isbn10":"711517928X","isbn13":"9787115179289","title":"编程珠玑","url":"http:\/\/api.douban.com\/v2\/book\/3227098","alt_title":"Programming Pearls Second Edition","author_intro":"Jon Bentley 世界著名计算机科学家，被誉为影响算法发展的十位大师之一。他先后任职于卡内基-梅隆大学（1976~1982）、贝尔实验室（1982~2001）和Avaya实验室（2001年至今）。在卡内基-梅隆大学担任教授期间，他培养了包括Tcl语言设计者John Ousterhout、Java语言设计者James Gosling、《算法导论》作者之一Charles Leiserson在内的许多计算机科学大家。2004年荣获Dr.Dobb's程序设计卓越奖。","summary":"本书是计算机科学方面的经典名著。书的内容围绕程序设计人员面对的一系列实际问题展开。作者Jon Bentley 以其独有的洞察力和创造力，引导读者理解这些问题并学会解决方法，而这些正是程序员实际编程生涯中至关重要的。本书的特色是通过一些精心设计的有趣而又颇具指导意义的程序，对实用程序设计技巧及基本设计原则进行了透彻而睿智的描述，为复杂的编程问题提供了清晰而完备的解决思路。本书对各个层次的程序员都具有很高的阅读价值。.\n多年以来，当程序员们推选出最心爱的计算机图书时，《编程珠玑》总是位列前列。正如自然界里珍珠出自细沙对牡蛎的磨砺，计算机科学大师Jon Bentley以其独有的洞察力和创造力，从磨砺程序员的实际问题中凝结出一篇篇不朽的编程“珠玑”，成为世界计算机界名刊《ACM通讯》历史上最受欢迎的专栏，最终结集为两部不朽的计算机科学经典名著，影响和激励着一代又一代程序员和计算机科学工作者。本书为第一卷，主要讨论计算机科学中最本质的问题：如何正确选择和高效地实现算法。..\n在书中，作者选取许多具有典型意义的复杂编程和算法问题，生动描绘了历史上众大师们在探索解决方案中发生的轶事、走过的弯路和不断精益求精的历程，引导读者像真正的程序员和软件工程师那样富于创新性地思考，并透彻阐述和总结了许多独特而精妙的设计原则、思考和解决问题的方法以及实用程序设计技巧。解决方案的代码均以C\/C++语言编写，不仅有趣，而且有很大的实战示范意义。每章后所附习题极具挑战性和启发性，书末给出了简洁的解答。...","price":"39.00元"},{"rating":{"max":10,"numRaters":1762,"average":"9.5","min":0},"subtitle":"第2版","author":["W.Richard Stevens","Stephen A.Rago"],"pubdate":"2006年","tags":[{"count":1800,"name":"unix","title":"unix"},{"count":1106,"name":"编程","title":"编程"},{"count":761,"name":"Linux","title":"Linux"},{"count":458,"name":"计算机","title":"计算机"},{"count":454,"name":"programming","title":"programming"},{"count":424,"name":"经典","title":"经典"},{"count":258,"name":"程序设计","title":"程序设计"},{"count":235,"name":"apue","title":"apue"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s4436543.jpg","binding":"平装","translator":["尤晋元","张亚英","戚正伟"],"catalog":"","pages":"780页","images":{"small":"http:\/\/img3.douban.com\/spic\/s4436543.jpg","large":"http:\/\/img3.douban.com\/lpic\/s4436543.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s4436543.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1788421\/","id":"1788421","publisher":"人民邮电出版社","isbn10":"7115147310","isbn13":"9787115147318","title":"UNIX环境高级编程","url":"http:\/\/api.douban.com\/v2\/book\/1788421","alt_title":"Advanced Programming in the UNIX Environment","author_intro":"作者：(美)史蒂文斯 (美)拉戈 译者：尤晋元 张亚英 戚正伟\nW.Richard Stevens，备受赞誉的技术作家，生前著有多种经典的传世之作，包括《UNIX网络编程》（两卷本）、《TCP\/IP详解》（三卷本）和本书第1版。 尤晋元，上海交通大学计算机科学及工程系教授、博士生导师。在科研方面，主要从事操作系统和分布对象计算技术方面的研究；在教学方面，长期承担操作系统及分布计算等课程的教学工作。主编和翻译了多本操作系统教材和参考书，包括《UNIX操作系统教程》、《UNIX高级编程技术》、《UNIX环境高级编程》和《操作系统：设计与实现》等。","summary":"本书是被誉为UNIX编程“圣经”的Advanced Programming in the UNIX Environment一书的更新版。在本书第1版出版后的十几年中，UNIX行业已经有了巨大的变化，特别是影响UNIX编程接口的有关标准变化很大。本书在保持了前一版风格的基础上，根据最新的标准对内容进行了修订和增补，反映了最新的技术发展。书中除了介绍UNIX文件和目录、标准I\/O库、系统数据文件和信息、进程环境、进程控制、进程关系、信号、线程、线程控制、守护进程、各种I\/O、进程间通信、网络IPC、伪终端等方面的内容，还在此基础上介绍了多个应用示例，包括如何创建数据库函数库以及如何与网络打印机通信等。此外，还在附录中给出了函数原型和部分习题的答案。\r\n    本书内容权威，概念清晰，阐述精辟，对于所有层次UNIX程序员都是一本不可或缺的参考书。","price":"99.00元"},{"rating":{"max":10,"numRaters":2011,"average":"9.1","min":0},"subtitle":"","author":["[美] Bruce Eckel"],"pubdate":"2007-6","tags":[{"count":1731,"name":"Java","title":"Java"},{"count":599,"name":"编程思想","title":"编程思想"},{"count":512,"name":"TinkingInJava","title":"TinkingInJava"},{"count":448,"name":"编程","title":"编程"},{"count":356,"name":"计算机","title":"计算机"},{"count":262,"name":"程序设计","title":"程序设计"},{"count":214,"name":"经典","title":"经典"},{"count":146,"name":"Programming","title":"Programming"}],"origin_title":"Thinking in Java","image":"http:\/\/img5.douban.com\/mpic\/s2553047.jpg","binding":"平装","translator":["陈昊鹏"],"catalog":"读者评论\n前言\n简介\n第1章 对象导论\n1.1 抽象过程\n1.2 每个对象都有一个接口\n1.3 每个对象都提供服务\n1.4 被隐藏的具体实现\n1.5 复用具体实现\n1.6 继承\n1.6.1 “是一个”（is-a）与“像是一个”（is-like-a）关系\n1.7 伴随多态的可互换对象\n1.8 单根继承结构\n1.9 容器\n1.9.1 参数化类型（范型）\n1.10 对象的创建和生命期\n1.11 异常处理：处理错误\n1.12 并发编程\n1.13 Java与Internet\n1.13.1 Web是什么\n1.13.2 客户端编程\n1.13.3 服务器端编程\n1.22 总结\n第2章 一切都是对象\n2.1 用引用操纵对象\n2.2 必须由你创建所有对象\n2.2.1 存储到什么地方\n2.2.2 特例：基本类型\n2.2.3 Java中的数组\n2.3 永远不需要销毁对象\n2.3.1 作用域\n2.3.2 对象的作用域\n2.4 创建新的数据类型：类\n2.4.1 域和方法\n2.4.2 基本成员默认值\n2.5 方法、参数和返回值\n2.5.1 参数列表\n2.6 构建一个Java程序\n2.6.1 名字可见性\n2.6.2 运用其他构件\n2.6.3 static 关键字\n2.7 你的第一个Java程序\n编译和运行\n2.8 注释和嵌入式文档\n2.8.1 注释文档\n2.8.2 语法\n2.8.3 嵌入式HTML\n2.8.4 一些标签示例\n2.8.5 文档示例\n2.9 编码风格\n2.10 总结\n2.11 练习\n第3章 操作符\n3.1 更简单的打印语句\n3.2 使用Java操作符\n3.3 优先级\n3.4 赋值\n3.4.1 方法调用中的别名问题\n3.5 算术操作符\n3.5.1 一元加、减操作符\n3.6 自动递增和递减\n3.7 关系操作符\n3.7.1 测试对象的等价性\n3.8 逻辑操作符\n3.8.1 短路\n3.9 直接常量\n3.9.1 指数记数法\n3.10 按位操作符\n3.11 移位操作符\n3.12 三元操作符 if-else\n3.13 字符串操作符 + 和 +=\n3.14 使用操作符时常犯的错误\n3.15 类型转换操作符\n3.15.1 截尾和舍入\n3.15.2提升\n3.16 Java没有“sizeof”\n3.17 操作符小结\n3.18 总结\n第4章 控制执行流程\n4.1 true和false\n4.2 if-else\n4.3 迭代\n4.3.1 do-while\n4.3.2 for\n4.3.3 逗号操作符\n4.4 Foreach语法\n4.5 return\n4.6 break和 continue\n4.7 臭名昭著的“goto”\n4.8 switch\n4.9 总结\n第5章 初始化与清理\n5.1 用构造器确保初始化\n5.2 方法重载\n5.2.1 区分重载方法\n5.2.2 涉及基本类型的重载\n5.2.3 以返回值区分重载方法\n5.3 缺省构造器\n5.4 this关键字\n5.4.1 在构造器中调用构造器\n5.4.2 static的含义\n5.5 清理：终结处理和垃圾回收\n5.5.1 finalize()的用途何在\n5.5.2 你必须实施清理\n5.5.3 终结条件\n5.5.4 垃圾回收器如何工作\n5.6 成员初始化\n5.6.1 指定初始化\n5.7 构造器初始化\n5.7.1 初始化顺序\n5.7.2. 静态数据的初始化\n5.7.3. 显式的静态初始化\n5.7.4. 非静态实例初始化\n5.8 数组初始化\n5.8.1 可变参数列表\n5.9 枚举类型\n5.10 总结\n第6章 访问权限控制\n第7章 复用类\n第8章 多态\n第9章 接口\n第10章 内部类\n第11章 持有对象\n第12章 通过异常处理错误\n第13章 字符串\n第14章 类型信息\n第15章 泛型\n第16章 数组\n第17章 容器深入研究\n第18章 Java I\/O系统\n第19章 枚举类型\n第20章 注解\n第21章 并发\n第22章 图形化用户界面\n附录A 补充材料\n可下载的补充材料\nThinking in C：Java的基础\nJava编程思想 研讨课\nHands-on Java研讨课CD\nThinking in Objects研讨课\nThinking in Enterprise Java\nThinking in Patterns(with Java)\nThinking in Patterns研讨课\n设计咨询与复审\n附录B 资源\n软件\n编辑器与IDE\n书籍\n分析与设计\nPython\n我的著作列表\n索引","pages":"880","images":{"small":"http:\/\/img5.douban.com\/spic\/s2553047.jpg","large":"http:\/\/img5.douban.com\/lpic\/s2553047.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s2553047.jpg"},"alt":"http:\/\/book.douban.com\/subject\/2130190\/","id":"2130190","publisher":"机械工业出版社","isbn10":"7111213823","isbn13":"9787111213826","title":"Java编程思想 （第4版）","url":"http:\/\/api.douban.com\/v2\/book\/2130190","alt_title":"Thinking in Java","author_intro":"Bruce Eckel是MindView公司（www.MindView.net）的总裁，该公司向客户提供软件咨询和培训。他是C++标准委员会拥有表决权的成员之一，拥有应用物理学学士和计算机工程硕士学位。除本书外，他还是《C++编程思想》的作者，并与人合著了《C++编程思想 第2卷》（这两本书的英文影印版及中文版均已由机械工业出版社引进出版）及其他著作。他已经发表了150多篇论文，还经常参加世界各地的研讨会并进行演讲。","summary":"本书赢得了全球程序员的广泛赞誉，即使是最晦涩的概念，在Bruce Eckel的文字亲和力和小而直接的编程示例面前也会化解于无形。从Java的基础语法到最高级特性（深入的面向对象概念、多线程、自动项目构建、单元测试和调试等），本书都能逐步指导你轻松掌握。\n从本书获得的各项大奖以及来自世界各地的读者评论中，不难看出这是一本经典之作。本书的作者拥有多年教学经验，对C、C++以及Java语言都有独到、深入的见解，以通俗易懂及小而直接的示例解释了一个个晦涩抽象的概念。本书共22章，包括操作符、控制执行流程、访问权限控制、复用类、多态、接口、通过异常处理错误、字符串、泛型、数组、容器深入研究、Java I\/O系统、枚举类型、并发以及图形化用户界面等内容。这些丰富的内容，包含了Java语言基础语法以及高级特性，适合各个层次的Java程序员阅读，同时也是高等院校讲授面向对象程序设计语言以及Java语言的绝佳教材和参考书。\n第4版特点：\n适合初学者与专业人员的经典的面向对象叙述方式，为更新的Java SE5\/6增加了新的示例和章节。\n 测验框架显示程序输出。","price":"108.00元"},{"rating":{"max":10,"numRaters":881,"average":"9.0","min":0},"subtitle":"","author":["TOBY SEGARAN"],"pubdate":"2009-1","tags":[{"count":1188,"name":"数据挖掘","title":"数据挖掘"},{"count":719,"name":"机器学习","title":"机器学习"},{"count":687,"name":"算法","title":"算法"},{"count":520,"name":"人工智能","title":"人工智能"},{"count":426,"name":"集体智慧","title":"集体智慧"},{"count":323,"name":"编程","title":"编程"},{"count":272,"name":"计算机","title":"计算机"},{"count":172,"name":"web2.0","title":"web2.0"}],"origin_title":"Programming Collective Intelligence","image":"http:\/\/img3.douban.com\/mpic\/s3350961.jpg","binding":"平装","translator":["莫映","王开福"],"catalog":"前言\n第1章　集体智慧导言\n什么是集体智慧\n什么是机器学习\n机器学习的局限\n真实生活中的例子\n学习型算法的其他用途\n第2章　提供推荐\n协作型过滤\n搜集偏好\n寻找相近的用户\n推荐物品\n匹配商品\n构建一个基于del.icio.us的链接推荐系统\n基于物品的过滤\n使用MovieLens数据集\n基于用户进行过滤还是基于物品进行过滤\n练习\n第3章　发现群组\n监督学习和无监督学习\n单词向量\n分级聚类\n绘制树状图\n列聚类\nK-均值聚类\n针对偏好的聚类\n以二维形式展现数据\n有关聚类的其他事宜\n练习\n第4章　搜索与排名\n搜索引擎的组成\n一个简单的爬虫程序\n建立索引\n查询\n基于内容的排名\n利用外部回指链接\n从点击行为中学习\n练习\n第5章　优化\n组团旅游\n描述题解\n成本函数\n随机搜索\n爬山法\n模拟退火算法\n遗传算法\n真实的航班搜索\n涉及偏好的优化\n网络可视化\n其他可能的应用场合\n练习\n第6章　文档过滤\n过滤垃圾信息\n文档和单词\n对分类器进行训练\n计算概率\n朴素分类器\n费舍尔方法\n将经过训练的分类器持久化\n过滤博客订阅源\n对特征检测的改进\n使用Akismet\n替代方法\n练习\n第7章　决策树建模\n预测注册用户\n引入决策树\n对树进行训练\n选择最合适的拆分方案\n以递归方式构造树\n决策树的显示\n对新的观测数据进行分类\n决策树的剪枝\n处理缺失数据\n处理数值型结果\n对住房价格进行建模\n对“热度”评价进行建模\n什么时候使用决策树\n练习\n第8章　构建价格模型\n构造一个样本数据集\nk-最近邻算法\n为近邻分配权重\n交叉验证\n不同类型的变量\n对缩放结果进行优化\n不对称分布\n使用真实数据——eBay API\n何时使用k-最近邻算法\n练习\n第9章　高阶分类：核方法与SVM\n婚介数据集\n数据中的难点\n基本的线性分类\n分类特征\n对数据进行缩放处理\n理解核方法\n支持向量机\n使用LIBSVM\n基于Facebook的匹配\n练习\n第10章　寻找独立特征\n搜集一组新闻\n先前的方法\n非负矩阵因式分解\n结果呈现\n利用股票市场的数据\n练习\n第11章　智能进化\n什么是遗传编程\n将程序以树形方式表示\n构造初始种群\n测试题解\n对程序进行变异\n交叉\n构筑环境\n一个简单的游戏\n更多可能性\n练习\n第12章　算法总结\n贝叶斯分类器\n决策树分类器\n神经网络\n支持向量机\nk-最近邻\n聚类\n多维缩放\n非负矩阵因式分解\n优化\n附录A：第三方函数库\n附录B：数学公式\n索引","pages":"334","images":{"small":"http:\/\/img3.douban.com\/spic\/s3350961.jpg","large":"http:\/\/img3.douban.com\/lpic\/s3350961.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s3350961.jpg"},"alt":"http:\/\/book.douban.com\/subject\/3288908\/","id":"3288908","publisher":"电子工业出版社","isbn10":"7121075393","isbn13":"9787121075391","title":"集体智慧编程","url":"http:\/\/api.douban.com\/v2\/book\/3288908","alt_title":"Programming Collective Intelligence","author_intro":"Toby Segaran是Genstruct公司的软件开发主管，这家公司涉足计算生物领域，他本人的职责是设计算法，并利用数据挖掘技术来辅助了解药品机理。Toby Segaran还为其他几家公司和数个开源项目服务，帮助它们从收集到的数据当中分析并发掘价值。除此以外，Toby Segaran还建立了几个免费的网站应用，包括流行的tasktoy和Lazybase。他非常喜欢滑雪与品酒，其博客地址是blog.kiwitobes.com，现居于旧金山。","summary":"本书以机器学习与计算统计为主题背景，专门讲述如何挖掘和分析Web上的数据和资源，如何分析用户体验、市场营销、个人品味等诸多信息，并得出有用的结论，通过复杂的算法来从Web网站获取、收集并分析用户的数据和反馈信息，以便创造新的用户价值和商业价值。全书内容翔实，包括协作过滤技术（实现关联产品推荐功能）、集群数据分析（在大规模数据集中发掘相似的数据子集）、搜索引擎核心技术（爬虫、索引、查询引擎、PageRank算法等）、搜索海量信息并进行分析统计得出结论的优化算法、贝叶斯过滤技术（垃圾邮件过滤、文本过滤）、用决策树技术实现预测和决策建模功能、社交网络的信息匹配技术、机器学习和人工智能应用等。\n本书是Web开发者、架构师、应用工程师等的绝佳选择。","price":"59.80元"},{"rating":{"max":10,"numRaters":1466,"average":"9.2","min":0},"subtitle":"","author":["Peter Van Der Linden"],"pubdate":"2008-2","tags":[{"count":811,"name":"C语言","title":"C语言"},{"count":475,"name":"编程","title":"编程"},{"count":324,"name":"c","title":"c"},{"count":252,"name":"计算机","title":"计算机"},{"count":237,"name":"C专家编程","title":"C专家编程"},{"count":216,"name":"C\/C++","title":"C\/C++"},{"count":215,"name":"C","title":"C"},{"count":197,"name":"程序设计","title":"程序设计"}],"origin_title":"Expert C Programming","image":"http:\/\/img5.douban.com\/mpic\/s2846868.jpg","binding":"平装","translator":["徐波"],"catalog":"第1章 C：穿越时空的迷雾\n1.1 C语言的史前阶段\n1.2 C语言的早期体验\n1.3 标准I\/O库和C预处理器\n1.4 K&R C\n1.5 今日之ANSI C\n1.6 它很棒，但它符合标准吗\n1.7 编译限制\n1.8 ANSI C标准的结构\n1.9 阅读ANSI C标准，寻找乐趣和裨益\n1.10 “安静的改变”究竟有多少安静\n1.11 轻松一下——由编译器定义的Pragmas效果\n第2章 这不是Bug，而是语言特性\n2.1 这关语言特性何事，在Fortran里这就是Bug呀\n2.2 多做之过\n2.3 误做之过\n2.4 少做之过\n2.5 轻松一下——有些特性确实就是Bug\n2.6 参考文献\n第3章 分析C语言的声明\n3.1 只有编译器才会喜欢的语法\n3.2 声明是如何形成的\n3.3 优先级规则\n3.4 通过图表分析C语言的声明\n3.5 typedef可以成为你的朋友\n3.6 typedef int x[10]和#define x int[10]的区别\n3.7 typedef struct foo{ ... foo; }的含义\n3.8 理解所有分析过程的代码段\n3.9 轻松一下——驱动物理实体的软件\n第4章 令人震惊的事实：数组和指针并不相同\n4.1 数组并非指针\n4.2 我的代码为什么无法运行\n4.3 什么是声明，什么是定义\n4.4 使声明与定义相匹配\n4.5 数组和指针的其他区别\n4.6 轻松一下——回文的乐趣\n第5章 对链接的思考\n5.1 函数库、链接和载入\n5.2 动态链接的优点\n5.3 函数库链接的5个特殊秘密\n5.4 警惕Interpositioning\n5.5 产生链接器报告文件\n5.6 轻松一下——看看谁在说话：挑战Turing测验\n第6章 运动的诗章：运行时数据结构\n6.1 a.out及其传说\n6.2 段\n6.3 操作系统在a.out文件里干了些什么\n6.4 C语言运行时系统在a.out里干了些什么\n6.5 当函数被调用时发生了什么：过程活动记录\n6.6 auto和static关键字\n6.7 控制线程\n6.8 setjmp和longjmp\n6.9 UNIX中的堆栈段\n6.10 MS-DOS中的堆栈段\n6.11 有用的C语言工具\n6.12 轻松一下——卡耐基-梅隆大学的编程难题\n6.13 只适用于高级学员阅读的材料\n第7章 对内存的思考\n7.1 Intel 80x86系列\n7.2 Intel 80x86内存模型以及它的工作原理\n7.3 虚拟内存\n7.4 Cache存储器\n7.5 数据段和堆\n7.6 内存泄漏\n7.7 总线错误\n7.8 轻松一下——“Thing King”和“页面游戏”\n第8章 为什么程序员无法分清万圣节和圣诞节\n8.1 Portzebie度量衡系统\n8.2 根据位模式构筑图形\n8.3 在等待时类型发生了变化\n8.4 原型之痛\n8.5 原型在什么地方会失败\n8.6 不需要按回车键就能得到一个字符\n8.7 用C语言实现有限状态机\n8.8 软件比硬件更困难\n8.9 如何进行强制类型转换，为何要进行类型强制转换\n8.10 轻松一下——国际C语言混乱代码大赛\n第9章 再论数组\n9.1 什么时候数组与指针相同\n9.2 为什么会发生混淆\n9.3 为什么C语言把数组形参当作指针\n9.4 数组片段的下标\n9.5 数组和指针可交换性的总结\n9.6 C语言的多维数组\n9.7 轻松一下——软件\/硬件平衡\n第10章 再论指针\n10.1 多维数组的内存布局\n10.2 指针数组就是Iliffe向量\n10.3 在锯齿状数组上使用指针\n10.4 向函数传递一个一维数组\n10.5 使用指针向函数传递一个多维数组\n10.6 使用指针从函数返回一个数组\n10.7 使用指针创建和使用动态数组\n10.8 轻松一下——程序检验的限制\n第11章 你懂得C，所以C++不在话下\n11.1 初识OOP\n11.2 抽象——取事物的本质特性\n11.3 封装——把相关的类型、数据和函数组合在一起\n11.4 展示一些类——用户定义类型享有和预定义类型一样的权限\n11.5 访问控制\n11.6 声明\n11.7 如何调用成员函数\n11.8 继承——复用已经定义的操作\n11.9 多重继承——从两个或更多的基类派生\n11.10 重载——作用于不同类型的同一操作具有相同的名字\n11.11 C++如何进行操作符重载\n11.12 C++的输入\/输出(I\/O)\n11.13 多态——运行时绑定\n11.14 解释\n11.15 C++如何表现多态\n11.16 新奇玩意——多态\n11.17 C++的其他要点\n11.18 如果我的目标是那里，我不会从这里起步\n11.19 它或许过于复杂，但却是惟一可行的方案\n11.20 轻松一下——死亡计算机协会\n11.21 更多阅读材料\n附录A 程序员工作面试的秘密\n附录B 术语表","pages":"291","images":{"small":"http:\/\/img5.douban.com\/spic\/s2846868.jpg","large":"http:\/\/img5.douban.com\/lpic\/s2846868.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s2846868.jpg"},"alt":"http:\/\/book.douban.com\/subject\/2377310\/","id":"2377310","publisher":"人民邮电出版社","isbn10":"7115171807","isbn13":"9787115171801","title":"C专家编程","url":"http:\/\/api.douban.com\/v2\/book\/2377310","alt_title":"Expert C Programming","author_intro":"","summary":"《C专家编程》展示了最优秀的C程序员所使用的编码技巧，并专门开辟了一章对C++的基础知识进行了介绍。\n书中C的历史、语言特性、声明、数组、指针、链接、运行时、内存以及如何进一步学习C++等问题进行了细致的讲解和深入的分析。全书撷取几十个实例进行讲解，对C程序员具有非常高的实用价值。\n本书可以帮助有一定经验的C程序员成为C编程方面的专家，对于具备相当的C语言基础的程序员，本书可以帮助他们站在C的高度了解和学习C++。","price":"45.00元"},{"rating":{"max":10,"numRaters":906,"average":"8.9","min":0},"subtitle":"","author":["本特利"],"pubdate":"2004-4","tags":[{"count":632,"name":"编程","title":"编程"},{"count":491,"name":"算法","title":"算法"},{"count":338,"name":"编程珠玑","title":"编程珠玑"},{"count":241,"name":"计算机","title":"计算机"},{"count":196,"name":"程序设计","title":"程序设计"},{"count":171,"name":"programming","title":"programming"},{"count":102,"name":"编程基本功","title":"编程基本功"},{"count":99,"name":"经典","title":"经典"}],"origin_title":"Programming Pearls Second Edition","image":"http:\/\/img3.douban.com\/mpic\/s2484300.jpg","binding":"平装","translator":["本特利著"],"catalog":"\n      ","pages":"217","images":{"small":"http:\/\/img3.douban.com\/spic\/s2484300.jpg","large":"http:\/\/img3.douban.com\/lpic\/s2484300.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s2484300.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1230206\/","id":"1230206","publisher":"中国电力出版社","isbn10":"7508319141","isbn13":"9787508319148","title":"编程珠玑(第二版)","url":"http:\/\/api.douban.com\/v2\/book\/1230206","alt_title":"Programming Pearls Second Edition","author_intro":"Jon Bentley，世界著名计算机科学家，被誉为影响算法发展的十位大师之一。他先后任职于卡内基—梅隆大学(1976—1982)、贝尔实验室(1982—2001)和Avaya实验室(2001年至今)。在卡内基—梅隆大学担任教授期间，他培养了包括Tcl语言设计者John Ousterhout、Java语言设计者James Gosling、《算法导论》作者之一Charles Leiserson在内的许多计算机科学大家。2004年荣获Dr．Dobb's程序设计卓越奖。","summary":"\n      ","price":"28.0"},{"rating":{"max":10,"numRaters":461,"average":"8.4","min":0},"subtitle":"15位软件先驱访谈录","author":["Peter Seibel"],"pubdate":"2011-1-1","tags":[{"count":612,"name":"编程","title":"编程"},{"count":387,"name":"程序员","title":"程序员"},{"count":353,"name":"计算机","title":"计算机"},{"count":245,"name":"传记","title":"传记"},{"count":160,"name":"思维","title":"思维"},{"count":145,"name":"Programming","title":"Programming"},{"count":136,"name":"软件开发","title":"软件开发"},{"count":104,"name":"软件工程","title":"软件工程"}],"origin_title":"Coders at Work","image":"http:\/\/img3.douban.com\/mpic\/s4549954.jpg","binding":"平装","translator":["图灵俱乐部"],"catalog":"第1篇 Jamie Zawinski\t1\n第2篇 Brad Fitzpatrick\t37\n第3篇 Douglas Crockford\t69\n第4篇 Brendan Eich\t101\n第5篇 Joshua Bloch\t129\n第6篇 Joe Armstrong\t157\n第7篇 Simon Peyton Jones\t185\n第8篇 Peter Norvig\t221\n第9篇 Guy Steele\t253\n第10篇 Dan Ingalls\t289\n第11篇 L Peter Deutsch\t321\n第12篇 Ken Thompson\t347\n第13篇 Fran Allen\t375\n第14篇 Bernie Cosell\t401\n第15篇 Donald Knuth\t435\n参考书目\t471","pages":"473","images":{"small":"http:\/\/img3.douban.com\/spic\/s4549954.jpg","large":"http:\/\/img3.douban.com\/lpic\/s4549954.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s4549954.jpg"},"alt":"http:\/\/book.douban.com\/subject\/5355285\/","id":"5355285","publisher":"人民邮电出版社","isbn10":"711523907X","isbn13":"9787115239075","title":"编程人生","url":"http:\/\/api.douban.com\/v2\/book\/5355285","alt_title":"Coders at Work","author_intro":"Peter Seibel  Common Lisp专家，Jolt生产效率大奖图书Practical Common Lisp的作者。耶鲁大学英语专业毕业，后投身于互联网行业，曾负责Mother Jones Magazine和Organic Online的Perl专栏以及WebLogic的Java专栏，并曾在加州大学伯克利分校成人教育学院教授Java编程。2003年辞职专心研究Lisp编程，之后即有了那部Jolt大奖图书。现在他是Gigamonkeys Consulting公司的首席执行官，和家人幸福地生活在加州伯克利。","summary":"界顶尖的程序员是怎么走上编程道路的？\n他们的编程工作创造和改变了人类历史，在这一过程中都有哪些经验和教训？\n他们对计算机软件行业的过去、现在和未来有什么独到的看法和见解？\n他们对培养、发现、选拔、面试优秀的程序员有什么建议？\n放下手头的工作，听听这些软件先驱们的故事和建议，眼界可以更开阔，思路可以更清晰，方向可以更明确，人生可以更精彩。\n作者Peter Seibel采访了下面这15位世界级编程大师，本书是他在近80个小时的访谈录音基础上整理汇编而成的。\n        Jamie Zawinski：Lisp程序员，XEmacs开发者，Netscape浏览器和Mozilla核心开发者。\n        Brad Fitzpatrick：书中唯一的80后，LiveJournal和memcached开发者。现效力于Google。\n        Douglas Crockford：JavaScript权威，JSON之父。现任Yahoo架构师。\n        Brendan Eich：JavaScript之父。Mozilla公司CTO。\n        Joshua Bloch：如果说Gosling是Java之父，那Bloch就是使Java真正成熟的教父，Java 2到5的核心架构师。现为Google首席Java架构师。\n        Joe Armstrong：Erlang和OTP（开放电信平台）框架之父。\n        Simon Peyton Jones：Haskell先驱。ACM会士。现为微软剑桥研究院研究员。\n        Peter Norvig：Google研发总监。ACM会士。\n        Guy Steele：精通多门语言，Common Lisp和Scheme开发者之一，Java语言规范作者之一，Common Lisp、Fortran、C、ECMAScript和Scheme等语言标准化委员会成员。高性能科学计算的语言Fortress设计者。ACM会士，美国工程院院士。Sun公司院士。\n        Dan Ingalls：与Alan Kay合作开发了Smalltalk，是该语言的真正实现者。现为Sun公司杰出工程师。\n        L. Peter Deutsch：JIT（即时）编译技术发明者之一，PostScript文件浏览器GhostScript的作者。ACM会士。Sun公司院士。\n        Ken Thompson：图灵奖得主。Unix之父。UTF-8 Unicode编码设计者。\n        Fran Allen：图灵奖第一位女得主。编译技术公认权威。IEEE院士，ACM会士，美国工程院院士。IBM院士。\n        Bernie Cosell：Internet奠基人，ARPANET最早的路由计算机IMP设计者之一。\n        Donald Knuth：多卷本经典巨著《计算机程序设计艺术》的作者，排版软件TeX的作者，图灵奖得主。","price":"79.00元"},{"rating":{"max":10,"numRaters":732,"average":"9.5","min":0},"subtitle":"第1卷:套接口API(第3版)","author":["史蒂文斯","芬纳","鲁道夫"],"pubdate":"2006-1","tags":[{"count":800,"name":"UNIX","title":"UNIX"},{"count":692,"name":"网络编程","title":"网络编程"},{"count":266,"name":"网络","title":"网络"},{"count":229,"name":"编程","title":"编程"},{"count":176,"name":"计算机","title":"计算机"},{"count":159,"name":"linux","title":"linux"},{"count":119,"name":"network","title":"network"},{"count":112,"name":"programming","title":"programming"}],"origin_title":"Unix Network Programming","image":"http:\/\/img3.douban.com\/mpic\/s1613283.jpg","binding":"平装","translator":["杨继张"],"catalog":"","pages":"848","images":{"small":"http:\/\/img3.douban.com\/spic\/s1613283.jpg","large":"http:\/\/img3.douban.com\/lpic\/s1613283.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s1613283.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1500149\/","id":"1500149","publisher":"清华大学出版社","isbn10":"7302119740","isbn13":"9787302119746","title":"UNIX网络编程","url":"http:\/\/api.douban.com\/v2\/book\/1500149","alt_title":"Unix Network Programming","author_intro":"","summary":"《UNIX网络编程》(第1卷)(套接口API第3版)第1版和第2版由已故UNIX网络专家W. Richard Stevens博士独自编写。《UNIX网络编程》(第1卷)(套接口API第3版)是3版，由世界著名网络专家Bill Fenner和Andrew M. Rudoff执笔，根据近几年网络技术的发展，对上一版进行全面修订，增添了IPv6的更新过的信息、SCTP协议和密钥管理套接口的内容，删除了X\/Open传输接口的内容。\n《UNIX网络编程》(第1卷)(套接口API第3版)内容详尽且具权威性，几乎每章都提供精选的习题，是计算机和网络专业高年级本科生和研究生的首选教材，《UNIX网络编程》(第1卷)(套接口API第3版)也可作为网络研究和开发人员的自学教材和参考书。","price":"98.0"},{"rating":{"max":10,"numRaters":931,"average":"8.7","min":0},"subtitle":"","author":["Jeremy Keith"],"pubdate":"2006年12月","tags":[{"count":904,"name":"javascript","title":"javascript"},{"count":381,"name":"dom","title":"dom"},{"count":235,"name":"web开发","title":"web开发"},{"count":166,"name":"web","title":"web"},{"count":116,"name":"编程","title":"编程"},{"count":101,"name":"脚本语言","title":"脚本语言"},{"count":84,"name":"计算机","title":"计算机"},{"count":84,"name":"入门","title":"入门"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s1958902.jpg","binding":"简裝本","translator":["杨涛 王建桥 杨晓云"],"catalog":"","pages":"316","images":{"small":"http:\/\/img3.douban.com\/spic\/s1958902.jpg","large":"http:\/\/img3.douban.com\/lpic\/s1958902.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s1958902.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1921890\/","id":"1921890","publisher":"人民邮电出版社","isbn10":"7115139210","isbn13":"9787115139214","title":"JavaScript DOM编程艺术","url":"http:\/\/api.douban.com\/v2\/book\/1921890","alt_title":"","author_intro":"","summary":"本书讲述了JavaScript和DOM的基础知识，但重点放在DOM编程技术背后的思路和原则：预留退路、循序渐进和以用户为中心等，这些概念对于任何前端Web开发工作都非常重要。本书将这些概念贯穿在书中的所有代码示例中，使你看到用来创建图片库页面的脚本、用来创建动画效果的脚本和用来丰富页面元素呈现效果的脚本，最后结合所讲述的内容创建了一个实际的网站。\n本书适合Web设计师和开发人员阅读。","price":"39.00元"},{"rating":{"max":10,"numRaters":998,"average":"7.7","min":0},"subtitle":"","author":["[美]Wesley J. Chun（陳仲才）"],"pubdate":"2008-06","tags":[{"count":915,"name":"Python","title":"Python"},{"count":381,"name":"编程","title":"编程"},{"count":164,"name":"程序语言","title":"程序语言"},{"count":157,"name":"计算机","title":"计算机"},{"count":129,"name":"programming","title":"programming"},{"count":117,"name":"程序设计","title":"程序设计"},{"count":92,"name":"python","title":"python"},{"count":70,"name":"开发","title":"开发"}],"origin_title":"Core Python Programming, 2nd Edition","image":"http:\/\/img5.douban.com\/mpic\/s3140466.jpg","binding":"平装","translator":["CPUG"],"catalog":"第1部分　Python核心\n第1章　欢迎来到Python世界\n1.1　什么是Python\n1.2　起源\n1.3　特点\n1.3.1　高级\n1.3.2　面向对象\n1.3.3　可升级\n1.3.4　可扩展\n1.3.5　可移植性\n1.3.6　易学\n1.3.7　易读\n1.3.8　易维护\n1.3.9　健壮性\n1.3.10　高效的快速原型开发工具\n1.3.11　内存管理器\n1.3.12　解释性和（字节）编译性\n1.4　下载和安装Python\n1.5　运行Python\n1.5.1　命令行上的交互式解释器\n1.5.2　从命令行启动脚本\n1.5.3　集成开发环境\n1.5.4　其他的集成开发环境和执行环境\n1.6　Python文档\n1.7　比较Python（Python与其他语言的比较）\n1.8　其他实现\n1.9　练习\n第2章　快速入门\n2.1　程序输出，print语句及“Hello World!”\n2.2　程序输入和raw_input（）内建函数\n2.3　注释\n2.4　操作符\n2.5　变量和赋值\n2.6　数字\n2.7　字符串\n2.8　列表和元组\n2.9　字典\n2.10　代码块及缩进对齐\n2.11　if语句\n2.12　while循环\n2.13　for循环和range（）内建函数\n2.14　列表解析\n2.15　文件和内建函数open（）、file（）\n2.16　错误和异常\n2.17　函数\n2.17.1　如何定义函数\n2.17.2　如何调用函数\n2.17.3　默认参数\n2.18　类\n2.19　模块\n2.19.1　如何导入模块\n2.19.2　如何访问一个模块函数或访问一个模块变量\n2.20　实用的函数\n2.21　练习\n第3章　Python基础\n3.1　语句和语法\n3.1.1　注释（#）\n3.1.2　继续（\\）\n3.1.3　多个语句构成代码组（:）\n3.1.4　代码组由不同的缩进分隔\n3.1.5　同一行书写多个语句（;）\n3.1.6　模块\n3.2　变量赋值\n3.2.1　赋值操作符\n3.2.2　增量赋值\n3.2.3　多重赋值\n3.2.4　“多元”赋值\n3.3　标识符\n3.3.1　合法的Python标识符\n3.3.2　关键字\n3.3.3　内建\n3.3.4　专用下划线标识符\n3.4　基本风格指南\n3.4.1　模块结构和布局\n3.4.2　在主程序中书写测试代码\n3.5　内存管理\n3.5.1　变量定义\n3.5.2　动态类型\n3.5.3　内存分配\n3.5.4　引用计数\n3.5.5　垃圾收集\n3.6　第一个Python程序\n3.7　相关模块和开发工具\n3.8　练习\n第4章　Python对象\n4.1　Python 对象\n4.2　标准类型\n4.3　其他内建类型\n4.3.1　类型对象和type类型对象\n4.3.2　None--Python的Null对象\n4.4　内部类型\n4.4.1　代码对象\n4.4.2　帧对象\n4.4.3　跟踪记录对象\n4.4.4　切片对象\n4.4.5　省略对象\n4.4.6　XRange 对象\n4.5　标准类型操作符\n4.5.1　对象值的比较\n4.5.2　对象身份比较\n4.5.3　布尔类型\n4.6　标准类型内建函数\n4.6.1　type（）\n4.6.2　cmp（）\n4.6.3　str（）和repr（）（及``操作符）\n4.6.4　type（）和isinstance（）\n4.6.5　Python类型操作符和内建函数总结\n4.7　类型工厂函数\n4.8　标准类型的分类\n4.8.1　存储模型\n4.8.2　更新模型\n4.8.3　访问模型\n4.9　不支持的类型\n4.10　练习\n第5章　数字\n5.1　数字简介\n5.1.1　如何创建数值对象并用其赋值（数字对象）\n5.1.2　如何更新数字对象\n5.1.3　如何删除数字对象\n5.2　整型\n5.2.1　布尔型\n5.2.2　标准整型\n5.2.3　长整型\n5.2.4　整型和长整型的统一\n5.3　双精度浮点型\n5.4　复数\n5.5　操作符\n5.5.1　混合模式操作符\n5.5.2　标准类型操作符\n5.5.3　算术操作符\n5.5.4　*位操作符（只适用于整型）\n5.6　内建函数与工厂函数\n5.6.1　标准类型函数\n5.6.2　数字类型函数\n5.6.3　仅用于整型的函数\n5.7　其他数字类型\n5.7.1　布尔“数”\n5.7.2　十进制浮点型\n5.8　相关模块\n5.9　练习\n第6章　序列：字符串、列表和元组\n6.1　序列\n6.1.1　标准类型操作符\n6.1.2　序列类型操作符\n6.1.3　内建函数（BIF）\n6.2　字符串\n6.3　字符串和操作符\n6.3.1　标准类型操作符\n6.3.2　序列操作符切片（[]和[:]）\n6.4　只适用于字符串的操作符\n6.4.1　格式化操作符（％）\n6.4.2　字符串模板: 更简单的替代品\n6.4.3　原始字符串操作符（r\/R）\n6.4.4　Unicode字符串操作符（u\/U）\n6.5　内建函数\n6.5.1　标准类型函数\n6.5.2　序列类型函数\n6.5.3　字符串类型函数\n6.6　字符串内建函数\n6.7　字符串的独特特性\n6.7.1　特殊字符串和控制字符\n6.7.2　三引号\n6.7.3　字符串不变性\n6.8　Unicode\n6.8.1　术语\n6.8.2　什么是Unicode\n6.8.3　怎样使用Unicode\n6.8.4　Codec是什么\n6.8.5　编码解码\n6.8.6　把Unicode应用到实际应用中\n6.8.7　从现实中得来的教训\n6.8.8　Python的Unicode支持\n6.9　相关模块\n6.10　字符串关键点总结\n6.11　列表\n6.12　操作符\n6.12.1　标准类型操作符\n6.12.2　序列类型操作符\n6.12.3　列表类型操作符和列表解析\n6.13　内建函数\n6.13.1　标准类型函数\n6.13.2　序列类型函数\n6.13.3　列表类型内建函数\n6.14　列表类型的内建函数\n6.15　列表的特殊特性\n6.16　元组\n6.17　元组操作符和内建函数\n6.17.1　标准类型操作符、序列类型操作符和内建函数\n6.17.2　元组类型操作符和内建函数、内建方法\n6.18　元组的特殊特性\n6.18.1　不可变性给元组带来了什么影响\n6.18.2　元组也不是那么“不可变”\n6.18.3　默认集合类型\n6.18.4　单元素元组\n6.18.5　字典的关键字\n6.19　相关模块\n6.20　*拷贝Python对象、浅拷贝和深拷贝\n6.21　序列类型小结\n6.22　练习\n第7章　映像和集合类型\n7.1　映射类型：字典\n7.1.1　如何创建字典和给字典赋值\n7.1.2　如何访问字典中的值\n7.1.3　如何更新字典\n7.1.4　如何删除字典元素和字典\n7.2　映射类型操作符\n7.2.1　标准类型操作符\n7.2.2　映射类型操作符\n7.3　映射类型的内建函数和工厂函数\n7.3.1　标准类型函数[type（）、str（）和cmp（）]\n7.3.2　映射类型相关的函数\n7.4　映射类型内建方法\n7.5　字典的键\n7.5.1　不允许一个键对应多个值\n7.5.2　键必须是可哈希的\n7.6　集合类型\n7.6.1　如何创建集合类型和给集合赋值\n7.6.2　如何访问集合中的值\n7.6.3　如何更新集合\n7.6.4　如何删除集合中的成员和集合\n7.7　集合类型操作符\n7.7.1　标准类型操作符（所有的集合类型）\n7.7.2　集合类型操作符（所有的集合类型）\n7.7.3　集合类型操作符（仅适用于可变集合）\n7.8　内建函数\n7.8.1　标准类型函数\n7.8.2　集合类型工厂函数\n7.9　集合类型内建方法\n7.9.1　方法（所有的集合方法）\n7.9.2　方法（仅适用于可变集合）\n7.9.3　操作符和内建方法比较\n7.10　集合类型总结表\n7.11　相关模块\n7.12　练习\n第8章　条件和循环\n8.1　if语句\n8.1.1　多重条件表达式\n8.1.2　单一语句的代码块\n8.2　else语句\n8.3　elif（即else-if）语句\n8.4　条件表达式（即“三元操作符”）\n8.5　while语句\n8.5.1　一般语法\n8.5.2　计数循环\n8.5.3　无限循环\n8.6　for语句\n8.6.1　一般语法\n8.6.2　用于序列类型\n8.6.3　用于迭代器类型\n8.6.4　range（）内建函数\n8.6.5　xrange（） 内建函数\n8.6.6　与序列相关的内建函数\n8.7　break语句\n8.8　continue语句\n8.9　pass语句\n8.10　再谈else语句\n8.11　迭代器和iter（）函数\n8.11.1　什么是迭代器\n8.11.2　为什么要迭代器\n8.11.3　如何迭代\n8.11.4　使用迭代器\n8.11.5　可变对象和迭代器\n8.11.6　如何创建迭代器\n8.12　列表解析\n8.13　生成器表达式\n8.14　相关模块\n8.15　练习\n第9章　文件和输入输出\n9.1　文件对象\n9.2　文件内建函数（open（）和file（））\n9.2.1　工厂函数file（）\n9.2.2　通用换行符支持（UNS）\n9.3　文件内建方法\n9.3.1　输入\n9.3.2　输出\n9.3.3　文件内移动\n9.3.4　文件迭代\n9.3.5　其他\n9.3.6　文件方法杂项\n9.4　文件内建属性\n9.5　标准文件\n9.6　命令行参数\n9.7　文件系统\n9.8　文件执行\n9.9　永久存储模块\n9.9.1　pickle和marshal模块\n9.9.2　DBM风格的模块\n9.9.3　shelve模块\n9.10　相关模块\n9.11　练习\n第10章　错误和异常\n10.1　什么是异常\n10.1.1　错误\n10.1.2　异常\n10.2　Python 中的异常\n10.3　检测和处理异常\n10.3.1　try-except语句\n10.3.2　包装内建函数\n10.3.3　带有多个except的try语句\n10.3.4　处理多个异常的except语句\n10.3.5　捕获所有异常\n10.3.6　“异常参数”\n10.3.7　在应用使用我们封装的函数\n10.3.8　else子句\n10.3.9　finally子句\n10.3.10　try-finally语句\n10.3.11　try-except-else-finally：厨房一锅端\n10.4　上下文管理\n10.4.1　with语句\n10.4.2　*上下文管理协议\n10.5　*字符串作为异常\n10.6　触发异常\n10.7　断言\n10.8　标准异常\n10.9　*创建异常\n10.10　（现在）为什么用异常\n10.11　到底为什么要异常\n10.12　异常和sys模块\n10.13　相关模块\n10.14　练习\n第11章　函数和函数式编程\n11.1　什么是函数？\n11.1.1　函数vs过程\n11.1.2　返回值与函数类型\n11.2　调用函数\n11.2.1　函数操作符\n11.2.2　关键字参数\n11.2.3　默认参数\n11.2.4　参数组\n11.3　创建函数\n11.3.1　def语句\n11.3.2　声明与定义比较\n11.3.3　前向引用\n11.3.4　函数属性\n11.3.5　内部\/内嵌函数\n11.3.6　*函数（与方法）装饰器\n11.4　传递函数\n11.5　Formal Arguments\n11.5.1　位置参数\n11.5.2　默认参数\n11.6　可变长度的参数\n11.6.1　非关键字可变长参数（元组）\n11.6.2　关键字变量参数（字典）\n11.6.3　调用带有可变长参数对象函数\n11.7　函数式编程\n11.7.1　匿名函数与lambda\n11.7.2　内建函数apply（）、filter（）、map（）、reduce（）\n11.7.3　偏函数应用\n11.8　变量作用域\n11.8.1　全局变量与局部变量\n11.8.2　globa语句\n11.8.3　作用域的数字\n11.8.4　闭包\n11.8.5　作用域和lambda\n11.8.6　变量作用域和名称空间\n11.9　*递归\n11.10　生成器\n11.10.1　简单的生成器特性\n11.10.2　加强的生成器特性\n11.11　练习\n第12章　模块\n12.1　什么是模块\n12.2　模块和文件\n12.2.1　模块名称空间\n12.2.2　搜索路径和路径搜索\n12.3　名称空间\n12.3.1　名称空间与变量作用域比较\n12.3.2　名称查找、确定作用域、覆盖\n12.3.3　无限制的名称空间\n12.4　导入模块\n12.4.1　import语句\n12.4.2　from-import语句\n12.4.3　多行导入\n12.4.4　扩展的import语句（as）\n12.5　模块导入的特性\n12.5.1　载入时执行模块\n12.5.2　导入（import）和加载（load）\n12.5.3　导入到当前名称空间的名称\n12.5.4　被导入到导入者作用域的名字\n12.5.5　关于__future__\n12.5.6　警告框架\n12.5.7　从ZIP文件中导入模块\n12.5.8　“新的”导入钩子\n12.6　模块内建函数\n12.6.1　__import__（）\n12.6.2　globals（）和locals（）\n12.6.3　reload（）\n12.7　包\n12.7.1　目录结构\n12.7.2　使用from-import导入包\n12.8　模块的其他特性\n12.8.1　自动载入的模块\n12.8.2　阻止属性导入\n12.8.3　不区分大小的导入\n12.8.4　源代码编码\n12.8.5　导入循环\n12.8.6　模块执行\n12.9　相关模块\n12.10　练习\n第13章　面向对象编程\n13.1　引言\n13.2　面向对象编程\n13.2.1　面向对象设计与面向对象编程的关系\n13.2.2　现实中的问题\n13.2.3　*常用术语\n13.3　类\n13.3.1　创建类\n13.3.2　声明与定义\n13.4　类属性\n13.4.1　类的数据属性\n13.4.2　Methods\n13.4.3　决定类的属性\n13.4.4　特殊的类属性\n13.5　实例\n13.5.1　初始化：通过调用类对象来创建实例\n13.5.2　__init__（）“构造器”方法\n13.5.3　__new__（）“构造器”方法\n13.5.4　__del__（）“解构器”方法\n13.6　实例属性\n13.6.1　“实例化”实例属性（或创建一个更好的构造器）\n13.6.2　查看实例属性\n13.6.3　特殊的实例属性\n13.6.4　建类型属性\n13.6.5　实例属性vs类属性\n13.7　绑定和方法调用\n13.7.1　调用绑定方法\n13.7.2　调用非绑定方法\n13.8　静态方法和类方法\n13.8.1　staticmethod（）和classmethod（）内建函数\n13.8.2　使用函数修饰符\n13.9　组合\n13.10　子类和派生\n13.11　继承\n13.11.1　__bases__类属性\n13.11.2　通过继承覆盖方法\n13.11.3　从标准类型派生\n13.11.4　多重继承\n13.12　类、实例和其他对象的内建函数\n13.12.1　issubclass（）\n13.12.2　isinstance（）\n13.12.3　hasattr（）、getattr（）、setattr（）、delattr（）\n13.12.4　dir（）\n13.12.5　super（）\n13.12.6　vars（）\n13.13　用特殊方法定制类\n13.13.1　简单定制（RoundFloat2）\n13.13.2　数值定制（Time60）\n13.13.3　迭代器（RandSeq和AnyIter）\n13.13.4　*多类型定制（NumStr）\n13.14　私有化\n13.15　*授权\n13.15.1　包装\n13.15.2　实现授权\n13.16　新式类的高级特性（Python 2.2+）\n13.16.1　新式类的通用特性\n13.16.2　__slots__类属性\n13.16.3　__getattribute__（）特殊方法\n13.16.4　描述符\n13.16.5　元类和__metaclass__\n13.17　相关模块和文档\n13.18　练习\n第14章　执行环境\n14.1　可调用对象\n14.1.1　函数\n14.1.2　方法\n14.1.3　类\n14.1.4　类的实例\n14.2　代码对象\n14.3　可执行的对象声明和内建函数\n14.3.1　callable（）\n14.3.2　compile（）\n14.3.3　eval（）\n14.3.4　exec\n14.3.5　input（）\n14.3.6　使用Python在运行时生成和执行Python代码\n14.4　执行其他（Python）程序\n14.4.1　导入\n14.4.2　execfile（）\n14.4.3　将模块作为脚本执行\n14.5　执行其他（非Python）程序\n14.5.1　os.system（）\n14.5.2　os.popen（）\n14.5.3　os.fork（）、os.exec*（）、os.wait*（）\n14.5.4　os.spawn*（）\n14.5.5　subprocess 模块\n14.5.6　相关函数\n14.6　受限执行\n14.7　结束执行\n14.7.1　sys.exit（） and SystemExit\n14.7.2　sys.exitfunc（）\n14.7.3　os._exit（） 函数\n14.7.4　os.kill（） Function\n14.8　各种操作系统接口\n14.9　相关模块\n14.10　练习\n第2部分　高级主题\n第15章　正则表达式\n15.1　引言\/动机\n15.2　正则表达式使用的特殊符号和字符\n15.2.1　用管道符号（|）匹配多个正则表达式模式\n15.2.2　匹配任意一个单个的字符（.）\n15.2.3　从字符串的开头或结尾或单词边界开始匹配（^\/$ \/\\b \/\\B ）\n15.2.4　创建字符类（[]）\n15.2.5　指定范围（-）和否定（^）\n15.2.6　使用闭包操作符（*，+，?，{}）实现多次出现\/重复匹配\n15.2.7　特殊字符表示、字符集\n15.2.8　用圆括号（（））组建组\n15.3　正则表达式和Python语言\n15.3.1　re模块：核心函数和方法\n15.3.2　使用compile（）编译正则表达式\n15.3.3　匹配对象和group（）、groups（）方法\n15.3.4　用match（）匹配字符串\n15.3.5　search（）在一个字符串中查找一个模式（搜索与匹配的比较）\n15.3.6　匹配多个字符串（|）\n15.3.7　匹配任意单个字符（.）\n15.3.8　创建字符集合（[]）\n15.3.9　重复、特殊字符和子组\n15.3.10　从字符串的开头或结尾匹配及在单词边界上的匹配\n15.3.11　用findall（）找到每个出现的匹配部分\n15.3.12　用sub（）（和subn（））进行搜索和替换\n15.3.13　用split（）分割（分隔模式）\n15.4　正则表达式示例\n15.4.1　匹配一个字符串\n15.4.2　搜索与匹配的比较，“贪婪”匹配\n15.5　练习\n第16章　网络编程\n16.1　引言\n16.1.1　什么是客户端\/服务器架构\n16.1.2　客户端\/服务器网络编程\n16.2　套接字：通信端点\n16.2.1　什么是套接字\n16.2.2　套接字地址：主机与端口\n16.2.3　面向连接与无连接\n16.3　Python中的网络编程\n16.3.1　socket（）模块函数\n16.3.2　套接字对象（内建）方法\n16.3.3　创建一个TCP服务器\n16.3.4　创建TCP客户端\n16.3.5　运行我们的客户端与TCP服务器\n16.3.6　创建一个UDP服务器\n16.3.7　创建一个UDP客户端\n16.3.8　执行UDP服务器和客户端\n16.3.9　Socket模块属性\n16.4　*SocketServer模块\n16.4.1　创建一个SocketServerTCP服务器\n16.4.2　创建SocketServerTCP客户端\n16.4.3　执行TCP服务器和客户端\n16.5　Twisted框架介绍\n16.5.1　创建一个Twisted Reactor TCP服务器\n16.5.2　创建一个Twisted Reactor TCP客户端\n16.5.3　执行TCP服务器和客户端\n16.6　相关模块\n16.7　练习\n第17章　网络客户端编程\n17.1　什么是因特网客户端\n17.2　文件传输\n17.2.1　文件传输网际协议\n17.2.2　文件传输协议（FTP）\n17.2.3　Python和FTP\n17.2.4　ftplib.FTP类方法\n17.2.5　交互式FTP示例\n17.2.6　客户端FTP程序举例\n17.2.7　FTP的其他方面\n17.3　网络新闻\n17.3.1　Usenet与新闻组\n17.3.2　网络新闻传输协议（NNTP）\n17.3.3　Python和NNTP\n17.3.4　nntplib.NNTP类方法\n17.3.5　交互式NNTP举例\n17.3.6　客户端程序NNTP举例\n17.3.7　NNTP的其他方面\n17.4　电子邮件\n17.4.1　电子邮件系统组件和协议\n17.4.2　发送电子邮件\n17.4.3　Python和SMTP\n17.4.4　smtplib.SMTP类方法\n17.4.5　交互式SMTP示例\n17.4.6　SMTP的其他方面\n17.4.7　接收电子邮件\n17.4.8　POP和IMAP\n17.4.9　Python和POP3\n17.4.10　交互式POP3举例\n17.4.11　poplib.POP3类方法\n17.4.12　客户端程序SMTP和POP3举例\n17.5　相关模块\n17.5.1　电子邮件\n17.5.2　其他网络协议\n17.6　练习\n第18章　多线程编程\n18.1　引言\/动机\n18.2　线程和进程\n18.2.1　什么是进程\n18.2.2　什么是线程\n18.3　Python、线程和全局解释器锁\n18.3.1　全局解释器锁（GIL）\n18.3.2　退出线程\n18.3.3　在Python中使用线程\n18.3.4　没有线程支持的情况\n18.3.5　Python的threading模块\n18.4　thread模块\n18.5　threading模块\n18.5.1　Thread类\n18.5.2　斐波那契、阶乘和累加和\n18.5.3　threading模块中的其他函数\n18.5.4　生产者-消费者问题和Queue模块\n18.6　相关模块\n18.7　练习\n第19章　图形用户界面编程\n19.1　简介\n19.1.1　什么是Tcl、Tk和Tkinter\n19.1.2　安装和使用Tkinter　533\n19.1.3　客户端\/服务器架构　534\n19.2　Tkinter与Python编程　534\n19.2.1　Tkinter模块：把Tk引入你的程序\n19.2.2　GUI程序开发简介\n19.2.3　顶层窗口：Tkinter.Tk（）\n19.2.4　Tk组件\n19.3　Tkinter举例\n19.3.1　标签组件\n19.3.2　按钮组件\n19.3.3　标签和按钮组件\n19.3.4　标签、按钮和进度条组件\n19.3.5　偏函数应用举例\n19.3.6　中级Tkinter范例\n19.4　其他GUI简介\n19.4.1　Tk Interface eXtensions （Tix）\n19.4.2　Python MegaWidgets （PMW）\n19.4.3　wxWidgets和wxPython\n19.4.4　GTK+和PyGTK\n19.5　相关模块和其他GUI\n19.6　练习\n第20章　Web编程\n20.1　介绍\n20.1.1　Web应用：客户端\/服务器计算\n20.1.2　因特网\n20.2　使用Python进行Web应用：创建一个简单的Web客户端\n20.2.1　统一资源定位符\n20.2.2　urlparse模块\n20.2.3　urllib模块\n20.2.4　urllib2模块\n20.3　高级Web客户端\n20.4　CGI：帮助Web服务器处理客户端数据\n20.4.1　CGI介绍\n20.4.2　CGI应用程序\n20.4.3　cgi模块\n20.5　建立CGI应用程序\n20.5.1　建立Web服务器\n20.5.2　建立表单页\n20.5.3　生成结果页\n20.5.4　生成表单和结果页面\n20.5.5　全面交互的Web站点\n20.6　在CGI中使用Unicode编码\n20.7　高级CGI\n20.7.1　Mulitipart表单提交和文件的上传\n20.7.2　多值字段\n20.7.3　cookie\n20.7.4　使用高级CGI\n20.8　Web（HTTP）服务器\n20.9　相关模块\n20.10　练习\n第21章　数据库编程\n21.1　介绍\n21.1.1　持久存储\n21.1.2　基本的数据库操作和SQL语言\n21.1.3　数据库和Python\n21.2　Python数据库应用程序程序员接口（DB-API）\n21.2.1　模块属性\n21.2.2　连接对象\n21.2.3　游标对象\n21.2.4　类型对象和构造器\n21.2.5　关系数据库\n21.2.6　数据库和Python：接口程序\n21.2.7　使用数据库接口程序举例\n21.3　对象-关系管理器（ORM）\n21.3.1　考虑对象，而不是SQL\n21.3.2　Python和ORM\n21.3.3　雇员数据库举例\n21.3.4　总结\n21.4　相关模块\n21.5　练习\n第22章　扩展Python　623\n22.1　引言\/动机\n22.1.1　什么是扩展\n22.1.2　为什么要扩展Python\n22.2　创建Python扩展\n22.2.1　创建您的应用程序代码\n22.2.2　用样板来包装你的代码\n22.2.3　编译\n22.2.4　导入和测试\n22.2.5　引用计数\n22.2.6　线程和全局解释器锁（GIL）\n22.3　相关话题\n22.4　练习\n第23章　其他话题\n23.1　Web服务\n23.2　用Win32的COM来操作微软Office\n23.2.1　客户端COM编程\n23.2.2 微软Excel\n23.2.3　微软Word　第1部分　Python核心\n23.2.4　微软PowerPoint\n23.2.5　微软Outlook\n23.2.6　中等规模的例子\n23.3　用Jython写Python和Java的程序\n23.3.1　什么是Jython\n23.3.2　Swing GUI开发（Java或者Python!）\n23.4　练习\n23.2.4　微软PowerPoint\n23.2.5　微软Outlook\n23.2.6　中等规模的例子\n23.3　用Jython写Python和Java的程序\n23.3.1　什么是Jython\n23.3.2　Swing GUI开发（Java或者Python!）\n23.4　练习","pages":"654","images":{"small":"http:\/\/img5.douban.com\/spic\/s3140466.jpg","large":"http:\/\/img5.douban.com\/lpic\/s3140466.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s3140466.jpg"},"alt":"http:\/\/book.douban.com\/subject\/3112503\/","id":"3112503","publisher":"人民邮电出版社","isbn10":"711517850X","isbn13":"9787115178503","title":"Python核心编程（第二版）","url":"http:\/\/api.douban.com\/v2\/book\/3112503","alt_title":"Core Python Programming, 2nd Edition","author_intro":"","summary":"本书是Python开发者的完全指南——针对 Python 2.5全面升级\n·学习专业的Python风格、最佳实践和好的编程习惯；\n·加强对Python对象、内存模型和Python面向对象特性的深入理解；\n·构建更有效的Web、CGI、互联网、网络和其他客户端\/服务器架构应用程序及软件；\n·学习如何使用Python中的Tkinter和其他工具来开发自己的GUI应用程序及软件；\n·通过用C等语言编写扩展来提升Python应用程序的性能，或者通过使用多线程增强I\/0相关的应用程序的能力；\n·学习Python中有关数据库的API，以及如何在Python中使用各种不同的数据库系统，包括MySQL、Postgres和 SQLite。","price":"89.0"},{"rating":{"max":10,"numRaters":502,"average":"8.7","min":0},"subtitle":"","author":["(美)Jon Bentley"],"pubdate":"2008 年10月","tags":[{"count":315,"name":"编程","title":"编程"},{"count":298,"name":"算法","title":"算法"},{"count":152,"name":"编程珠玑","title":"编程珠玑"},{"count":147,"name":"程序设计","title":"程序设计"},{"count":114,"name":"计算机","title":"计算机"},{"count":71,"name":"programming","title":"programming"},{"count":69,"name":"经典","title":"经典"},{"count":66,"name":"算法与数据结构","title":"算法与数据结构"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s3304504.jpg","binding":"平装","translator":["钱丽艳;刘田"],"catalog":"","pages":"186","images":{"small":"http:\/\/img3.douban.com\/spic\/s3304504.jpg","large":"http:\/\/img3.douban.com\/lpic\/s3304504.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s3304504.jpg"},"alt":"http:\/\/book.douban.com\/subject\/3234692\/","id":"3234692","publisher":"人民邮电出版社","isbn10":"711517606X","isbn13":"9787115176066","title":"编程珠玑II","url":"http:\/\/api.douban.com\/v2\/book\/3234692","alt_title":"","author_intro":"Jon Bentley，世界著名计算机科学家，被誉为影响算法发展的十位大师之一。他先后任职于卡内基—梅隆大学(1976—1982)、贝尔实验室(1982—2001)和Avaya实验室(2001年至今)。在卡内基—梅隆大学担任教授期间，他培养了包括Tcl语言设计者John Ousterhout、Java语言设计者James Gosling、《算法导论》作者之一Charles Leiserson在内的许多计算机科学大家。2004年荣获Dr．Dobb's程序设计卓越奖。.","summary":"本书是计算机科学方面的经典名著《编程珠玑》的姊妹篇，讲述了对于程序员有共性的知识。书中涵盖了程序员操纵程序的技术、程序员取舍的技巧、输入和输出设计以及算法示例，这些内容结合成一个有机的整体，如一串串珠玑展示给程序员。本书适合各级程序员阅读参考。...\n【媒体评论】\n“《编程珠玑》第1版是对我职业生涯早期影响最大的书之一，其中的许多真知灼见多年之后仍然使我受益匪浅。Jon在第2版中对素材进行了大量更新，许多新内容让我耳目一新。”.\n——Steve McConnell，软件工程大师，IEEE Software前主编，《代码大全》作者\n“对每一位遇到的程序员，我都会毫不迟疑地建议他阅读并不断重读这部经典之作。”...\n——Slashdot","price":"39.00元"},{"rating":{"max":10,"numRaters":256,"average":"7.5","min":0},"subtitle":"与27位编程语言创始人对话","author":["Federico Biancuzzi","Shane Warden"],"pubdate":"2010-04","tags":[{"count":297,"name":"编程","title":"编程"},{"count":142,"name":"程序设计","title":"程序设计"},{"count":114,"name":"计算机","title":"计算机"},{"count":85,"name":"思维","title":"思维"},{"count":78,"name":"programming","title":"programming"},{"count":58,"name":"软件开发","title":"软件开发"},{"count":56,"name":"编程语言与系统","title":"编程语言与系统"},{"count":48,"name":"计算机科学","title":"计算机科学"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s4305983.jpg","binding":"平裝","translator":["闫怀志"],"catalog":"","pages":"400","images":{"small":"http:\/\/img3.douban.com\/spic\/s4305983.jpg","large":"http:\/\/img3.douban.com\/lpic\/s4305983.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s4305983.jpg"},"alt":"http:\/\/book.douban.com\/subject\/4719230\/","id":"4719230","publisher":"电子工业出版社","isbn10":"7121104989","isbn13":"9787121104985","title":"编程之魂","url":"http:\/\/api.douban.com\/v2\/book\/4719230","alt_title":"","author_intro":"","summary":"本书是27位杰出的设计师与你分享他们的智慧和经验。书中以问答方式告诉为什么要创建某种编程语言、它在技术上如何开发、如何教授和学习，以及它如何顺应时代发展等。你会发现构建成功编程语言所需的思想和步骤，它广受欢迎的原因，以及如何处理程序员常见的问题。因此，如果你想深入学习设计成功编程语言的思想，本书会对你大有帮助。","price":"59.80元"},{"rating":{"max":10,"numRaters":199,"average":"8.4","min":0},"subtitle":"","author":["[美] 桑德Warren Sande","Carter Sande"],"pubdate":"2010-11","tags":[{"count":409,"name":"编程","title":"编程"},{"count":343,"name":"python","title":"python"},{"count":157,"name":"儿童教育","title":"儿童教育"},{"count":146,"name":"计算机","title":"计算机"},{"count":109,"name":"程序设计","title":"程序设计"},{"count":67,"name":"Python","title":"Python"},{"count":62,"name":"Programming","title":"Programming"},{"count":57,"name":"教育","title":"教育"}],"origin_title":"Hello World！Computer Programming for Kids and Other Beginners","image":"http:\/\/img3.douban.com\/mpic\/s4518521.jpg","binding":"平装","translator":["苏金国","姚曜 等"],"catalog":"第1章 出发吧    1\n1.1 安装Python     1\n1.2 从IDLE启动Python   2\n1.3 来点指令吧     3\n1.4 与Python交互   5\n1.5 该编程了     7\n1.6 运行你的第一个程序   8\n1.7 如果出问题     9\n1.8 你的第二个程序   11\n第2章 记住内存和变量  14\n2.1 输入、处理和输出   14\n2.2 名字     16\n2.3 名字里是什么   20\n2.4 数字和字符串   21\n2.5 它们有多“可变”   22\n2.6 全新的我     23\n第3章 基本数学运算  　26\n3.1 四大基本运算  　 26\n3.2 操作符     　28\n3.3 运算顺序     29\n3.4 另外两个操作符   30\n3.5 非常大和非常小   33\n第4章 数据的类型  　38\n4.1 改变类型     38\n4.2 得到更多信息：type() 　41\n4.3 类型转换错误   42\n4.4 使用类型转换   42\n第5章 输入    44\n5.1 raw_input()   44\n5.2 Print命令和逗号   45\n5.3 输入数字     47\n5.4 来自互联网的输入   49\n第6章 GUI——图形用户界面　　52\n6.1 什么是GUI     52\n6.2 第一个GUI     53\n6.3 GUI输入     54\n6.4 选择你的口味   55\n6.5 再看猜数游戏   59\n6.6 其他GUI组件   60\n第7章 判断再判断  62\n7.1 测试，测试     62\n7.2 缩进     64\n7.3 是不是有问题   65\n7.4 其他类型的测试   66\n7.5 如果测试为假会怎么样 67\n7.6 测试多个条件   69\n7.7 使用and     69\n7.8 使用or     70\n7.9 使用not     70\n第8章 转圈圈    74\n8.1 计数循环     75\n8.2 使用计数循环   77\n8.3 一条捷径——range() 　　78\n8.4 风格问题——循环变量名　 80\n8.5 按步长计数     82\n8.6 没有数字的计数   84\n8.7 关于这个问题   84\n8.8  跳出循环——break和continue    85\n第9章 全都为了你——注释　　89\n9.1 增加注释     89\n9.2 单行注释     90\n9.3 行末注释     90\n9.4 多行注释     90\n9.5 注释风格     91\n9.6 注释掉     92\n第10章 游戏时间到了  94\n第11章 嵌套与可变循环  99\n11.1 嵌套循环     99\n11.2 可变循环     101\n11.3 可变嵌套循环   102\n11.4 更多可变嵌套循环   103\n11.5 使用嵌套循环   105\n第12章 收集起来——列表　　112\n12.1 什么是列表   112\n12.2 创建列表     113\n12.3 向列表增加元素   113\n12.4 这个点是什么   114\n12.5 列表可以包含任何内容　 114\n12.6 从列表获取元素  　 115\n12.7 列表“分片”   116\n12.8 修改元素     118\n12.9  向列表增加元素的其他方法     118\n12.10 从列表删除元素   120\n12.11 搜索列表   121\n12.12 循环处理列表   122\n12.13 列表排序   123\n12.14 可改变和不可改变 　126\n12.15 双重列表：数据表　 126\n第13章 函数    131\n13.1 函数——积木   131\n13.2 调用函数     133\n13.3 向函数传递参数   134\n13.4 有多个参数的函数   137\n13.5 返回值的函数   139\n13.6 变量作用域   140\n13.7 强制为全局   143\n13.8 关于变量命名的一点建议 　144\n第14章 对象   　146\n14.1 真实世界中的对象   146\n14.2 Python中的对象  　147\n14.3 对象 = 属性+ 方法   148\n14.4 这个点是什么   148\n14.5 创建对象     149\n14.6 一个示例类——HotDog 154\n14.7 隐藏数据     159\n14.8 多态和继承   159\n14.9 未雨绸缪     161\n第15章 模块    164\n15.1 什么是模块   164\n15.2 为什么使用模块   　164\n15.3 积木桶    　165\n15.4 如何创建模块   165\n15.5 如何使用模块   165\n15.6 命名空间     167\n15.7 标准模块     170\n第16章 图形    174\n16.1 寻求帮助——Pygame　 174\n16.2 Pygame窗口   175\n16.3 在窗口中画图   178\n16.4 单个像素     186\n16.5 图像     190\n16.6 动起来   　192\n16.7 动画     193\n16.8 更流畅的动画   194\n16.9 让球反弹     195\n16.10 让球翻转   198\n第17章 动画精灵和碰撞检测　　201\n17.1 动画精灵     201\n17.2 嘣! 碰撞检测   207\n17.3 统计时间   　211\n第18章 一种新的输入——事件　　216\n18.1 事件     216\n18.2 键盘事件     218\n18.3 鼠标事件     222\n18.4 定时器事件   224\n18.5 另一个游戏PyPong　 226\n第19章 声音   　238\n19.1  从Pygame寻求更多帮助——mixer   238\n19.2 制造声音与播放声音 239\n19.3 播放声音     239\n19.4 控制音量     242\n19.5 重复音乐     244\n19.6 为PyPong增加声音 244\n19.7 更多声音     245\n19.8 为PyPong增加音乐 249\n第20章 更 多 GUI  253\n20.1 使用PythonCard   .253\n20.2 组件     254\n20.3 让GUI做点事情   256\n20.4 事件处理器的返回   258\n20.5 移动按钮     259\n20.6 更多有用的GUI   259\n20.7 TempGUI     259\n20.8 菜单上是什么   264\n第21章 打印格式化与字符串　　271\n21.1 换行     272\n21.2 水平间隔——制表符 　　273\n21.3 在字符串中插入变量 　　275\n21.4 数字格式化   　276\n21.5 更多字符串处理  　280\n第22章 文件输入与输出　　287\n22.1 什么是文件   287\n22.2 文件名   　288\n22.3 文件位置     289\n22.4 打开文件     292\n22.5 读文件   　293\n22.6 文本文件和二进制文件　 295\n22.7 写文件     　296\n22.8 在文件中保存内容：pickle　 300\n22.9  又到了游戏时间——Hangman     301\n第23章 碰运气——随机性　　310\n23.1 什么是随机性   310\n23.2 掷骰子     311\n23.3 创建一副牌  　 316\n23.4 Crazy Eights 　  320\n第24章 计算机仿真　  333\n24.1 真实世界建模   333\n24.2 Lunar Lander   334\n24.3 跟踪时间     339\n24.4 时间对象     340\n24.5 把时间保存到文件   343\n24.6 电子宠物     345\n第25章 接下来呢  354\n25.1 一般编程     354\n25.2 Python     355\n25.3 游戏编程与Pygame　　355\n25.4 其他Python模块   356\n25.5 回顾     358\n附录 变量命名规则 　 359\n自测题答案  　  361","ebook_url":"http:\/\/read.douban.com\/ebook\/1003628\/","pages":"388","images":{"small":"http:\/\/img3.douban.com\/spic\/s4518521.jpg","large":"http:\/\/img3.douban.com\/lpic\/s4518521.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s4518521.jpg"},"alt":"http:\/\/book.douban.com\/subject\/5338024\/","id":"5338024","publisher":"人民邮电出版社","isbn10":"7115239967","isbn13":"9787115239969","title":"与孩子一起学编程","url":"http:\/\/api.douban.com\/v2\/book\/5338024","alt_title":"Hello World！Computer Programming for Kids and Other Beginners","author_intro":"Warren Sande    毕业于加拿大里贾那大学电气工程系。一直在面向计算机初学者教授软件基础课程，编写过大量广受欢迎的技术文档。\nCarter Sande    Warren之子，一个聪明、热情、好奇心强、喜欢思考问题的小男孩，热爱计算机，喜欢弹钢琴和玩超级玛丽。很小的时候就开始跟着父亲玩编程。","summary":"一本老少咸宜的编程入门奇书！一册在手，你完全可以带着自己的孩子，跟随Sande父子组合在轻松的氛围中熟悉那些编程概念，如内存、循环、输入和输出、数据结构和图形用户界面等。这些知识一点儿也不高深，听起来备感亲切，书中言语幽默风趣而不失真义，让学习过程充满乐趣。细心的作者还配上了孩子们都喜欢的可爱漫画和经过运行测试的程序示例，教你用最易编写和最易理解的Python语言，写出你梦想中的游戏程序。\n“Hello, World!我来了！”编程乐趣无穷，起点就在脚下，请引导你的孩子走进这奇妙的世界。无论是中小学生还是其他初学者，都可以跟随本书学习Python编程，并过渡到任何其他语言，重要的是你将学会思考问题和解决问题的方法。","ebook_price":"30.00","price":"65.00元"},{"rating":{"max":10,"numRaters":462,"average":"9.0","min":0},"subtitle":"","author":["宋劲杉"],"pubdate":"2009-12","tags":[{"count":503,"name":"Linux","title":"Linux"},{"count":464,"name":"C","title":"C"},{"count":221,"name":"编程","title":"编程"},{"count":105,"name":"计算机","title":"计算机"},{"count":95,"name":"程序设计","title":"程序设计"},{"count":75,"name":"programming","title":"programming"},{"count":68,"name":"Linux\/Unix","title":"Linux\/Unix"},{"count":46,"name":"嵌入式","title":"嵌入式"}],"origin_title":"","image":"http:\/\/img5.douban.com\/mpic\/s24562068.jpg","binding":"","translator":[],"catalog":"","pages":"461","images":{"small":"http:\/\/img5.douban.com\/spic\/s24562068.jpg","large":"http:\/\/img5.douban.com\/lpic\/s24562068.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s24562068.jpg"},"alt":"http:\/\/book.douban.com\/subject\/4141733\/","id":"4141733","publisher":"电子工业出版社","isbn10":"7121097710","isbn13":"9787121097713","title":"Linux C编程一站式学习","url":"http:\/\/api.douban.com\/v2\/book\/4141733","alt_title":"","author_intro":"","summary":"本书有两条线索，一条线索是以Linux平台为载体全面深入地介绍C语言的语法和程序的工作原理，另一条线索是介绍程序设计的基本思想和开发调试方法。本书分为两部分：第一部分讲解编程语言和程序设计的基本思想方法，让读者从概念上认识C语言；第二部分结合操作系统和体系结构的知识讲解程序的工作原理，让读者从本质上认识C语言。.\n本书适合做零基础的初学者学习C语言的第一本教材，帮助读者打下牢固的基础。有一定的编程经验但知识体系不够完整的读者也可以对照本书查缺补漏，从而更深入地理解程序的工作原理。本书最初是为北京亚嵌教育研究中心的嵌入式Linux系统工程师就业班课程量身定做的教材之一，也适合作为高等院校程序设计基础课程的教材。本书对于C语言的语法介绍得非常全面，对C99标准做了很多解读，因此也可以作为一本精简的C语言语法参考书。...","price":"60.00元"},{"rating":{"max":10,"numRaters":375,"average":"9.2","min":0},"subtitle":"","author":["Jon Bentley"],"pubdate":"2006-11","tags":[{"count":261,"name":"编程","title":"编程"},{"count":230,"name":"算法","title":"算法"},{"count":119,"name":"programming","title":"programming"},{"count":108,"name":"计算机","title":"计算机"},{"count":105,"name":"程序设计","title":"程序设计"},{"count":72,"name":"经典","title":"经典"},{"count":58,"name":"计算机科学","title":"计算机科学"},{"count":40,"name":"英文原版","title":"英文原版"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s2170174.jpg","binding":"平装","translator":[],"catalog":"","pages":"239","images":{"small":"http:\/\/img3.douban.com\/spic\/s2170174.jpg","large":"http:\/\/img3.douban.com\/lpic\/s2170174.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s2170174.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1910326\/","id":"1910326","publisher":"人民邮电出版社","isbn10":"7115151717","isbn13":"9787115151711","title":"编程珠玑","url":"http:\/\/api.douban.com\/v2\/book\/1910326","alt_title":"","author_intro":"","summary":"《编程珠玑》第一版是我早期职业生涯中阅读过的对我影响较大的书籍之一，在书中首次接触到的很多观点都让我长期受益。作者在这一版本中做了重要更新，新增加的很多例子让我耳目一新。——Steve McConnell,《代码大全》作者　　如果让程序员列举出他们喜欢的书籍，Jon Bentley的《编程珠玑》一定可以归于经典之列。如同精美的珍珠出自饱受沙砾折磨的牡蛎，程序员们的精彩设计也来源泉于曾经折磨他们的实际问题。Bentley的“珍珠”基于坚实的工程学基础，为那些麻烦的问题提供了富于智慧性和创造性的解决方案。本书通过一些有趣的具有指导意义的程序，对程序设计技巧和基本设计原理进行了清晰而睿智的描述。因此本书对各个层次的程序员都具有很高的价值。　　本书作者的“编程珠玑”专栏多年来一直是顶级学术杂志Communications of the ACM最风行的特色专栏之一，而本书正是建立在这些专栏的基础之上。","price":"28.0"},{"rating":{"max":10,"numRaters":338,"average":"9.5","min":0},"subtitle":"","author":["[意] Paolo Perrotta"],"pubdate":"2012-1-10","tags":[{"count":602,"name":"Ruby","title":"Ruby"},{"count":311,"name":"元编程","title":"元编程"},{"count":168,"name":"编程","title":"编程"},{"count":109,"name":"动态语言","title":"动态语言"},{"count":81,"name":"Programming","title":"Programming"},{"count":79,"name":"计算机","title":"计算机"},{"count":71,"name":"ruby","title":"ruby"},{"count":63,"name":"程序设计","title":"程序设计"}],"origin_title":"Metaprogramming Ruby","image":"http:\/\/img5.douban.com\/mpic\/s7014167.jpg","binding":"平装","translator":["廖志刚","陈睿杰"],"catalog":"目录\n前言 vii\n致谢 ix\n引言 xi\n“元”这个字眼 xii\n关于本书 xix\n关于你 xxii\n第1部分 Ruby元编程 1\n第1章 星期一：对象模型 3\n1.1 跟Bill在一起的星期一 3\n1.2 打开类 4\n1.3 类的真相 9\n1.4 小测验：缺失的连接线 21\n1.5 调用一个方法时发生了什么 23\n1.6 小测验：混乱的模块 32\n1.7 对象模型小结 35\n第2章 星期二：方法 37\n2.1 一个重复代码的问题 38\n2.2 动态方法 40\n2.3 method_missing()方法 48\n2.4 小测验：狩猎Bug 59\n2.5 关于method_missing()方法的更多内容 61\n第3章 星期三：代码块 69\n3.1 怎样度过驼峰日 70\n3.2 小测验：Ruby的#符号 71\n3.3 闭包 74\n3.4 instance_eval() 83\n3.5 可调用对象 86\n3.6 编写一种领域专属语言 94\n3.7 小测验：更好的领域专属语言 96\n第4章 星期四：类定义 101\n4.1 类定义揭秘 102\n4.2 小测验：Taboo类 109\n4.3 单件方法 110\n4.4 Eigenclass 116\n4.5 小测验：模块的麻烦 129\n4.6 别名 131\n4.7 小测验：打破数学规律 135\n第5章 星期五：编写代码的代码 139\n5.1 带路 139\n5.2 Kernel#eval 142\n5.3 小测验：校验过的属性（第一步） 152\n5.4 小测验：校验过的属性（第二步） 155\n5.5 小测验：校验过的属性（第三步） 157\n5.6 小测验：校验过的属性（第四步） 158\n5.7 钩子方法 159\n5.8 小测验：校验过的属性（第五步） 165\n第6章 尾声 167\n第2部分“Rails中的元编程” 169\n第7章 ActiveRecord的设计 171\n7.1 准备旅程 172\n7.2 ActiveRecord的设计 174\n7.3 经验教训 183\n第8章 深入ActiveRecord 187\n8.1 动态属性 187\n8.2 动态查找器 195\n8.3 经验教训 200\n第9章 安全元编程 205\n9.1 元编程的测试 205\n9.2 化解猴子补丁 213\n9.3 经验教训 218\n第三部分 附录 221\n附录A 常见惯用法 223\nA.1 拟态方法 223\nA.2 空指针保护 226\nA.3 关于方法参数的技巧 227\nA.4 Self Yield 231\nA.5 Symbol#to_proc()方法 232\n附录B 领域专属语言 235\nB.1 关于领域专属语言 235\nB.2 内部和外部领域专属语言 237\nB.3 领域专属语言和元编程 238\n附录C 法术手册 239\nC.1 法术集 239\n附录D 参考书目 251\n索引 253","pages":"288","images":{"small":"http:\/\/img5.douban.com\/spic\/s7014167.jpg","large":"http:\/\/img5.douban.com\/lpic\/s7014167.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s7014167.jpg"},"alt":"http:\/\/book.douban.com\/subject\/7056800\/","id":"7056800","publisher":"华中科技大学出版社","isbn10":"7560974589","isbn13":"9787560974583","title":"Ruby元编程","url":"http:\/\/api.douban.com\/v2\/book\/7056800","alt_title":"Metaprogramming Ruby","author_intro":"Paolo Perrotta有超过10年的软件设计和开发经验，发表过上百篇技术文章。他用过Java、C++、C#编程，最后爱上了Ruby。他是较早接受敏捷方法的实践者，在Yoox（一家大型互联网时尚公司）从事管理敏捷团队的工作。他还在欧洲各国教授编程培训课。目前他和女友（还有一只猫）住在意大利，专心钻研Ruby。","summary":"《Ruby元编程》以案例形式循序渐进讲解Ruby对象模型原理和高级应用技巧，堪称动态语言的设计模式。书中讲述的各种Ruby编程模式，完全可以应用于其他动态语言（甚至静态语言）。本书不仅适合Ruby程序员阅读，也适合对动态编程 语言和面向对象编程感兴趣的读者阅读。所有对程序设计理论感兴趣的人都能从中获益。Ruby之父松本行弘作序推荐。","price":"56.00元"},{"rating":{"max":10,"numRaters":434,"average":"8.8","min":0},"subtitle":"","author":["Jeffrey Richter"],"pubdate":"2000-5-1","tags":[{"count":209,"name":"Windows","title":"Windows"},{"count":166,"name":"Windows编程","title":"Windows编程"},{"count":119,"name":"编程","title":"编程"},{"count":89,"name":"计算机","title":"计算机"},{"count":76,"name":"核心编程","title":"核心编程"},{"count":73,"name":"Win32","title":"Win32"},{"count":51,"name":"programming","title":"programming"},{"count":42,"name":"程序设计","title":"程序设计"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s1874860.jpg","binding":"平装（带盘）","translator":[],"catalog":"第一部分   程序员必读\n第二部分   编程的具体方法\n第三部分   内存管理\n第四部分   动态链接库\n第五部分   结构化异常处理\n第六部分   窗口\n第七部分   附录","pages":"704","images":{"small":"http:\/\/img3.douban.com\/spic\/s1874860.jpg","large":"http:\/\/img3.douban.com\/lpic\/s1874860.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s1874860.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1088045\/","id":"1088045","publisher":"机械工业出版社","isbn10":"7111079450","isbn13":"9787111079453","title":"Windows核心编程","url":"http:\/\/api.douban.com\/v2\/book\/1088045","alt_title":"","author_intro":"","summary":"Windows核心编程，ISBN：9787111079453，作者：（美）Jeffrey Richter（J.理查特）著；王建华[等]译；王建华译","price":"86.00元"},{"rating":{"max":10,"numRaters":511,"average":"8.0","min":0},"subtitle":"程序员职业规划之道","author":["[美] Chad Fowler"],"pubdate":"2010-8","tags":[{"count":292,"name":"程序员","title":"程序员"},{"count":236,"name":"职业生涯","title":"职业生涯"},{"count":222,"name":"职业规划","title":"职业规划"},{"count":120,"name":"编程","title":"编程"},{"count":87,"name":"计算机","title":"计算机"},{"count":63,"name":"程序设计","title":"程序设计"},{"count":59,"name":"Programming","title":"Programming"},{"count":57,"name":"软件开发","title":"软件开发"}],"origin_title":"The Passionate Programmer:Creating A Remarkable Career In Software Development","image":"http:\/\/img5.douban.com\/mpic\/s6378707.jpg","binding":"平装","translator":["于梦瑄"],"catalog":"第1章 选择市场\t1\n1 稳定成熟的技术还是未成熟的新技术?\t5\n2 供应和需求\t8\n3 只会编程是不够的\t12\n4 做团队中最差的\t15\n5 在思维上投资\t18\n6 不要听从父母\t21\n7 做一名通才\t27\n8 成为一名专家\t32\n9 切忌孤注一掷\t35\n10 热爱它，不然就离开它\t37\n第2章 在产品上投资\t45\n11 学习钓鱼\t49\n12 学习行业是如何运转的\t52\n13 寻找良师\t54\n14 做一名良师\t58\n15 练习，练习，再练习\t61\n16 做事的方法\t66\n17 站在巨人的肩膀上\t69\n18 在工作中，将自己自动化\t72\n第3章 执行\t79\n19 就是现在\t82\n20 读心术\t84\n21 每日成绩\t87\n22 别忘了你在为谁工作\t90\n23 安分守己\t93\n24 今天我能把工作做到多好？\t96\n25 你的价值是多少\t99\n26 一桶水中的鹅卵石\t102\n27 爱上维护\t105\n28 8小时激情燃烧\t109\n29 学习如何失败\t112\n30 说“不”\t115\n31 不要恐慌\t118\n32 说出来、行动、展示\t122\n第4章 推销……不仅仅是迎合\t131\n33 不要忽视感觉\t135\n34 探险向导\t138\n35 学会沟通，善于写作\t141\n36 到场\t144\n37 适当的言语\t148\n38 改变世界\t150\n39 让人们听到你的声音\t152\n40 创建自己的商标\t156\n41 发布你编写的程序\t158\n42 变为卓越的能力\t161\n43 建立关系\t164\n第5章 保持技术领先\t171\n44 已经过时的技术\t174\n45 你已经失去工作了\t177\n46 没有终点的道路\t179\n47 给自己做一份蓝图\t181\n48 要注意观察市场变化\t183\n49 镜子里的胖子\t185\n50 南印度捉猴陷阱\t188\n51 避免瀑布型职业计划\t192\n52 每天都有进步\t195\n53 独立\t199\n祝你开心\t203\n参考文献\t204","ebook_url":"http:\/\/read.douban.com\/ebook\/381109\/","pages":"202","images":{"small":"http:\/\/img5.douban.com\/spic\/s6378707.jpg","large":"http:\/\/img5.douban.com\/lpic\/s6378707.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s6378707.jpg"},"alt":"http:\/\/book.douban.com\/subject\/4923179\/","id":"4923179","publisher":"人民邮电出版社","isbn10":"7115233527","isbn13":"9787115233523","title":"我编程，我快乐","url":"http:\/\/api.douban.com\/v2\/book\/4923179","alt_title":"The Passionate Programmer:Creating A Remarkable Career In Software Development","author_intro":"Chad Fowler 国际知名的软件开发人员、培训师、经理、演说家和音乐人。近十年来，他在几家国际知名的公司工作过，与很多受人钦佩的软件开发人员共事。他热爱编程，目前是InfoEther公司的首席技术执行官，主要负责为客户解决Ruby语言上的难题。他还写过软件开发方面的书籍。","summary":"要在当今的IT职场取得成功，必须像经营企业那样对待你的事业。在本书中，你将学到如何规划自己的职业生涯，让它向着你选择的目标前进，使人生更快乐、更美好。\n作者运用其独特的思维方式，启发程序员不能只注重技能上的提高，还要关注自己的职业发展。书中涉及新旧技术的取舍、技术与业务的关系、技术是要专精还是要广博等，相信这也是长久以来困扰你的问题。带着这些问题去阅读此书，定会受益良多。\n此外，本书中的每一章都包含一篇或几篇各领域成功人士的文章，让你直接了解他们如何规划自己的职业生涯！","ebook_price":"18.00","price":"39.00元"},{"rating":{"max":10,"numRaters":594,"average":"8.7","min":0},"subtitle":"","author":["[美] Bruce Eckel"],"pubdate":"2002-9","tags":[{"count":407,"name":"Java","title":"Java"},{"count":122,"name":"编程思想","title":"编程思想"},{"count":95,"name":"编程","title":"编程"},{"count":81,"name":"计算机","title":"计算机"},{"count":72,"name":"软件开发","title":"软件开发"},{"count":67,"name":"程序设计","title":"程序设计"},{"count":46,"name":"经典","title":"经典"},{"count":34,"name":"IT","title":"IT"}],"origin_title":"","image":"http:\/\/img5.douban.com\/mpic\/s1085058.jpg","binding":"平装16开","translator":["侯捷"],"catalog":"出版者的话\n专家指导委员会\n读者回应\n关于《Thinking in C++》\n题献\n译序\nJava环境设定\n序言\n简介\n第一章 对象导论\n第二章 万事万物皆对象\n第三章 控制程序流程\n第四章 初始化与清理\n第五章 隐藏实现细目\n第六章 重复运用Classes\n第七章 多态\n第八章 接口与内隐类\n……\n附录A 对象的传递和返回\n……\n索引","pages":"809","images":{"small":"http:\/\/img5.douban.com\/spic\/s1085058.jpg","large":"http:\/\/img5.douban.com\/lpic\/s1085058.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s1085058.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1101158\/","id":"1101158","publisher":"机械工业出版社","isbn10":"7111104412","isbn13":"9787111104414","title":"Java编程思想","url":"http:\/\/api.douban.com\/v2\/book\/1101158","alt_title":"","author_intro":"Bruce Eckel是Thinking in C++和《C++编程思想》的作者。他有20年专业编程经验，并自1986年起教育人们如何撰写面向对象程序，足迹遍及全球，成为一位知名的C++教师和顾问，如今兼涉Java。Eckel是C++标准委员会拥有表决权的成员之一，曾经写过另五本面向对象编程书籍，发表过150篇以上的文章，是多本计算机杂志的专栏作家。","summary":"作者根据多年教学实践中发现的问题，通过简练的示例和叙述，阐明了在学习Java中特别容易混淆的诸多概念。与前一版相比，此第2版不但新增了Java2的语言特性，还根据语言的演变作出了彻底的更新，其中最主要的改变是第9章的群集。","price":"99.00元"},{"rating":{"max":10,"numRaters":452,"average":"9.1","min":0},"subtitle":"","author":["[美] Peter Vander Linde"],"pubdate":"2002-12","tags":[{"count":198,"name":"C语言","title":"C语言"},{"count":175,"name":"c","title":"c"},{"count":146,"name":"编程","title":"编程"},{"count":78,"name":"programming","title":"programming"},{"count":72,"name":"计算机","title":"计算机"},{"count":58,"name":"经典","title":"经典"},{"count":48,"name":"C专家编程","title":"C专家编程"},{"count":41,"name":"C\/C++","title":"C\/C++"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s1457934.jpg","binding":"平装","translator":["徐波"],"catalog":"\n      ","pages":"291","images":{"small":"http:\/\/img3.douban.com\/spic\/s1457934.jpg","large":"http:\/\/img3.douban.com\/lpic\/s1457934.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s1457934.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1232029\/","id":"1232029","publisher":"人民邮电出版社","isbn10":"7115106274","isbn13":"9787115106278","title":"C专家编程","url":"http:\/\/api.douban.com\/v2\/book\/1232029","alt_title":"Expert C Programming","author_intro":"","summary":"《C专家编程》展示了最优秀的C程序员所使用的编码技巧，并专门开辟了一章对C++的基础知识进行了介绍。\n书中对C的历史、语言特性、声明、数组、指针、链接、运行时、内存，以及如何进一步学习C++等问题作了细致的讲解和深入的分析。全书撷取几十几个实例进行讲解，对C程序员具有非常高的实用价值。\n这本《C专家编程》可以帮助有一定经验的C程序员成为C编程方面的专家，对于具备相当的C语言基础的程序员，本书可以帮助他们站在C的高度了解和学习C++。","price":"40.00元"},{"rating":{"max":10,"numRaters":108,"average":"8.3","min":0},"subtitle":"","author":["Terence Parr"],"pubdate":"2012-3-20","tags":[{"count":320,"name":"编译原理","title":"编译原理"},{"count":207,"name":"编程语言","title":"编程语言"},{"count":129,"name":"程序设计","title":"程序设计"},{"count":95,"name":"编程","title":"编程"},{"count":91,"name":"计算机","title":"计算机"},{"count":69,"name":"计算机科学","title":"计算机科学"},{"count":56,"name":"设计模式","title":"设计模式"},{"count":39,"name":"屠“龙书”","title":"屠“龙书”"}],"origin_title":"Language Implementation Patterns: Create Your Own Domain-Specific and General Programming Languages","image":"http:\/\/img5.douban.com\/mpic\/s7661036.jpg","binding":"平装","translator":["李袁奎","尧飘海"],"catalog":"第1部分  读取输入\n第1章  初探语言应用 3\n1.1  大局观 3\n1.2  模式概览 5\n1.3  深入浅出语言应用 9\n1.4  为语言应用选择合适的模式 17\n第2章  基本解析模式 21\n2.1  识别式子的结构 22\n2.2  构建递归下降语法解析器 24\n2.3  使用文法DSL来构建语法解析器 26\n2.4  词法单元和句子 27\n第3章  高阶解析模式 49\n3.1  利用任意多的向前看符号进行解析 50\n3.2  记忆式解析 52\n3.3  采用语义信息指导解析过程 52\n第2部分  分析输入\n第4章  从语法树构建中间表示 73\n4.1  为什么要构建树 75\n4.2  构建抽象语法树 77\n4.3  简要介绍ANTLR 84\n4.4  使用ANTLR文法构建AST 86\n第5章  遍历并改写树形结构 101\n5.1  遍历树以及访问顺序 102\n5.2  封装访问节点的代码 105\n5.3  根据文法自动生成访问者 107\n5.4  将遍历与匹配解耦 110\n第6章  记录并识别程序中的符号 131\n6.1  收集程序实体的信息 132\n6.2  根据作用域划分符号 134\n6.3  解析符号 139\n第7章  管理数据聚集的符号表 155\n7.1  为结构体构建作用域树 156\n7.2  为类构建作用域树 158\n第8章  静态类型检查 181\n第3部分  解释执行\n第9章  构建高级解释器 219\n9.1  高级解释器存储系统的设计 220\n9.2  高级解释器中的符号记录 222\n9.3  处理指令 224\n第10章  构建字节码解释器 239\n10.1  设计字节码解释器 241\n10.2  定义汇编语言语法 243\n10.3  字节码机器的架构 245\n10.4  如何深入 250\n第4部分  生成输出\n第11章  语言的翻译 278\n11.1  语法制导的翻译 280\n11.2  基于规则的翻译 281\n11.3  模型驱动的翻译 283\n11.4  创建嵌套的输出模型 291\n第12章  使用模板生成DSL 312\n12.1  熟悉StringTemplate 313\n12.2  StringTemplate的性质 316\n12.2  从一个简单的输入模型生成模板 317\n12.4  在输入模型不同的情况下复用模板 320\n12.5  使用树文法来创建模板 323\n12.6  对数据列表使用模板 330\n12.7  编写可改变输出结果的翻译器 336\n第13章  知识汇总 348\n13.1  在蛋白质结构中查找模式 348\n13.2  使用脚本构建三维场景 349\n13.3  处理XML 350\n13.4  读取通用的配置文件 352\n13.5  对代码进行微调 353\n13.6  为Java添加新的类型 354\n13.7  美化源代码 355\n13.8  编译为机器码 356\n参考文献 359\n索引 361","pages":"388","images":{"small":"http:\/\/img5.douban.com\/spic\/s7661036.jpg","large":"http:\/\/img5.douban.com\/lpic\/s7661036.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s7661036.jpg"},"alt":"http:\/\/book.douban.com\/subject\/10482195\/","id":"10482195","publisher":"华中科技大学出版社","isbn10":"7560977006","isbn13":"9787560977003","title":"编程语言实现模式","url":"http:\/\/api.douban.com\/v2\/book\/10482195","alt_title":"Language Implementation Patterns: Create Your Own Domain-Specific and General Programming Languages","author_intro":"Terence Parr是美国旧金山大学的计算机教授、研究生导师，他一直致力于从事ANTLR项目（antlr.org）和模板引擎（stringtemplate.org）的设计和开发工作。Terence曾担任IBM、洛克希德马丁、NeXT、雷诺汽车等公司的技术顾问，另著有《ANTLR权威指南》。","summary":"《编程语言实现模式》旨在传授开发语言应用（工具）的经验和理念，帮助读者构建自己的语言应用。这里的语言应用并非特指用编译器或解释器实现编程语言，而是泛指任何处理、分析、翻译输入文件的程序，比如配置文件读取器、数据读取器、模型驱动的代码生成器、源码到源码的翻译器、源码分析工具、解释器，以及诸如此类的工具。为此，作者举例讲解已有语言应用的工作机制，拆解、归纳出31种易于理解且常用的设计模式（每种都包括通用数据结构、算法、策略）。虽然示例是用Java编写的，但相信读者可以触类旁通，利用这些设计模式构建针对其他编程语言（既包括特定领域语言，也包括通用编程语言）的应用。","price":"72.00元"},{"rating":{"max":10,"numRaters":623,"average":"8.3","min":0},"subtitle":"标准C++导引","author":["[美] Bruce Eckel"],"pubdate":"2002-9","tags":[{"count":367,"name":"C++","title":"C++"},{"count":126,"name":"编程","title":"编程"},{"count":118,"name":"计算机","title":"计算机"},{"count":79,"name":"编程思想","title":"编程思想"},{"count":78,"name":"Programming","title":"Programming"},{"count":56,"name":"程序设计","title":"程序设计"},{"count":51,"name":"C\/C++","title":"C\/C++"},{"count":24,"name":"软件开发","title":"软件开发"}],"origin_title":"","image":"http:\/\/img5.douban.com\/mpic\/s1085408.jpg","binding":"平装","translator":["刘宗田","袁兆山","潘秋菱"],"catalog":"第一章  对象导言\n第二章  对象的创建于使用\n第三章  C++中的C\n第四章  数据抽象\n第五章  隐藏实现\n第六章  初始化与清除\n第七章  函数重载于默认参数\n第八章  常量\n第九章  内联函数\n第十章  名字控制\n……","pages":"479","images":{"small":"http:\/\/img5.douban.com\/spic\/s1085408.jpg","large":"http:\/\/img5.douban.com\/lpic\/s1085408.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s1085408.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1101524\/","id":"1101524","publisher":"机械工业出版社","isbn10":"7111108078","isbn13":"9787111108078","title":"C++编程思想（第1卷）","url":"http:\/\/api.douban.com\/v2\/book\/1101524","alt_title":"Thinking in C++ Second Edition Volume One:Introduction to Standard C++ ","author_intro":"Bruce Eckel是《Java编程思想》的作者，他有20年专业编程经验，并自1986年起教育人们如何撰写面向对象程序，足迹遍及全球，成为一位知名的C++教师和顾问，如今兼涉Java。Eckel是C++标准委员会拥有表决权的成员之一，曾经写过另五本面向对象编程书籍，发表过150篇以上的文章，是多本计算机杂志的专栏作家。Eckel开创Software Development Conference的C++、Java、Python等多项研讨活动。拥有应用物理学学士和计算机工程学硕士学位。","summary":"《C++编程思考》第2版与第1版相比，在章节安排上有以下改变。增加了两章：“对象的创建与使用”和“C++中的C”，前者与“对象导言”实际上是第1版“对象的演化”一章的彻底重写，增加了近几年面向对象方法和编程方法的最瓣研究与实践的有效成果，后者的添加使不熟悉C的读者可以直接使用这本书。删去了四章：“输入输出流介绍”、“多重继承”、“异常处理”和“运行时类型识别”，删去的内容属于C++中较复杂的主题，作者将它们连同C++标准完成后又增加的一些内容放到第2卷中，使得第1卷的内容更加集中，供不同程度的读者选择阅读。需要强调的是，第2版的改变不仅体现在这些章节的调整上，更多的改变体现在每一章的字里行间中，包括例子的调整和练习的补充。与众不同的精心选材和认真推敲的叙述使得第2版更趋成熟。\n这本书是C++领域的一本权威著作，书中的内容、讲授方法、选用例子和跟随练习既适合课堂教学，又适合读者自学。","price":"59.00元"},{"rating":{"max":10,"numRaters":152,"average":"8.8","min":0},"subtitle":"使用muduo C++网络库","author":["陈硕"],"pubdate":"2013-1-15","tags":[{"count":329,"name":"网络编程","title":"网络编程"},{"count":314,"name":"C++","title":"C++"},{"count":297,"name":"Linux","title":"Linux"},{"count":249,"name":"多线程","title":"多线程"},{"count":69,"name":"计算机","title":"计算机"},{"count":62,"name":"编程","title":"编程"},{"count":41,"name":"Networks","title":"Networks"},{"count":39,"name":"Programming","title":"Programming"}],"origin_title":"","image":"http:\/\/img5.douban.com\/mpic\/s24522799.jpg","binding":"平装","translator":[],"catalog":"第1 部分C++ 多线程系统编程1\n第1章 线程安全的对象生命期管理3\n1.1 当析构函数遇到多线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n1.1.1 线程安全的定义. . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n1.1.2 MutexLock 与MutexLockGuard . . . . . . . . . . . . . . . . . . . . 4\n1.1.3 一个线程安全的Counter 示例. . . . . . . . . . . . . . . . . . . . 4\n1.2 对象的创建很简单. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n1.3 销毁太难. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n1.3.1 mutex 不是办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n1.3.2 作为数据成员的mutex 不能保护析构. . . . . . . . . . . . . . . 8\n1.4 线程安全的Observer 有多难. . . . . . . . . . . . . . . . . . . . . . . . . 8\n1.5 原始指针有何不妥. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n1.6 神器shared_ptr\/weak_ptr . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n1.7 插曲：系统地避免各种指针错误. . . . . . . . . . . . . . . . . . . . . . . 14\n1.8 应用到Observer 上. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\n1.9 再论shared_ptr 的线程安全. . . . . . . . . . . . . . . . . . . . . . . . . 17\n1.10 shared_ptr 技术与陷阱. . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n1.11 对象池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n1.11.1 enable_shared_from_this . . . . . . . . . . . . . . . . . . . . . . 23\n1.11.2 弱回调. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n1.12 替代方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n1.13 心得与小结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n1.14 Observer 之谬. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n第2章 线程同步精要31\n2.1 互斥器（mutex） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32\n2.1.1 只使用非递归的mutex . . . . . . . . . . . . . . . . . . . . . . . . 33\n2.1.2 死锁. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\n2.2 条件变量（condition variable） . . . . . . . . . . . . . . . . . . . . . . . 40\n2.3 不要用读写锁和信号量. . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\n2.4 封装MutexLock、MutexLockGuard、Condition . . . . . . . . . . . . . . 44\n2.5 线程安全的Singleton 实现. . . . . . . . . . . . . . . . . . . . . . . . . . 48\n2.6 sleep(3) 不是同步原语. . . . . . . . . . . . . . . . . . . . . . . . . . . . 50\n2.7 归纳与总结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\n2.8 借shared_ptr 实现copy-on-write . . . . . . . . . . . . . . . . . . . . . . 52\n第3章 多线程服务器的适用场合与常用编程模型59\n3.1 进程与线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59\n3.2 单线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 61\n3.3 多线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 62\n3.3.1 one loop per thread . . . . . . . . . . . . . . . . . . . . . . . . . . 62\n3.3.2 线程池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63\n3.3.3 推荐模式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64\n3.4 进程间通信只用TCP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65\n3.5 多线程服务器的适用场合. . . . . . . . . . . . . . . . . . . . . . . . . . . 67\n3.5.1 必须用单线程的场合. . . . . . . . . . . . . . . . . . . . . . . . . 69\n3.5.2 单线程程序的优缺点. . . . . . . . . . . . . . . . . . . . . . . . . 70\n3.5.3 适用多线程程序的场景. . . . . . . . . . . . . . . . . . . . . . . . 71\n3.6 “多线程服务器的适用场合”例释与答疑. . . . . . . . . . . . . . . . . . 74\n第4章 C++ 多线程系统编程精要83\n4.1 基本线程原语的选用. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84\n4.2 C\/C++ 系统库的线程安全性. . . . . . . . . . . . . . . . . . . . . . . . . 85\n4.3 Linux 上的线程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89\n4.4 线程的创建与销毁的守则. . . . . . . . . . . . . . . . . . . . . . . . . . . 91\n4.4.1 pthread_cancel 与C++ . . . . . . . . . . . . . . . . . . . . . . . 94\n4.4.2 exit(3) 在C++ 中不是线程安全的. . . . . . . . . . . . . . . . . 94\n4.5 善用__thread 关键字. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96\n4.6 多线程与IO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98\n4.7 用RAII 包装文件描述符. . . . . . . . . . . . . . . . . . . . . . . . . . . 99\n4.8 RAII 与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101\n4.9 多线程与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102\n4.10 多线程与signal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103\n4.11 Linux 新增系统调用的启示. . . . . . . . . . . . . . . . . . . . . . . . . . 105\n第5章 高效的多线程日志107\n5.1 功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109\n5.2 性能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112\n5.3 多线程异步日志. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114\n5.4 其他方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120\n第2部分 muduo 网络库123\n第6章 muduo 网络库简介125\n6.1 由来. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125\n6.2 安装. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127\n6.3 目录结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129\n6.3.1 代码结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131\n6.3.2 例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134\n6.3.3 线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135\n6.4 使用教程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136\n6.4.1 TCP 网络编程本质论. . . . . . . . . . . . . . . . . . . . . . . . . 136\n6.4.2 echo 服务的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . 138\n6.4.3 七步实现finger 服务. . . . . . . . . . . . . . . . . . . . . . . . . 140\n6.5 性能评测. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144\n6.5.1 muduo 与Boost.Asio、libevent2 的吞吐量对比. . . . . . . . . . 145\n6.5.2 击鼓传花：对比muduo 与libevent2 的事件处理效率. . . . . . 148\n6.5.3 muduo 与Nginx 的吞吐量对比. . . . . . . . . . . . . . . . . . . 153\n6.5.4 muduo 与ZeroMQ 的延迟对比. . . . . . . . . . . . . . . . . . . 156\n6.6 详解muduo 多线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n6.6.1 数独求解服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n6.6.2 常见的并发网络服务程序设计方案. . . . . . . . . . . . . . . . . 160\n第7章 muduo 编程示例177\n7.1 五个简单TCP 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178\n7.2 文件传输. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185\n7.3 Boost.Asio 的聊天服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . 194\n7.3.1 TCP 分包. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194\n7.3.2 消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195\n7.3.3 编解码器LengthHeaderCodec . . . . . . . . . . . . . . . . . . . . 197\n7.3.4 服务端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198\n7.3.5 客户端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200\n7.4 muduo Buffer 类的设计与使用. . . . . . . . . . . . . . . . . . . . . . . 204\n7.4.1 muduo 的IO 模型. . . . . . . . . . . . . . . . . . . . . . . . . . 204\n7.4.2 为什么non-blocking 网络编程中应用层buffer 是必需的. . . . 205\n7.4.3 Buffer 的功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . 207\n7.4.4 Buffer 的数据结构. . . . . . . . . . . . . . . . . . . . . . . . . . 209\n7.4.5 Buffer 的操作. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211\n7.4.6 其他设计方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217\n7.4.7 性能是不是问题. . . . . . . . . . . . . . . . . . . . . . . . . . . . 218\n7.5 一种自动反射消息类型的Google Protobuf 网络传输方案. . . . . . . . 220\n7.5.1 网络编程中使用Protobuf 的两个先决条件. . . . . . . . . . . . . 220\n7.5.2 根据type name 反射自动创建Message 对象. . . . . . . . . . . . 221\n7.5.3 Protobuf 传输格式. . . . . . . . . . . . . . . . . . . . . . . . . . 226\n7.6 在muduo 中实现Protobuf 编解码器与消息分发器. . . . . . . . . . . . 228\n7.6.1 什么是编解码器（codec） . . . . . . . . . . . . . . . . . . . . . . 229\n7.6.2 实现ProtobufCodec . . . . . . . . . . . . . . . . . . . . . . . . . 232\n7.6.3 消息分发器（dispatcher）有什么用. . . . . . . . . . . . . . . . 232\n7.6.4 ProtobufCodec 与ProtobufDispatcher 的综合运用. . . . . . . 233\n7.6.5 ProtobufDispatcher 的两种实现. . . . . . . . . . . . . . . . . . 234\n7.6.6 ProtobufCodec 和ProtobufDispatcher 有何意义. . . . . . . . . 236\n7.7 限制服务器的最大并发连接数. . . . . . . . . . . . . . . . . . . . . . . . 237\n7.7.1 为什么要限制并发连接数. . . . . . . . . . . . . . . . . . . . . . 237\n7.7.2 在muduo 中限制并发连接数. . . . . . . . . . . . . . . . . . . . 238\n7.8 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240\n7.8.1 程序中的时间. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240\n7.8.2 Linux 时间函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . 241\n7.8.3 muduo 的定时器接口. . . . . . . . . . . . . . . . . . . . . . . . . 242\n7.8.4 Boost.Asio Timer 示例. . . . . . . . . . . . . . . . . . . . . . . . 243\n7.8.5 Java Netty 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . 245\n7.9 测量两台机器的网络延迟和时间差. . . . . . . . . . . . . . . . . . . . . 248\n7.10 用timing wheel 踢掉空闲连接. . . . . . . . . . . . . . . . . . . . . . . . 250\n7.10.1 timing wheel 原理. . . . . . . . . . . . . . . . . . . . . . . . . . 251\n7.10.2 代码实现与改进. . . . . . . . . . . . . . . . . . . . . . . . . . . . 254\n7.11 简单的消息广播服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257\n7.12 “串并转换”连接服务器及其自动化测试. . . . . . . . . . . . . . . . . . 260\n7.13 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264\n7.13.1 TCP 中继器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264\n7.13.2 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . 267\n7.13.3 N : 1 与1 : N 连接转发. . . . . . . . . . . . . . . . . . . . . . . . 267\n7.14 短址服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267\n7.15 与其他库集成. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268\n7.15.1 UDNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270\n7.15.2 c-ares DNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272\n7.15.3 curl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273\n7.15.4 更多. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275\n第8章 muduo 网络库设计与实现277\n8.0 什么都不做的EventLoop . . . . . . . . . . . . . . . . . . . . . . . . . . . 277\n8.1 Reactor 的关键结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280\n8.1.1 Channel class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280\n8.1.2 Poller class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283\n8.1.3 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 287\n8.2 TimerQueue 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290\n8.2.1 TimerQueue class . . . . . . . . . . . . . . . . . . . . . . . . . . . 290\n8.2.2 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 292\n8.3 EventLoop::runInLoop() 函数. . . . . . . . . . . . . . . . . . . . . . . . 293\n8.3.1 提高TimerQueue 的线程安全性. . . . . . . . . . . . . . . . . . . 296\n8.3.2 EventLoopThread class . . . . . . . . . . . . . . . . . . . . . . . . 297\n8.4 实现TCP 网络库. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299\n8.5 TcpServer 接受新连接. . . . . . . . . . . . . . . . . . . . . . . . . . . . 303\n8.5.1 TcpServer class . . . . . . . . . . . . . . . . . . . . . . . . . . . . 304\n8.5.2 TcpConnection class . . . . . . . . . . . . . . . . . . . . . . . . . 305\n8.6 TcpConnection 断开连接. . . . . . . . . . . . . . . . . . . . . . . . . . . 308\n8.7 Buffer 读取数据. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313\n8.7.1 TcpConnection 使用Buffer 作为输入缓冲. . . . . . . . . . . . . 314\n8.7.2 Buffer::readFd() . . . . . . . . . . . . . . . . . . . . . . . . . . 315\n8.8 TcpConnection 发送数据. . . . . . . . . . . . . . . . . . . . . . . . . . . 316\n8.9 完善TcpConnection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 320\n8.9.1 SIGPIPE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321\n8.9.2 TCP No Delay 和TCP keepalive . . . . . . . . . . . . . . . . . . 321\n8.9.3 WriteCompleteCallback 和HighWaterMarkCallback . . . . . . . 322\n8.10 多线程TcpServer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 324\n8.11 Connector . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327\n8.12 TcpClient . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 332\n8.13 epoll . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333\n8.14 测试程序一览. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 336\n第3部分 工程实践经验谈337\n第9章 分布式系统工程实践339\n9.1 我们在技术浪潮中的位置. . . . . . . . . . . . . . . . . . . . . . . . . . . 341\n9.1.1 分布式系统的本质困难. . . . . . . . . . . . . . . . . . . . . . . . 343\n9.1.2 分布式系统是个险恶的问题. . . . . . . . . . . . . . . . . . . . . 344\n9.2 分布式系统的可靠性浅说. . . . . . . . . . . . . . . . . . . . . . . . . . . 349\n9.2.1 分布式系统的软件不要求7  24 可靠. . . . . . . . . . . . . . . . 352\n9.2.2 “能随时重启进程”作为程序设计目标. . . . . . . . . . . . . . . 354\n9.3 分布式系统中心跳协议的设计. . . . . . . . . . . . . . . . . . . . . . . . 356\n9.4 分布式系统中的进程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . 360\n9.4.1 错误做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361\n9.4.2 正确做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 362\n9.4.3 TCP 协议的启示. . . . . . . . . . . . . . . . . . . . . . . . . . . . 363\n9.5 构建易于维护的分布式程序. . . . . . . . . . . . . . . . . . . . . . . . . 364\n9.6 为系统演化做准备. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367\n9.6.1 可扩展的消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . 368\n9.6.2 反面教材：ICE 的消息打包格式. . . . . . . . . . . . . . . . . . . 369\n9.7 分布式程序的自动化回归测试. . . . . . . . . . . . . . . . . . . . . . . . 370\n9.7.1 单元测试的能与不能. . . . . . . . . . . . . . . . . . . . . . . . . 370\n9.7.2 分布式系统测试的要点. . . . . . . . . . . . . . . . . . . . . . . . 373\n9.7.3 分布式系统的抽象观点. . . . . . . . . . . . . . . . . . . . . . . . 374\n9.7.4 一种自动化的回归测试方案. . . . . . . . . . . . . . . . . . . . . 375\n9.7.5 其他用处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 379\n9.8 分布式系统部署、监控与进程管理的几重境界. . . . . . . . . . . . . . . 380\n9.8.1 境界1：全手工操作. . . . . . . . . . . . . . . . . . . . . . . . . 382\n9.8.2 境界2：使用零散的自动化脚本和第三方组件. . . . . . . . . . . 383\n9.8.3 境界3：自制机群管理系统，集中化配置. . . . . . . . . . . . . 386\n9.8.4 境界4：机群管理与naming service 结合. . . . . . . . . . . . . 389\n第10章 C++ 编译链接模型精要391\n10.1 C 语言的编译模型及其成因. . . . . . . . . . . . . . . . . . . . . . . . . 394\n10.1.1 为什么C 语言需要预处理. . . . . . . . . . . . . . . . . . . . . . 395\n10.1.2 C 语言的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 398\n10.2 C++ 的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399\n10.2.1 单遍编译. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399\n10.2.2 前向声明. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 402\n10.3 C++ 链接（linking） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 404\n10.3.1 函数重载. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 406\n10.3.2 inline 函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 407\n10.3.3 模板. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409\n10.3.4 虚函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 414\n10.4 工程项目中头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . 415\n10.4.1 头文件的害处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 416\n10.4.2 头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . . . 417\n10.5 工程项目中库文件的组织原则. . . . . . . . . . . . . . . . . . . . . . . . 418\n10.5.1 动态库是有害的. . . . . . . . . . . . . . . . . . . . . . . . . . . . 423\n10.5.2 静态库也好不到哪儿去. . . . . . . . . . . . . . . . . . . . . . . . 424\n10.5.3 源码编译是王道. . . . . . . . . . . . . . . . . . . . . . . . . . . . 428\n第11章 反思C++ 面向对象与虚函数429\n11.1 朴实的C++ 设计. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429\n11.2 程序库的二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . . . . 431\n11.2.1 什么是二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . 432\n11.2.2 有哪些情况会破坏库的ABI . . . . . . . . . . . . . . . . . . . . . 433\n11.2.3 哪些做法多半是安全的. . . . . . . . . . . . . . . . . . . . . . . . 435\n11.2.4 反面教材：COM . . . . . . . . . . . . . . . . . . . . . . . . . . . 435\n11.2.5 解决办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 436\n11.3 避免使用虚函数作为库的接口. . . . . . . . . . . . . . . . . . . . . . . . 436\n11.3.1 C++ 程序库的作者的生存环境. . . . . . . . . . . . . . . . . . . . 437\n11.3.2 虚函数作为库的接口的两大用途. . . . . . . . . . . . . . . . . . 438\n11.3.3 虚函数作为接口的弊端. . . . . . . . . . . . . . . . . . . . . . . . 439\n11.3.4 假如Linux 系统调用以COM 接口方式实现. . . . . . . . . . . . 442\n11.3.5 Java 是如何应对的. . . . . . . . . . . . . . . . . . . . . . . . . . 443\n11.4 动态库接口的推荐做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 443\n11.5 以boost::function 和boost::bind 取代虚函数. . . . . . . . . . . . . 447\n11.5.1 基本用途. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 450\n11.5.2 对程序库的影响. . . . . . . . . . . . . . . . . . . . . . . . . . . . 451\n11.5.3 对面向对象程序设计的影响. . . . . . . . . . . . . . . . . . . . . 453\n11.6 iostream 的用途与局限. . . . . . . . . . . . . . . . . . . . . . . . . . . . 457\n11.6.1 stdio 格式化输入输出的缺点. . . . . . . . . . . . . . . . . . . . . 457\n11.6.2 iostream 的设计初衷. . . . . . . . . . . . . . . . . . . . . . . . . 461\n11.6.3 iostream 与标准库其他组件的交互. . . . . . . . . . . . . . . . . 463\n11.6.4 iostream 在使用方面的缺点. . . . . . . . . . . . . . . . . . . . . 464\n11.6.5 iostream 在设计方面的缺点. . . . . . . . . . . . . . . . . . . . . 468\n11.6.6 一个300 行的memory buffer output stream . . . . . . . . . . . 476\n11.6.7 现实的C++ 程序如何做文件IO . . . . . . . . . . . . . . . . . . . 480\n11.7 值语义与数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482\n11.7.1 什么是值语义. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482\n11.7.2 值语义与生命期. . . . . . . . . . . . . . . . . . . . . . . . . . . . 483\n11.7.3 值语义与标准库. . . . . . . . . . . . . . . . . . . . . . . . . . . . 488\n11.7.4 值语义与C++ 语言. . . . . . . . . . . . . . . . . . . . . . . . . . 488\n11.7.5 什么是数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . 490\n11.7.6 数据抽象所需的语言设施. . . . . . . . . . . . . . . . . . . . . . 493\n11.7.7 数据抽象的例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . 495\n第12章 C++ 经验谈501\n12.1 用异或来交换变量是错误的. . . . . . . . . . . . . . . . . . . . . . . . . 501\n12.1.1 编译器会分别生成什么代码. . . . . . . . . . . . . . . . . . . . . 503\n12.1.2 为什么短的代码不一定快. . . . . . . . . . . . . . . . . . . . . . 505\n12.2 不要重载全局::operator new() . . . . . . . . . . . . . . . . . . . . . . 507\n12.2.1 内存管理的基本要求. . . . . . . . . . . . . . . . . . . . . . . . . 507\n12.2.2 重载::operator new() 的理由. . . . . . . . . . . . . . . . . . . 508\n12.2.3 ::operator new() 的两种重载方式. . . . . . . . . . . . . . . . . 508\n12.2.4 现实的开发环境. . . . . . . . . . . . . . . . . . . . . . . . . . . . 509\n12.2.5 重载::operator new() 的困境. . . . . . . . . . . . . . . . . . . 510\n12.2.6 解决办法：替换malloc() . . . . . . . . . . . . . . . . . . . . . . 512\n12.2.7 为单独的class 重载::operator new() 有问题吗. . . . . . . . . 513\n12.2.8 有必要自行定制内存分配器吗. . . . . . . . . . . . . . . . . . . . 513\n12.3 带符号整数的除法与余数. . . . . . . . . . . . . . . . . . . . . . . . . . . 514\n12.3.1 语言标准怎么说. . . . . . . . . . . . . . . . . . . . . . . . . . . . 515\n12.3.2 C\/C++ 编译器的表现. . . . . . . . . . . . . . . . . . . . . . . . . 516\n12.3.3 其他语言的规定. . . . . . . . . . . . . . . . . . . . . . . . . . . . 516\n12.3.4 脚本语言解释器代码. . . . . . . . . . . . . . . . . . . . . . . . . 517\n12.3.5 硬件实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521\n12.4 在单元测试中mock 系统调用. . . . . . . . . . . . . . . . . . . . . . . . 522\n12.4.1 系统函数的依赖注入. . . . . . . . . . . . . . . . . . . . . . . . . 522\n12.4.2 链接期垫片（link seam） . . . . . . . . . . . . . . . . . . . . . . 524\n12.5 慎用匿名namespace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 526\n12.5.1 C 语言的static 关键字的两种用法. . . . . . . . . . . . . . . . . 526\n12.5.2 C++ 语言的static 关键字的四种用法. . . . . . . . . . . . . . . . 526\n12.5.3 匿名namespace 的不利之处. . . . . . . . . . . . . . . . . . . . . 527\n12.5.4 替代办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 529\n12.6 采用有利于版本管理的代码格式. . . . . . . . . . . . . . . . . . . . . . . 529\n12.6.1 对diff 友好的代码格式. . . . . . . . . . . . . . . . . . . . . . . . 530\n12.6.2 对grep 友好的代码风格. . . . . . . . . . . . . . . . . . . . . . . 537\n12.6.3 一切为了效率. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 538\n12.7 再探std::string . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539\n12.7.1 直接拷贝（eager copy） . . . . . . . . . . . . . . . . . . . . . . . 540\n12.7.2 写时复制（copy-on-write） . . . . . . . . . . . . . . . . . . . . . 542\n12.7.3 短字符串优化（SSO） . . . . . . . . . . . . . . . . . . . . . . . . 543\n12.8 用STL algorithm 轻松解决几道算法面试题. . . . . . . . . . . . . . . . 546\n12.8.1 用next_permutation() 生成排列与组合. . . . . . . . . . . . . . 546\n12.8.2 用unique() 去除连续重复空白. . . . . . . . . . . . . . . . . . . 548\n12.8.3 用{make,push,pop}_heap() 实现多路归并. . . . . . . . . . . . 549\n12.8.4 用partition() 实现“重排数组，让奇数位于偶数前面” . . . . 553\n12.8.5 用lower_bound() 查找IP 地址所属的城市. . . . . . . . . . . . . 554\n第4 部分附录559\n附录A 谈一谈网络编程学习经验561\n附录B 从《C++ Primer（第4 版）》入手学习C++ 579\n附录C 关于Boost 的看法591\n附录D 关于TCP 并发连接的几个思考题与试验593\n参考文献599","pages":"610","images":{"small":"http:\/\/img5.douban.com\/spic\/s24522799.jpg","large":"http:\/\/img5.douban.com\/lpic\/s24522799.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s24522799.jpg"},"alt":"http:\/\/book.douban.com\/subject\/20471211\/","id":"20471211","publisher":"电子工业出版社","isbn10":"7121192829","isbn13":"9787121192821","title":"Linux多线程服务端编程","url":"http:\/\/api.douban.com\/v2\/book\/20471211","alt_title":"","author_intro":"陈硕，北京师范大学硕士，擅长C++ 多线程网络编程和实时分布式系统架构。\n曾在摩根士丹利IT 部门工作5 年，从事实时外汇交易系统开发。现在在美国加州硅\n谷某互联网大公司工作，从事大规模分布式系统的可靠性工程。编写了开源C++ 网\n络库muduo，参与翻译了《代码大全（第2 版）》和《C++ 编程规范（繁体版）》，整\n理了《C++ Primer （第4 版）（评注版）》，并曾多次在各地技术大会演讲。","summary":"本书主要讲述采用现代C++ 在x86-64 Linux 上编写多线程TCP 网络服务程序的\n主流常规技术，重点讲解一种适应性较强的多线程服务器的编程模型，即one loop\nper thread。这是在Linux 下以native 语言编写用户态高性能网络程序最成熟的模\n式，掌握之后可顺利地开发各类常见的服务端网络应用程序。本书以muduo 网络库\n为例，讲解这种编程模型的使用方法及注意事项。\n本书的宗旨是贵精不贵多。掌握两种基本的同步原语就可以满足各种多线程同步\n的功能需求，还能写出更易用的同步设施。掌握一种进程间通信方式和一种多线程网\n络编程模型就足以应对日常开发任务，编写运行于公司内网环境的分布式服务系统。","price":"89.00元"},{"rating":{"max":10,"numRaters":322,"average":"8.2","min":0},"subtitle":"101条规则、准则与最佳实践","author":["（美）Herb Sutter, Andrei Alexandrescu"],"pubdate":"2006-1","tags":[{"count":311,"name":"C++","title":"C++"},{"count":109,"name":"编程","title":"编程"},{"count":72,"name":"规范","title":"规范"},{"count":57,"name":"计算机","title":"计算机"},{"count":48,"name":"C\/C++","title":"C\/C++"},{"count":40,"name":"程序设计","title":"程序设计"},{"count":34,"name":"编程技巧","title":"编程技巧"},{"count":28,"name":"programming","title":"programming"}],"origin_title":"","image":"http:\/\/img5.douban.com\/mpic\/s9101106.jpg","binding":"","translator":["刘基诚"],"catalog":"","pages":"216","images":{"small":"http:\/\/img5.douban.com\/spic\/s9101106.jpg","large":"http:\/\/img5.douban.com\/lpic\/s9101106.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s9101106.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1480481\/","id":"1480481","publisher":"人民邮电出版社","isbn10":"711514205X","isbn13":"9787115142054","title":"C++编程规范","url":"http:\/\/api.douban.com\/v2\/book\/1480481","alt_title":"","author_intro":"","summary":"《C++编程规范:101条规则准则与最佳实践》中，两位知名的C++专家将全球C++界20年的集体智慧和经验凝结成一套编程规范。这些规范可以作为每一个开发团队制定实际开发规范的基础，更是每一位C++程序员应该遵循的行事准则。书中对每一条  规范都给出了精确的描述，并辅以实例说明；从类型定义到错误处理，都给出了最佳的C++实践。即使使用C++多年的程序员也会从《C++编程规范:101条规则准则与最佳实践》中受益匪浅。《C++编程规范:101条规则准则与最佳实践》适合于各层次C++程序员使用，也可作为高等院校C++课程的教学参考书。","price":"35.00元"},{"rating":{"max":10,"numRaters":344,"average":"9.2","min":0},"subtitle":"微软技术丛书","author":["Jeffrey Richter","Christophe Nasarre"],"pubdate":"2008年9月","tags":[{"count":292,"name":"Windows编程","title":"Windows编程"},{"count":139,"name":"Windows","title":"Windows"},{"count":94,"name":"编程","title":"编程"},{"count":79,"name":"操作系统","title":"操作系统"},{"count":63,"name":"计算机","title":"计算机"},{"count":59,"name":"C++","title":"C++"},{"count":51,"name":"程序设计","title":"程序设计"},{"count":43,"name":"Programming","title":"Programming"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s3348730.jpg","binding":"16开","translator":["葛子昂","周靖","廖敏"],"catalog":"第1部分 必备知识\n第1章 错误处理\n1.1 定义自己的错误代码\n1.2 ErrorShow示例程序\n第2章 字符和字符串处理\n2.1 字符编码\n2.2 ANSI字符和Unicode字符与字符串数据类型\n2.3 Windows中的Unicode函数和ANSI函数\n2.4 C运行库中的Unicode函数和ANSI函数\n2.5 C运行库中的安全字符串函数\n2.5.1 初识新的安全字符串函数\n2.5.2 在处理字符串时如何获得更多控制\n2.5.3 Windows字符串函数\n2.6 为何要用Unicode\n2.7 推荐的字符和字符串处理方式\n2.8 Unicode与ANSI字符串转换\n2.8.1 导出ANSI和Unicode DLL函数\n2.8.2 判断文本是ANSI还是Unicode\n第3章 内核对象\n3.1 何为内核对象\n3.1.1 使用计数\n3.1.2 内核对象的安全性\n3.2 进程内核对象句柄表\n3.2.1 创建一个内核对象\n3.2.2 关闭内核对象\n3.3 跨进程边界共享内核对象\n3.3.1 使用对象句柄继承\n3.3.2 改变句柄的标志\n3.3.3 为对象命名\n3.3.4 终端服务命名空间\n3.3.5 专有命名空间\n3.3.5 复制对象句柄\n第Ⅱ部分 工作机制\n第4章 进程\n4.1 编写第一个Windows应用程序\n4.1.1 进程实例句柄\n4.1.2 进程前一个实例的句柄\n4.1.3 进程的命令行\n4.1.4 进程的环境变量\n4.1.5 进程的关联性\n4.1.6 进程的错误模式\n4.1.7 进程当前所在的驱动器和目录\n4.1.8 进程的当前目录\n4.1.9 系统版本\n4.2 CreateProcess函数\n4.2.1 pszApplicationName和pszCommandLine参数\n4.2.2 psaProcess，psaThread和bInheritHandles参数\n4.2.3 fdwCreate参数\n4.2.4 pvEnvironment参数\n4.2.5 pszCurDir参数\n4.2.6 psiStartInfo参数\n4.2.7 ppiProcInfo参数\n4.3 终止进程\n4.3.1 主线程的入口点函数返回\n4.3.2 ExitProcess函数\n4.3.3 TerminateProcess函数\n4.3.4 当进程中的所有线程终止时\n4.3.5 当进程终止运行时\n4.4 子进程\n4.5 管理员以标准用户权限运行时\n4.5.1 自动提升进程的权限\n4.5.2 手动提升进程的权限\n4.5.3 何为当前权限上下文\n4.5.4 枚举系统中正在运行的进程\n4.5.5 Process Information示例程序\n第5章 作业\n5.1 对作业中的进程施加限制\n5.2 将进程放入作业中\n5.3 终止作业中的所有线程查询作业统计信息\n5.4 作业通知\n5.6 Job Lab示例程序\n第6章 线程基础\n6.1 何时创建线程\n6.2 何时不应该创建线程\n6.3 编写第一个线程函数\n6.4 CreateThread函数\n6.4.1 psa参数\n6.4.2 cbStackSize参数\n6.4.3 pfnStartAddr和pvParam参数\n6.4.4 dwCreateFlags\n6.4.5 pdwThreadID7\n6.5 终止运行线程\n6.5.1 线程函数返回\n6.5.2 ExitThread函数\n6.5.3 TerminateThread函数\n6.5.4 进程终止运行时\n6.5.5 线程终止运行时\n6.6 线程内幕\n6.7 C\/C++运行库注意事项\n6.7.1 用_beginthreadex而不要用CreateThread创建线程\n6.7.2 绝对不应该调用的C\/C++运行库函数\n6.8 了解自己的身份\n6.8.1 将伪句柄转换为真正的句柄\n第7章 线程调度、优先级和关联性\n7.1 线程的挂起和恢复\n7.2 进程的挂起和恢复\n7.3 睡眠\n7.4 切换到另一个线程\n7.5 在超线程CPU上切换到另一个线程\n7.6 线程的执行时间\n7.7 在实际上下文中谈CONTEXT结构\n7.8 线程优先级\n7.9 从抽象角度看优先级\n7.10 优先级编程\n7.10.1 动态提升线程优先级\n7.10.2 为前台进程微调调度程序\n7.10.3 调度I\/O请求优先级\n7.10.4 Scheduling Lab 示例程序\n7.11 关联性\n第8章 用户模式下的线程同步\n8.1 原子访问：Interlocked系列函数\n8.2 高速缓存行\n8.3 高级线程同步需要避免使用的一种方法\n8.4 关键段\n8.4.1 关键段：细节\n8.4.2 关键段和旋转锁\n8.4.3 关键段和错误处理\n8.5 Slim读\/写锁\n8.6 条件变量\n8.6.1 Queue示例程序\n8.6.2 在停止线程时的死锁问题\n8.6.3 一些有用的窍门和技巧\n第9章 用内核对象进行线程同步\n9.1 等待函数\n9.2 等待成功所引起的副作用\n9.3 事件内核对象\n9.4 可等待的计时器内核对象\n9.4.1 让可等待的计时器添加APC调用\n9.4.2 计时器的剩余问题\n9.5 信号量内核对象\n9.6 互斥量内核对象\n9.6.1 遗弃问题\n9.6.2 互斥量与关键段的比较\n9.6.3 Queue示例程序\n9.7 线程同步对象速查表\n9.8 其他的线程同步函数\n9.8.1 异步设备I\/O\n9.8.2 WaitForInputIdle函数\n9.8.3 MsgWaitForMultipleObjects（Ex）函数\n9.8.4 WaitForDebugEvent函数\n9.8.5 SignalObjectAndWait函数\n9.8.6 使用等待链遍历API来检测死锁\n第10章 同步设备I\/O与异步设备I\/O\n10.1 打开和关闭设备细看CreateFile函数\n10.2 使用文件设备\n10.2.1 取得文件的大小\n10.2.2 设置文件指针的位置\n10.2.3 设置文件尾\n10.3 执行同步设备I\/O\n10.3.1 将数据刷新至设备\n10.3.2 同步I\/O的取消\n10.4 异步设备I\/O基础\n10.4.1 OVERLAPPED结构\n10.4.2 异步设备I\/O的注意事项\n10.4.3 取消队列中的设备I\/O请求\n10.5 接收I\/O请求完成通知\n10.5.1 触发设备内核对象\n10.5.2 触发事件内核对象\n10.5.3 可提醒I\/O\n10.5.4 I\/O完成端口\n10.5.5 模拟已完成的I\/O请求\n第11章 Windows线程池\n11.1 情形1：以异步方式调用函数\n11.1.1 显式地控制工作项\n11.1.2 Batch示例程序\n11.2 情形2：每隔一段时间调用一个函数\n11.3 情形3：在内核对象触发时调用一个函数\n11.4 情形4：在异步I\/O请求完成时调用一个函数\n11.5 回调函数的终止操作\n11.5.1 对线程池进行定制\n11.5.2 得体地销毁线程池：清理组\n第12章 纤程\n第Ⅲ部分 内存管理\n第13章 Windows内存体系结构\n13.1 进程的虚拟地址空间\n13.2 虚拟地址空间的分区\n13.2.1 空指针赋值分区\n13.2.2 用户模式分区\n13.3 地址空间中的区域\n13.4 给区域调拨物理存储器\n13.5 物理存储器和页交换文件\n13.6 页面保护属性\n13.6.1 写时复制\n13.6.2 一些特殊的访问保护属性标志\n13.7 实例分析\n13.8 数据对齐的重要性\n第14章 探索虚拟内存\n14.1 系统信息\n14.2 虚拟内存状态\n14.3 NUMA机器中的内存管理\n14.4 确定地址空间的状态\n14.4.1 VMQuery函数\n14.4.2 示例程序：虚拟内存映射\n第15章 在应用程序中使用虚拟内存\n15.1 预订地址空间区域\n15.2 给区域调拨物理存储器\n15.3 同时预订和调拨物理存储器\n15.4 何时调拨物理存储器\n15.5 撤销调拨物理存储器及释放区\n15.5.1 何时撤销调拨物理存储器\n15.5.2 虚拟内存分配示例程序\n15.6 改变保护属性\n15.7 重置物理存储器的内容\n15.8 地址窗口扩展\n第16章 线程栈\n16.1 C\/C++运行库的栈检查函数\n16.2 Summation示例程序\n第17章 内存映射文件\n17.1 映射到内存的可执行文件和DLL\n17.1.1 同一个可执行文件或DLL的多个实例不会共享静态数据\n17.1.2 在同一个可执行文件或DLL的多个实例间共享静态数据\n17.1.3 Application Instances示例程序\n17.2 映射到内存的数据文件\n17.2.1 方法1：一个文件，一块缓存\n17.2.2 方法2：两个文件，一块缓存\n17.2.3 方法3：一个文件，两块缓存\n17.2.4 方法4：一个文件，零个缓存\n17.3 使用内存映射文件\n17.3.1 第1步：创建或打开文件内核对象\n17.3.2 第2步：创建文件映射内核对象\n17.3.3 第3步：将文件的数据映射到进程的地址空间\n17.3.4 第4步：从进程的地址空间撤销对文件数据的映射\n17.3.5 第5步和第6步：关闭文件映射对象和文件对象\n17.6 File Reverse示例程序\n17.7 用内存映射文件来处理大文件\n17.8 内存映射文件和一致性\n17.9 给内存映射文件指定基地址\n17.10 内存映射文件的实现细节\n第18章 堆\n18.1 进程的默认堆\n18.2 为什么要创建额外的堆\n18.2.1 对组件进行保护\n18.2.2 更有效的内存管理\n18.2.3 使内存访问局部化\n18.2.4 避免线程同步的开销\n18.2.5 快速释放\n18.3 如何创建额外的堆\n18.3.1 从堆中分配内存块\n18.3.2 调整内存块的大小\n18.3.3 获得内存块的大小\n18.3.4 释放内存块\n18.3.5 销毁堆\n18.3.6 在C++中使用堆\n18.4 其他堆函数\n第Ⅳ部分 动态链接库\n第19章 DLL基础\n19.1 DLL和进程的地址空间\n19.2 纵观全局\n19.2.1 构建DLL模块\n19.2.2 构建可执行模块\n19.2.3 运行可执行模块\n第20章 DLL高级技术\n20.1 DLL模块的显式载入和符号链接\n20.1.1 显式地载入DLL模块\n20.1.2 显式地卸载DLL模块\n20.1.3 显式地链接到导出符号\n20.2 DLL的入口点函数\n20.2.1 DLL_PROCESS_ATTACH通知\n20.2.2 DLL_PROCESS_DETACH通知\n20.2.3 DLL_THREAD_ATTACH通知\n20.2.4 DLL_THREAD_DETACH通知\n20.2.5 DllMain的序列化调用\n20.2.6 DllMain和C\/C++运行库\n20.3 延迟载入DLL\n20.4 函数转发器\n20.5 已知的DLL\n20.6 DLL重定向\n20.7 模块的基地址重定位\n20.8 模块的绑定\n第21章 线程局部存储区\n21.1 动态TLS\n21.2 静态TLS0\n第22章 DLL注入和API拦截\n22.1 DLL注入的一个例子\n22.2 使用注册表来注入DLL\n22.3 使用Windows挂钩来注入DLL\n22.4 使用远程线程来注入DLL\n22.4.1 Inject Library示例程序\n22.4.2 Image Walk DLL\n22.5 使用木马DLL来注入DLL\n22.6 把DLL作为调试器来注入\n22.7 使用CreateProcess来注入代码\n22.8 API拦截的一个例子9\n22.8.1 通过覆盖代码来拦截API0\n22.8.2 通过修改模块的导入段来拦截API\n22.8.3 Last MessageBox Info示例程序\n第Ⅴ部分 结构化异常处理\n第23章 终止处理程序\n第24章 异常处理程序与软件异常\n24.1 通过实例理解异常过滤程序和异常处理程序\n24.1.1 Funcmeister1函数\n24.1.2 Funcmeister2函数\n24.2 EXCEPTION_EXECUTE_HANDLER1\n24.2.1 一些有用的例子\n24.2.2 全局展开\n24.2.3 停止全局展开\n24.3 EXCEPTION_CONTINUE_EXECUTION\n24.4 EXCEPTION_CONTINUE_SEARCH0\n24.5 GetExceptionCode2\n24.6 GetExceptionInformation6\n24.7 软件异常\n第25章 未处理异常、向量化异常处理与C++异常\n25.1 UnhandledExceptionFilter函数详解\n25.2 即时调试\n25.3 电子表格示例程序\n25.4 向量化异常和继续处理程序\n25.5 C++异常与结构化异常的比较\n25.6 异常与调试器\n第26章 错误报告与应用程序恢复\n26.1 Windows错误报告控制台\n26.2 可编程的Windows错误报告\n26.3 对进程中所有的问题报告进行定制\n26.4 问题报告的创建与定制\n26.4.1 创建一个自定义的问题报告\n26.4.2 设置报告参数：WerReportSetParameter\n26.4.3 将小型转储文件放入报告：WerReportAddDump8\n26.4.4 将任意文件放入报告：WerReportAddFile9\n26.4.5 修改对话框文本：WerReportSetUIOption0\n26.4.6 提交错误报告：WerReportSubmit0\n26.4.7 关闭问题报告：WerReportCloseHandle\n26.4.8 Customized WER示例程序\n26.5 应用程序的自动重启与恢复\n26.5.1 应用程序的自动重启\n26.5.2 对应用程序恢复的支持\n第Ⅵ部分\n附录A 构建环境\n附录B 消息处理宏、子控件宏和API宏\n索引","pages":"770","images":{"small":"http:\/\/img3.douban.com\/spic\/s3348730.jpg","large":"http:\/\/img3.douban.com\/lpic\/s3348730.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s3348730.jpg"},"alt":"http:\/\/book.douban.com\/subject\/3235659\/","id":"3235659","publisher":"清华大学出版社","isbn10":"7302184003","isbn13":"9787302184003","title":"Windows核心编程(第5版)","url":"http:\/\/api.douban.com\/v2\/book\/3235659","alt_title":"Windows via C\/C++","author_intro":"Jeffrey Richter是一位在全球享有盛誉的技术作家，尤其在Windows\/.NET领域有着杰出的贡献。他的第一本Windows著作Windows 3: A Developer's Guide大获好评，从而声名远扬。之后，他又推出了经典著作《Windows 高级编程指南》和《Windows核心编程》。如今这两本书早已成为Windows程序设计领域的颠峰之作，培育了几代软件开发设计人员。他的每一本新作问世，我们都有理由相信这是一本巨著，我们想要的一切尽在其中。Jeffery 是Wintellect公司的创始人之一，也是MSDN杂志.NET专栏的特邀编辑。现在他正领导开发该公司的.NET程序设计课程，向大众推广.NET技术。因为他自1999年开始就参与了微软.NET框架开发组的咨询工作，与这些一线人员一起经历了.NET的孕育与诞生，所以他对.NET思想的领悟、对.NET的细节熟稔，是其他任何作家难以企及的。他是.NET著作领域中当之无愧的一面旗帜。\nChristophe Nasarre是Business Objects的软件架构师和开发部门领导，该公司致力于帮助其他企业更好地专注于其主营业务，通过商业智能方案来提升决策能力和业绩。他为Addison-Wesley，APress和Microsoft Press出版的许多图书担任过技术审校，此外还是MSDN Magazine的撰稿人。","summary":"这是一本经典的Windows核心编程指南，从第1版到第5版，引领着数十万程序员走入Windows开发阵营，培养了大批精英。.\n作为Windows开发人员的必备参考，本书是为打算理解Windows的C和C++程序员精心设计的。第5版全面覆盖Windows XP，Windows Vista和Windows Server 2008中的170个新增函数和Windows特性。书中还讲解了Windows系统如何使用这些特性，我们开发的应用程序又如何充分使用这些特性，如何自行创建新的特性。...","price":"99.00元"},{"rating":{"max":10,"numRaters":525,"average":"9.0","min":0},"subtitle":"第3版.","author":["[美] Bruce Eckel"],"pubdate":"2005-9","tags":[{"count":325,"name":"java","title":"java"},{"count":132,"name":"编程","title":"编程"},{"count":99,"name":"java编程思想","title":"java编程思想"},{"count":73,"name":"计算机","title":"计算机"},{"count":52,"name":"Programming","title":"Programming"},{"count":46,"name":"软件开发","title":"软件开发"},{"count":33,"name":"技术","title":"技术"},{"count":27,"name":"软件思想","title":"软件思想"}],"origin_title":"","image":"http:\/\/img5.douban.com\/mpic\/s1320039.jpg","binding":"平装","translator":[],"catalog":"","pages":"756","images":{"small":"http:\/\/img5.douban.com\/spic\/s1320039.jpg","large":"http:\/\/img5.douban.com\/lpic\/s1320039.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s1320039.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1313042\/","id":"1313042","publisher":"机械工业出版社","isbn10":"711116220X","isbn13":"9787111162209","title":"Java编程思想","url":"http:\/\/api.douban.com\/v2\/book\/1313042","alt_title":"","author_intro":"","summary":"Java编程思想（第三版），ISBN：9787111162209，作者：（美）Bruce Eckel著；陈昊鹏，饶若楠等译；陈昊鹏译","price":"95.00元"},{"rating":{"max":10,"numRaters":279,"average":"8.8","min":0},"subtitle":"","author":["戈茨"],"pubdate":"2007-6","tags":[{"count":341,"name":"Java","title":"Java"},{"count":206,"name":"并发","title":"并发"},{"count":137,"name":"concurrency","title":"concurrency"},{"count":133,"name":"并发编程","title":"并发编程"},{"count":94,"name":"多线程","title":"多线程"},{"count":50,"name":"编程","title":"编程"},{"count":44,"name":"计算机","title":"计算机"},{"count":34,"name":"java","title":"java"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s2764832.jpg","binding":"","translator":[],"catalog":"","pages":"403","images":{"small":"http:\/\/img3.douban.com\/spic\/s2764832.jpg","large":"http:\/\/img3.douban.com\/lpic\/s2764832.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s2764832.jpg"},"alt":"http:\/\/book.douban.com\/subject\/2148132\/","id":"2148132","publisher":"电子工业出版社","isbn10":"7121043165","isbn13":"9787121043161","title":"JAVA并发编程实践","url":"http:\/\/api.douban.com\/v2\/book\/2148132","alt_title":"","author_intro":"","summary":"《JAVA并发编程实践》随着多核处理器的普及，使用并发成为构建高性能应用程序的关键。Java 5以及6在开发并发程序中取得了显著的进步，提高了Java虚拟机的性能以及并发类的可伸缩性，并加入了丰富的新并发构建块。在《JAVA并发编程实践》中，这些便利工具的创造者不仅解释了它们究竟如何工作、如何使用，还阐释了创造它们的原因，及其背后的设计模式。","price":"58.00元"},{"rating":{"max":10,"numRaters":57,"average":"8.0","min":0},"subtitle":"","author":["Alexander Stepanov","Paul McJones"],"pubdate":"2012-1-10","tags":[{"count":238,"name":"编程","title":"编程"},{"count":150,"name":"计算机科学","title":"计算机科学"},{"count":91,"name":"程序设计","title":"程序设计"},{"count":82,"name":"计算机","title":"计算机"},{"count":67,"name":"数学","title":"数学"},{"count":53,"name":"算法","title":"算法"},{"count":46,"name":"Programming","title":"Programming"},{"count":38,"name":"编程风格","title":"编程风格"}],"origin_title":"Elements of Programming","image":"http:\/\/img3.douban.com\/mpic\/s7027640.jpg","binding":"平装","translator":["裘宗燕"],"catalog":"译者序\n前言\n关于作者\n第1章  基础................................ 1\n1.1理念范畴:实体,类别,类属.................1\n1.2值.....................................2\n1.3对象....................................4\n1.4过程....................................6\n1.5规范类型.................................7\n1.6规范过程.................................8\n1.7概念....................................10\n1.8总结....................................14\n第2章  变换及其轨道........................ 15\n2.1变换....................................15\n2.2轨道....................................18\n2.3碰撞点...................................21\n2.4轨道规模的度量.............................27\n2.5动作....................................28\n2.6总结....................................29\n第3章  可结合运算.......................... 31\n3.1可结合性.................................31\n3.2计算乘幂.................................32\n3.3程序变换.................................35\n3.4处理特殊情况的过程..........................40\n3.5参数化算法................................43\n3.6线性递归.................................44\n3.7累积过程.................................47\n3.8总结....................................48\n第4章  线性序................................ 49\n4.1关系的分类................................49\n4.2全序和弱序................................51\n4.3按序选取.................................52\n4.4自然全序.................................62\n4.5派生过程组................................63\n4.6按序选取过程的扩展..........................63\n4.7总结....................................64\n第5章  有序代数结........................... 65\n5.1基本代数结构..............................65\n5.2有序代数结构..............................70\n5.3求余....................................72\n5.4最大公因子................................76\n5.5广义gcd..................................79\n5.6Steingcd.................................81\n5.7商.....................................82\n5.8负量的商和余数.............................84\n5.9概念及其模型..............................87\n5.10计算机整数类型.............................88\n5.11结论....................................89\n第6章  迭代器.............................. 91\n6.1可读性...................................91\n6.2迭代器...................................92\n6.3范围....................................94\n6.4可读范围.................................97\n6.5递增的范围................................106\n6.6前向迭代器................................108\n6.7索引迭代器................................113\n6.8双向迭代器................................114\n6.9随机访问迭代器.............................115\n6.10总结....................................117\n第7章坐标结构.............................. 119\n7.1二叉坐标.................................119\n7.2双向二叉坐标..............................123\n7.3坐标结构.................................129\n7.4同构,等价和有序............................129\n7.5总结....................................137\n第8章  后继可变的坐标....................... 139\n8.1链接迭代器................................139\n8.2链接重整.................................140\n8.3链接重整的应用.............................147\n8.4链接的二叉坐标.............................151\n8.5结论....................................155\n第9章拷贝.................................. 157\n9.1可写性...................................157\n9.2基于位置的拷贝.............................159\n9.3基于谓词的拷贝.............................166\n9.4范围的交换................................174\n9.5总结....................................178\n第10章  重整............................... 179\n10.1置换....................................179\n10.2重整....................................182\n10.3 反转算法.................................184\n10.4 轮换算法.................................188\n10.5 算法选择.................................196\n10.6 总结....................................200\n第11章  划分和归并.......................... 201\n11.1划分....................................201\n11.2平衡的归约................................207\n11.3归并....................................212\n11.4总结....................................218\n第12章  复合对象........................... 219\n12.1简单复合对象..............................219\n12.2动态序列.................................227\n12.3基础类型.................................233\n12.4总结....................................236\n跋......................................... 237\n附录A  数学表示............................ 241\n附录B  程序设计语言........................ 243\n参考文献................................... 253\n索引....................................... 257","pages":"281","images":{"small":"http:\/\/img3.douban.com\/spic\/s7027640.jpg","large":"http:\/\/img3.douban.com\/lpic\/s7027640.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s7027640.jpg"},"alt":"http:\/\/book.douban.com\/subject\/7564093\/","id":"7564093","publisher":"机械工业出版社华章公司","isbn10":"7111367294","isbn13":"9787111367291","title":"编程原本","url":"http:\/\/api.douban.com\/v2\/book\/7564093","alt_title":"Elements of Programming","author_intro":"Alexander Stepanov 于1967~1972年间在国立莫斯科大学学习数学，从1972年开始在苏联，1977年移民后继续在美国从事编程工作。他编写过操作系统、编程工具、编译器和各种程序库。他在程序设计基础方面的工作先后得到GE、Polytechnic、AT&T、惠普、SGI和Adobe的支持。1995年因C++标准模板库的设计获Dr. Dobb, Journal的程序设计杰出贡献奖。\nPaul McJones 于1967~1971年间在加州大学伯克利分校学习工程数学。从1967年开始介入程序设计，涉足的领域包括操作系统、程序设计环境、事务处理系统以及企业和客户应用系统等。他先后在加州大学、IBM、Xerox、Tandem、DEC和Adobe工作。1982年他与合作者一起因论文“The Recovery Manager of the System R Database Manager”获得ACM程序设计系统和语言论文奖。","summary":"本书提供了有关编程的一种与众不同的理解。其主旨是，实际的编程也应像其他科学和工程领域一样基于坚实的数学基础。本书展示了在实际编程语言（如C++）中实现的算法如何在最一般的数学背景中操作。例如，如何定义快速求幂算法，使之能使用任何可交换运算。使用抽象算法将能得到更高效、可靠、安全和经济的软件。\n这不是一本很容易读的书，它也不是能提升你的编程技能的秘诀和技巧汇编。本书的价值是更根本性的，其终极目标是提升你对编程的洞察力。要想从中大获裨益，你需要从头到尾认真学习：阅读代码，证明引理，完成练习。到结束之时，你将看到如何把这里讨论的演绎方法应用到你的程序中，保证你做出的软件部件能一起工作，并表现出它们所应该表现的行为。\n书中给出的算法和需求针对某些被操作的类型。有关这些描述的代码（也可以通过Web得到）采用C++的一个小子集书写，这样做是为了让所有有经验的程序员都能理解。这个小子集可以看做一种特殊语言，是由Sean Parent和Bjarne Stroustrup一起设计的。\n无论你是一位软件开发者，还是其他以编程作为一项重要活动的专业人员，或者是一名在校的学生，你都会逐渐理解本书的经验丰富的作者多年来一直在教授和阐释的道理：数学对于编程是绝好的东西，理论对于实际是绝好的东西。","price":"59.00元"},{"rating":{"max":10,"numRaters":243,"average":"9.2","min":0},"subtitle":"","author":["Bruce Molay","杨宗源","黄海涛"],"pubdate":"2004-10-1","tags":[{"count":235,"name":"linux","title":"linux"},{"count":164,"name":"编程","title":"编程"},{"count":118,"name":"Linux\/Unix","title":"Linux\/Unix"},{"count":96,"name":"unix","title":"unix"},{"count":81,"name":"Programming","title":"Programming"},{"count":59,"name":"计算机","title":"计算机"},{"count":51,"name":"Linux","title":"Linux"},{"count":46,"name":"C","title":"C"}],"origin_title":"Understanding UNIX\/LINUX Programming","image":"http:\/\/img5.douban.com\/mpic\/s1164759.jpg","binding":"平装（带盘）","translator":["杨宗源","黄海涛"],"catalog":"第1章 Unix系统编程概述\n第2章 用户、文件操作与联机帮助：编写who命令\n第3章 目录与文件属性：编写IS\n第4章 文件系统：编写PWD\n第5章 连接控制：学习STTY\n第6章 为用户编程：终端控制和信号\n第7章 事件驱动编程：编写一个视频游戏\n第8章 进程和程序：编写命令解释器she\n第9章 可编程的shell、shell变量和环境：编写自己的shell \n第10章 1\/0重定向和管道\n……","pages":"495","images":{"small":"http:\/\/img5.douban.com\/spic\/s1164759.jpg","large":"http:\/\/img5.douban.com\/lpic\/s1164759.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s1164759.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1219329\/","id":"1219329","publisher":"清华大学出版社","isbn10":"7302096139","isbn13":"9787302096139","title":"Unix\/Linux编程实践教程","url":"http:\/\/api.douban.com\/v2\/book\/1219329","alt_title":"Understanding UNIX\/LINUX Programming","author_intro":"","summary":"Unix\/Linux编程实践教程：国外经典教材，ISBN：9787302096139，作者：（美）Bruce Molay著；杨宗源，黄海涛译；杨宗源译","price":"56.00元"},{"rating":{"max":10,"numRaters":239,"average":"8.5","min":0},"subtitle":"","author":["周爱民"],"pubdate":"2008-3","tags":[{"count":316,"name":"javascript","title":"javascript"},{"count":86,"name":"周爱民","title":"周爱民"},{"count":65,"name":"JAVASCRIPT语言精髓与编程实践","title":"JAVASCRIPT语言精髓与编程实践"},{"count":61,"name":"JavaScript","title":"JavaScript"},{"count":40,"name":"编程","title":"编程"},{"count":39,"name":"程序设计","title":"程序设计"},{"count":39,"name":"web","title":"web"},{"count":37,"name":"动态语言","title":"动态语言"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s2970031.jpg","binding":"平装","translator":[],"catalog":"","pages":"510","images":{"small":"http:\/\/img3.douban.com\/spic\/s2970031.jpg","large":"http:\/\/img3.douban.com\/lpic\/s2970031.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s2970031.jpg"},"alt":"http:\/\/book.douban.com\/subject\/3012828\/","id":"3012828","publisher":"电子工业出版社","isbn10":"7121056879","isbn13":"9787121056871","title":"JAVASCRIPT语言精髓与编程实践","url":"http:\/\/api.douban.com\/v2\/book\/3012828","alt_title":"","author_intro":"","summary":"《JAVASCRIPT语言精髓与编程实践》讲述了JavaScript的语言实现与扩展，主要包括以下三个方面的内容：（1）动态、函数式语言，以及其它语言特性在JavaScript的表现与应用；（2）如何用动态函数式语言的特性来扩展JavaScript的语言特性与框架；（3）如何将JavaScript引擎整合到其它高级语言的开发过程中。","price":"68.00元"},{"rating":{"max":10,"numRaters":163,"average":"7.2","min":0},"subtitle":"","author":["谭亮"],"pubdate":"2011-6","tags":[{"count":228,"name":"processing","title":"processing"},{"count":151,"name":"交互设计","title":"交互设计"},{"count":85,"name":"编程","title":"编程"},{"count":76,"name":"新媒体","title":"新媒体"},{"count":70,"name":"设计","title":"设计"},{"count":55,"name":"艺术","title":"艺术"},{"count":33,"name":"Processing","title":"Processing"},{"count":21,"name":"新媒介","title":"新媒介"}],"origin_title":"","image":"http:\/\/img5.douban.com\/mpic\/s6514269.jpg","binding":"","translator":[],"catalog":"目 录\n第1章 认识Processing 1\n1.1 Processing是什么 2\n1.2 Processing的诞生 3\n1.2.1 MIT与约翰•梅达 3\n1.2.2 Casey Reas和Ben Fry 6\n1.3 Processing能做什么 8\n1.3.1 数据视觉化 8\n1.3.2 生成艺术 10\n1.3.3 互动艺术 14\n第2章 使用Processing 17\n2.1 下载与安装 17\n2.2 开发环境 18\n2.2.1 开发环境界面 18\n2.2.2 快捷按钮 20\n2.3 语法结构 20\n2.3.1 基本语句 21\n2.3.2 代码编写流程 22\n2.3.3 注释 22\n2.3.4 表达式和陈述 23\n2.3.5 控制台 24\n2.4 变量 24\n2.4.1 声明一个变量 25\n2.4.2 变量的类型 26\n2.4.3 系统变量 27\n2.5 符号与条件式 28\n2.5.1 布尔表达式 28\n2.5.2 算术运算符 28\n2.5.3 关系操作符 29\n2.5.4 逻辑操作符 29\n2.5.5 条件式——if、else和else if 33\n本章作业 36\n第3章 绘画 39\n3.1 画布与坐标 39\n3.1.1 像素与画布 39\n3.1.2 直角坐标与计算机屏幕坐标 40\n3.2 图形 41\n3.2.1 点 41\n3.2.2 直线 42\n3.2.3 矩形 42\n3.2.4 圆与圆弧形 43\n3.2.5 三角形与四边形 45\n3.2.6 贝塞尔曲线 46\n3.2.7 自由图形 47\n3.3 色彩 49\n3.3.1 灰阶与透明度 50\n3.3.2 RGB色彩 52\n3.3.3 HSB色彩 53\n3.4 绘画属性设定 55\n3.4.1 填色与边框 55\n3.4.2 图形的顺序 56\n3.5 重复绘画 58\n3.5.1 简单的重复 58\n3.5.2 迭代法与while循环 59\n3.5.3 for 循环 60\n3.6 PDF输出与绘画实例 62\n3.6.1 PDF格式输出 62\n3.6.2 绘画实例 63\n3.6.3 学生作品欣赏 64\n本章作业 66\n第4章 响应互动 67\n4.1 鼠标响应 67\n4.1.1 鼠标移动响应mouseX 和 mouseY 67\n4.1.2 pmouseX和pmouseY 70\n4.1.3 鼠标响应事件 72\n4.2 键盘响应 75\n4.2.1 按击键响应 75\n4.2.2 特定按键响应 78\n4.2.3 功能键响应 79\n4.3 随机random 80\n4.4 限制constrain 83\n本章作业 84\n第5章 动画 85\n5.1 运动的产生 85\n5.1.1 变量控制运动 85\n5.1.2 条件句控制运动 86\n5.1.3 加速与减速 87\n5.2 随机运动 89\n5.3 曲线轨迹运动 90\n5.4 坐标转移、旋转与缩放 95\n5.4.1 坐标转移 95\n5.4.2 旋转运动 96\n5.4.3 缩放运动 99\n5.5 pushMatrix() 与 popMatrix() 100\n5.6 时间控制 102\n本章作业 103\n第6章 函数与对象 105\n6.1 函数 105\n6.1.1 定义函数 105\n6.1.2 调用函数 109\n6.1.3 函数与循环 111\n6.1.4 函数返回类型 114\n6.2 类与对象 115\n6.2.1 面向对象的程序设计 115\n6.2.2 定义类 116\n6.2.3 创建对象 119\n6.2.4 构造器的引数 121\n本章作业 124\n第7章 数组 125\n7.1 变量列数组 127\n7.1.1 声明变量列数组 127\n7.1.2 定义数组的长度 128\n7.1.3 给数组赋值 128\n7.2 变量列数组实例 130\n7.3 对象的数组 134\n本章作业 137\n第8章 图片与文字 139\n8.1 图片 139\n8.1.1 显示图片 139\n8.1.2 图片互动 143\n8.1.3 图片色彩设置 144\n8.2 文字 147\n8.2.1 使用字体 147\n8.2.2 字符串 148\n本章作业 150\n第9章 视频 151\n9.1 播放视频文件 151\n9.2 实时视频输入 155\n9.3 视频互动特效 158\n9.3.1 互动色彩调整 158\n9.3.2 视频马赛克 159\n9.3.3 色彩捕捉 161\n9.3.4 版画效果 166\n本章作业 169\n第10章 Minim音频 171\n10.1 播放音频 171\n10.2 声音的视觉化 173\n10.3 音频输入互动 179\n本章作业 181\n第11章 3D 183\n11.1 3D简介 183\n11.2 3D图形 184\n11.3 3D空间旋转 185\n11.4 3D互动 187\n11.5 参考案例 190\n本章作业 192\n第12章 Arduino与物理计算 193\n12.1 Arduino简介 193\n12.2 Arduino与开关 195\n12.3 Arduino与传感器 197\n12.4 光敏传感器 200\n本章作业 202\n附录A 203\n后记 205\n参考书目 206","pages":"220","images":{"small":"http:\/\/img5.douban.com\/spic\/s6514269.jpg","large":"http:\/\/img5.douban.com\/lpic\/s6514269.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s6514269.jpg"},"alt":"http:\/\/book.douban.com\/subject\/6517501\/","id":"6517501","publisher":"电子工业出版社","isbn10":"7121134632","isbn13":"9787121134630","title":"Processing互动编程艺术","url":"http:\/\/api.douban.com\/v2\/book\/6517501","alt_title":"","author_intro":"谭亮，2004年至今任教于广州美术学院新媒介艺术专业，致力于互动艺术、编程艺术教学与研究。2005年作品参加日本爱知世界博览会中国馆数字艺术项目。2007年赴德国柏林设计学院信息设计系交流，“城市突变”国际工作坊指导教师。2008年在英国文化协会主办的“香港48小时和合设计竞赛”中获得Best Design奖。2009年赴法国埃克斯•普罗旺斯艺术学院访问学习。","summary":"内容简介\n本书将引领你进入编程艺术的世界。本书揭示了运用Processing创建高质量互动艺术作品的奥秘，你将感受到Processing的敏捷性和艺术性，内容覆盖绘图、响应互动、动画、视频、3D、物理计算等专题。精选的实例将激发读者的想象力和创造的乐趣，阅读和练习本书的案例即能快速进入互动艺术创作。本书语言简洁易懂，案例设计独特，所有代码均可在线下载，适合于专业编程人员和学习互动艺术的读者。\n前 言\n编程，即计算机程序设计，是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。也许有人认为编程课程只适合于理工类专业，对艺术设计类专业来讲似乎意义不大，实际上并非这样。程序设计技术的先驱者唐纳德·克努特认为，程序设计既是一门科学，也是一门艺术，这两方面可以彼此很好地相互补充。科学的方法一般是通过“逻辑的”、“系统的”、“非个人的”、“冷静的”、“理性的”这些词来表征的，而艺术的方法是通过“艺术的”、“创新的”、“博爱的”、“渴望的”、“非理性的”这些词来表征的。\n2009年11月，英国伦敦V&A博物馆“数字设计感官展”展出了大量由计算机程序生成的互动艺术作品，展览打破了作品静态呈现的传统展示方式，颠覆了观众静观作品的观看惯性。计算机程序对艺术的介入引发了艺术家创作工具和思维方式的转变。研究如何编写程序、创造声音或图像的界面以实现代码与观众之间的交流互动，成为设计艺术界新的课题。美国排名前列的罗德岛设计学院聘请麻省理工媒体实验室ACG小组主任约翰·梅达担任校长，传统的艺术设计行业正面临着一场革命。编写程序不仅是程序员的专利，它也已成为数字艺术家的创作手段，以及艺术院校的必修课程。英国皇家艺术学院、耶鲁大学设计学院、加州大学媒体艺术专业、卡内基梅隆大学等院校都把编程作为教学课题。\n大部分设计师都会使用商业软件（如 Photoshop、Illustrator、Flash）来从事创作，这些软件功能丰富、使用方便，可以实现预设的效果。但人们的创意和表现形式往往被企业所主导的制式化生产工具所限制。Processing的出现是艺术设计创作的一场革命，它是一种具有前瞻性的新兴计算机语言，用户主要面向计算机程序员和数字艺术家。艺术家可以运用Processing生成唯美的图形，为互动艺术作品编写程序，将抽象的数据呈现为视觉形象。当你进入到互动编程艺术的世界，就会发现这一切都是让人兴奋不已的。\n由于文化和语言的差异，国内研究Processing的学术机构并不多见，中文网站和学术论坛等学习资源有限，也没有相关的中文版本的书籍。资料的缺乏在很大程度上降低了中国设计师学习Processing的积极性。鉴于以上现实，作者根据自身的教学实践编写了本书。本书可作为学习互动艺术编程的基础书籍，主要面向艺术院校数字媒体设计专业、交互设计专业，以及业界的设计师，等等。本书前两章主要介绍了Processing的背景、编程与互动艺术的关系，以及编程基础知识。接下来的章节对绘画、互动、动画、函数与对象、数组、图片与文字、视频与音频、3D与物理计算等方面进行了较为全面的论述，并结合了大量的实例与作品分析来启发读者的互动艺术思维。在国内，互动艺术和编程艺术都是新的研究领域，本书是在一个全新的领域中进行探索，在此过程中难免会存在不完善之处，希望得到相关专家和广大读者的批评指正！\n在创意产业迅速发展的中国，我们有理由相信新一代的艺术家和设计师们不会只停留在软件应用的层次，他们会运用编程去创新、发展艺术与设计，并将民族文化与思想注入到作品中！\n作者：谭亮\n2011年5月于广州","price":"39.00元"},{"rating":{"max":10,"numRaters":413,"average":"8.7","min":0},"subtitle":"","author":["[英] Jeremy Keith","[加] Jeffrey Sambells"],"pubdate":"2011-4","tags":[{"count":317,"name":"javascript","title":"javascript"},{"count":174,"name":"前端开发","title":"前端开发"},{"count":151,"name":"JavaScript","title":"JavaScript"},{"count":116,"name":"dom","title":"dom"},{"count":72,"name":"前端","title":"前端"},{"count":63,"name":"编程","title":"编程"},{"count":51,"name":"web开发","title":"web开发"},{"count":46,"name":"Web","title":"Web"}],"origin_title":"DOM Scripting: Web Design with JavaScript and the Document Object Model","image":"http:\/\/img3.douban.com\/mpic\/s4677623.jpg","binding":"平装","translator":["杨涛","王建桥","杨晓云 等"],"catalog":"第1章 JavaScript简史\t1\n1.1 JavaScript的起源\t1\n1.2 DOM\t2\n1.3 浏览器战争\t3\n1.3.1 DHTML\t3\n1.3.2 浏览器之间的冲突\t3\n1.4 制定标准\t4\n1.4.1 浏览器以外的考虑\t4\n1.4.2 浏览器战争的结局\t5\n1.4.3 崭新的起点\t5\n1.5 小结\t6\n第2章 JavaScript语法\t8\n2.1 准备工作\t8\n2.2 语法\t10\n2.2.1 语句\t10\n2.2.2 注释\t10\n2.2.3 变量\t11\n2.2.4 数据类型\t14\n2.2.5 数组\t16\n2.2.6 对象\t18\n2.3 操作\t19\n2.4 条件语句\t21\n2.4.1 比较操作符\t22\n2.4.2 逻辑操作符\t23\n2.5 循环语句\t24\n2.5.1 while循环\t24\n2.5.2 for循环\t25\n2.6 函数\t26\n2.7 对象\t29\n2.7.1 内建对象\t30\n2.7.2 宿主对象\t31\n2.8 小结\t31\n第3章 DOM\t32\n3.1 文档：DOM中的“D”\t32\n3.2 对象：DOM中的“O”\t32\n3.3 模型：DOM中的“M”\t33\n3.4 节点\t35\n3.4.1 元素节点\t35\n3.4.2 文本节点\t35\n3.4.3 属性节点\t36\n3.4.4 CSS\t36\n3.4.5 获取元素\t38\n3.4.6 盘点知识点\t42\n3.5 获取和设置属性\t43\n3.5.1 getAttribute\t43\n3.5.2 setAttribute\t44\n3.6 小结\t45\n第4章 案例研究：JavaScript图片库\t46\n4.1 标记\t46\n4.2 JavaScript\t48\n4.2.1 非DOM解决方案\t49\n4.2.2 最终的函数代码清单\t50\n4.3 应用这个JavaScript函数\t50\n4.4 对这个函数进行扩展\t52\n4.4.1 childNodes属性\t53\n4.4.2 nodeType属性\t54\n4.4.3 在标记里增加一段描述\t54\n4.4.4 用JavaScript改变这段描述\t55\n4.4.5 nodeValue属性\t56\n4.4.6 firstChild和lastChild属性\t56\n4.4.7 利用nodeValue属性刷新这段描述\t57\n4.5 小结\t60\n第5章 最佳实践\t61\n5.1 过去的错误\t61\n5.1.1 不要怪罪JavaScript\t61\n5.1.2 Flash的遭遇\t62\n5.1.3 质疑一切\t63\n5.2 平稳退化\t63\n5.2.1 “javascript:”伪协议\t64\n5.2.2 内嵌的事件处理函数\t65\n5.2.3 谁关心这个\t65\n5.3 向CSS学习\t66\n5.3.1 结构与样式的分离\t66\n5.3.2 渐进增强\t67\n5.4 分离JavaScript\t68\n5.5 向后兼容\t70\n5.5.1 对象检测\t70\n5.5.2 浏览器嗅探技术\t71\n5.6 性能考虑\t72\n5.6.1 尽量少访问DOM和尽量减少标记\t72\n5.6.2 合并和放置脚本\t73\n5.6.3 压缩脚本\t73\n5.7 小结\t74\n第6章 案例研究：图片库改进版\t75\n6.1 快速回顾\t75\n6.2 它支持平稳退化吗\t76\n6.3 它的JavaScript与HTML标记是分离的吗\t77\n6.3.1 添加事件处理函数\t77\n6.3.2 共享onload事件\t82\n6.4 不要做太多的假设\t84\n6.5 优化\t86\n6.6 键盘访问\t88\n6.7 把JavaScript与CSS结合起来\t90\n6.8 DOM Core和HTML-DOM\t93\n6.9 小结\t94\n第7章 动态创建标记\t96\n7.1 一些传统方法\t96\n7.1.1 document.write\t96\n7.1.2 innerHTML属性\t98\n7.2 DOM方法\t101\n7.2.1 createElement方法\t101\n7.2.2 appendChild方法\t102\n7.2.3 createTextNode方法\t103\n7.2.4 一个更复杂的组合\t105\n7.3 重回图片库\t107\n7.3.1 在已有元素前插入一个新元素\t108\n7.3.2 在现有方法后插入一个新元素\t109\n7.3.3 图片库二次改进版\t111\n7.4 Ajax\t114\n7.4.1 XMLHttpRequest对象\t115\n7.4.2 渐进增强与Ajax\t119\n7.4.3 Hijax\t120\n7.5 小结\t121\n第8章 充实文档的内容\t122\n8.1 不应该做什么\t122\n8.2 把“不可见”变成“可见”\t123\n8.3 内容\t123\n8.3.1 选用HTML、XHTML还是HTML5\t124\n8.3.2 CSS\t126\n8.3.3 JavaScript\t127\n8.4 显示“缩略语列表”\t127\n8.4.1 编写displayAbbreviations函数\t128\n8.4.2 创建标记\t130\n8.4.3 一个浏览器“地雷”\t135\n8.5 显示“文献来源链接表”\t138\n8.6 显示“快捷键清单”\t143\n8.7 检索和添加信息\t146\n8.8 小结\t147\n第9章 CSS-DOM\t148\n9.1 三位一体的网页\t148\n9.1.1 结构层\t148\n9.1.2 表示层\t148\n9.1.3 行为层\t149\n9.1.4 分离\t150\n9.2 style属性\t150\n9.2.1 获取样式\t151\n9.2.2 设置样式\t156\n9.3 何时该用DOM脚本设置样式\t158\n9.3.1 根据元素在节点树里的位置来设置样式\t158\n9.3.2 根据某种条件反复设置某种样式\t161\n9.3.3 响应事件\t165\n9.4 className属性\t167\n9.5 小结\t171\n第10章 用JavaScript实现动画效果\t172\n10.1 动画基础知识\t172\n10.1.1 位置\t172\n10.1.2 时间\t175\n10.1.3 时间递增量\t175\n10.1.4 抽象\t178\n10.2 实用的动画\t184\n10.2.1 提出问题\t184\n10.2.2 解决问题\t186\n10.2.3 CSS\t187\n10.2.4 JavaScript\t189\n10.2.5 变量作用域问题\t192\n10.2.6 改进动画效果\t193\n10.2.7 添加安全检查\t196\n10.2.8 生成HTML标记\t198\n10.3 小结\t200\n第11章 HTML5\t201\n11.1 HTML5简介\t201\n11.2 来自朋友的忠告\t203\n11.3 几个示例\t204\n11.3.1 Canvas\t205\n11.3.2 音频和视频\t209\n11.3.3 表单\t215\n11.4 HTML5还有其他特性吗\t219\n11.5 小结\t219\n第12章 综合示例\t220\n12.1 项目简介\t220\n12.1.1 原始资料\t220\n12.1.2 站点结构\t220\n12.1.3 页面结构\t221\n12.2 设计\t222\n12.3 CSS\t223\n12.3.1 颜色\t225\n12.3.2 布局\t226\n12.3.3 版式\t228\n12.4 标记\t229\n12.5 JavaScript\t230\n12.5.1 页面突出显示\t231\n12.5.2 JavaScript幻灯片\t235\n12.5.3 内部导航\t239\n12.5.4 JavaScript图片库\t242\n12.5.5 增强表格\t245\n12.5.6 增强表单\t249\n12.5.7 压缩代码\t263\n12.6 小结\t264\n附录 JavaScript库\t265","pages":"300","images":{"small":"http:\/\/img3.douban.com\/spic\/s4677623.jpg","large":"http:\/\/img3.douban.com\/lpic\/s4677623.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s4677623.jpg"},"alt":"http:\/\/book.douban.com\/subject\/6038371\/","id":"6038371","publisher":"人民邮电出版社","isbn10":"7115249997","isbn13":"9787115249999","title":"JavaScript DOM编程艺术 （第2版）","url":"http:\/\/api.douban.com\/v2\/book\/6038371","alt_title":"DOM Scripting: Web Design with JavaScript and the Document Object Model","author_intro":"Jeremy Keith  国际知名的Web设计师，Web标准项目组成员，DOM Scripting任务组负责人之一，任职于Web咨询公司Clearleft。除本书外，还著有HTML5 for Web Designers、Bulletproof Ajax。可通过其个人网站adactio.com与他联系。\nJeffrey Sambells 资深平面设计师，Web开发人员，创办了软件公司We-Create并担任研发总监。除本书外，还著有《JavaScript高级程序设计》和 Beginning Google Maps Applications with PHP and Ajax等多部畅销书。","summary":"JavaScript是Web开发中最重要的一门语言，它强大而优美。无论是桌面开发，还是移动应用。JavaScript都是必须掌握的技术。W3C的DOM标准是开发Web应用的基石。已经得到所有现代浏览器的支持，这使得跨平台Web开发成了一件轻松惬意的事。\n本书是超级畅销书的升级版，由倡导Web标准的领军人物执笔，揭示了前端开发的真谛，是学习JavaScript和DOM开发的必读之作。\n本 书在简洁明快地讲述JavaScript和DOM的基本知识之后，通过几个实例演示了专业水准的网页开发技术，透彻阐述了平稳退化等一批至关重要的 JavaScript编程原则和最佳实践，并全面探讨了HTML5以及jQuery等JavaScript库。读者将看到JavaScript、 HTML5和CSS如何协作来创建易用的、与标准兼容的Web设计，掌握使用JavaScript和DOM通过客户端动态效果和用户控制的动画来加强 Web页面的必备技术；同时，还将对如何利用库提高开发效率有全面深入的理解。","price":"49.00元"},{"rating":{"max":10,"numRaters":263,"average":"7.1","min":0},"subtitle":"使用Python构建网络程序的综合指南","author":["John Goerzen"],"pubdate":"2007","tags":[{"count":320,"name":"python","title":"python"},{"count":127,"name":"网络编程","title":"网络编程"},{"count":103,"name":"编程","title":"编程"},{"count":82,"name":"网络","title":"网络"},{"count":41,"name":"Python","title":"Python"},{"count":40,"name":"programming","title":"programming"},{"count":38,"name":"计算机","title":"计算机"},{"count":35,"name":"web","title":"web"}],"origin_title":"","image":"http:\/\/img5.douban.com\/mpic\/s2604186.jpg","binding":"","translator":["莫迟 等"],"catalog":"","pages":"","images":{"small":"http:\/\/img5.douban.com\/spic\/s2604186.jpg","large":"http:\/\/img5.douban.com\/lpic\/s2604186.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s2604186.jpg"},"alt":"http:\/\/book.douban.com\/subject\/2137490\/","id":"2137490","publisher":"电子工业出版社","isbn10":"7121256665","isbn13":"9787121256660","title":"Python网络编程基础","url":"http:\/\/api.douban.com\/v2\/book\/2137490","alt_title":"","author_intro":"","summary":"","price":"68.00"},{"rating":{"max":10,"numRaters":361,"average":"9.1","min":0},"subtitle":"计算机科学丛书","author":["W.Richard Stevens"],"pubdate":"2000-2-1","tags":[{"count":233,"name":"UNIX","title":"UNIX"},{"count":119,"name":"编程","title":"编程"},{"count":62,"name":"计算机","title":"计算机"},{"count":61,"name":"programming","title":"programming"},{"count":40,"name":"经典","title":"经典"},{"count":39,"name":"linux","title":"linux"},{"count":30,"name":"APUE","title":"APUE"},{"count":29,"name":"操作系统","title":"操作系统"}],"origin_title":"","image":"http:\/\/img5.douban.com\/mpic\/s23110406.jpg","binding":"平装(无盘)","translator":["尤晋元"],"catalog":"译者序\n译者简介\n前言\n第1章 UNIX基础知识\n第2章 UNIX标准化及实现\n第3章 文件I\/O\n第4章 文件和目录\n第5章 标准I\/O库\n第6章 系统数据文件和信息\n第7章 UNIX进程的环境\n第8章 进程控制\n第9章 进程关系\n第10章 信号","pages":"552","images":{"small":"http:\/\/img5.douban.com\/spic\/s23110406.jpg","large":"http:\/\/img5.douban.com\/lpic\/s23110406.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s23110406.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1092099\/","id":"1092099","publisher":"机械工业出版社","isbn10":"711107579X","isbn13":"9787111075790","title":"UNIX环境高级编程","url":"http:\/\/api.douban.com\/v2\/book\/1092099","alt_title":"","author_intro":"","summary":"本书详细说明、讨论UNIX程序设计界面的应用技术，包括：系统调用界面及标准C函数库。全书具有鲜明的特点：在同类书籍中内容最为丰富、实用；提供了大量应用实例，其中大部分可直接引入到相关程序设计中；界面应用和UNIX内部结构紧密结合。 \n　　本书全面介绍了UNIX系统的程序设计界面——系统调用界面和标准C库提供的许多函数。 本书的前15章着重于理论知识阐述，主要内容包括UNIX文件和目录、进程环境、进程控制、进程间通信以及各种I\/O。在此基础上，分别按章介绍了多个应用实例，包括如何创建数据库函数库，PostScript打印机驱动程序，调制解调器拨号器及在伪终端上运行其他程序的程序等。 本书内容丰富权威，概念清晰精辟，一直以来被誉为UNIX编程的“圣经”，对于所有UNIX程序员——无论是初学者还是专家级人士——都是一本无价的参考书籍。","price":"55.00元"},{"rating":{"max":10,"numRaters":583,"average":"7.2","min":0},"subtitle":"","author":["池建强"],"pubdate":"2014-2-1","tags":[{"count":181,"name":"mac","title":"mac"},{"count":157,"name":"计算机","title":"计算机"},{"count":102,"name":"池建强","title":"池建强"},{"count":89,"name":"Mac","title":"Mac"},{"count":82,"name":"杂文","title":"杂文"},{"count":80,"name":"互联网","title":"互联网"},{"count":62,"name":"Apple","title":"Apple"},{"count":52,"name":"科普","title":"科普"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s27219901.jpg","binding":"平装","translator":[],"catalog":"写在前面的话\n技术写作与减熵\n但行好事，莫问前程\n生命中遇见的每一本书，都不是偶然\n开篇：为何而写\nMac\nMacintosh 的命名\n1984，Mac 诞生\nMacintosh 演化史\n说说我和Mac\n品评OS X Mavericks--唯快不破\n免费的代价--从OS X 免费谈起\n选择Mac\n开始使用Mac\n非同凡想\n怀念2007\n年轻时的梦想还在吗\n苹果的语言\nMac Tips\n程序员与编程\n并发的错觉\n程序员的性格\n程序员如何提高英语阅读水平\n普通人之殇\n趣谈个人建站\n人生元编程\n如何提问\n如何学习一门编程语言\n神奇的程序员--王小波\nLinux 的文件系统王国\n科技与人文\n不要做一个Hater\n沉默的坚持和沉没的成本\n缅怀那些沉没的项目\n锤子和钉子\n读书日谈书\n付费阅读\n技术成长\n克隆高手\n老兵不死，只能自我提升\n没文化有人文\n明天的科技\n你有多少时间\n自由软件\n允许吹牛\n用好自己的份额\n也无风雨也无晴\n写作与编程\n奇特的一生\n是旅行还是长跑\n西塘古色\n《晓说》不小\n遗失的访谈--岁月无声\n怎能忘了西游\n重读黑客与画家\n人物\n传统的黑客--史蒂夫·沃兹\n从汇编到太空--保罗·艾伦\n敬畏之心\n设计巨匠--乔纳森·艾维\n工具\nVim\n神兵利器--Alfred\n终极Shell\n职场\n留不住的人才\n薪水几何\n顾得上就问，是为“顾问”也\n跟着老大去跳槽\n一生要面试多少回\n去创业还是继续编程\n去公司上班还是独自在家\n独自在家续篇兼答读者问","pages":"316","images":{"small":"http:\/\/img3.douban.com\/spic\/s27219901.jpg","large":"http:\/\/img3.douban.com\/lpic\/s27219901.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s27219901.jpg"},"alt":"http:\/\/book.douban.com\/subject\/25826578\/","id":"25826578","publisher":"人民邮电出版社","isbn10":"7115342237","isbn13":"9787115342232","title":"MacTalk 人生元编程","url":"http:\/\/api.douban.com\/v2\/book\/25826578","alt_title":"","author_intro":"池建强，70后程序员，Blogger，微信平台MacTalk作者。先后任职于洪恩软件和用友集团，从事互联网和企业应用软件研发，目前担任瑞友科技IT应用研究院技术负责人。\n热爱技术和编码工作，Apple和Google产品重度用户，分享技术，坚持梦想。","summary":"《MacTalk·人生元编程》是一本随笔文集，主要内容来自作者的微信公众平台“MacTalk By 池建强”。本书撰写于2013年，书中时间线却不止于此。作者以一个70 后程序员的笔触，立于Mac 之上，讲述技术与人文的故事，有历史，有明天，有技术，有人生。70 多篇文章划分为六大主题：Mac、程序员与编程、科技与人文、人物、工具、职场。篇篇独立成文，可拆可合，随时阅读。\n此外，作者还对原来散落在各篇文章中的Mac 技巧进行了统一的整理和规划，形成130 个Mac Tips，通过阅读这些技巧，读者既可以了解Mac，增长知识，又能够提高工作效率。\n本书行文采用了一种技术和人生感悟相结合的风格，起于Mac 却不止Mac，文风幽默又能笔底见风雷。王小波说，“每一本书都应该有趣，对于一些书来说，有趣是它存在的理由；对于另一些书，有趣是它应该达到的标准”。本书就是一本达到了有趣标准的技术书，它不仅适合Mac 用户阅读，更值得所有技术人员随时翻阅。","price":"45"},{"rating":{"max":10,"numRaters":261,"average":"7.2","min":0},"subtitle":"","author":["许式伟"],"pubdate":"2012-8","tags":[{"count":240,"name":"go语言","title":"go语言"},{"count":195,"name":"Go","title":"Go"},{"count":137,"name":"编程","title":"编程"},{"count":87,"name":"程序设计","title":"程序设计"},{"count":81,"name":"编程语言","title":"编程语言"},{"count":69,"name":"golang","title":"golang"},{"count":67,"name":"计算机","title":"计算机"},{"count":67,"name":"programming","title":"programming"}],"origin_title":"","image":"http:\/\/img5.douban.com\/mpic\/s11162016.jpg","binding":"平装","translator":[],"catalog":"序 为什么我们需要一门新的语言？\n第1章 初识Go语言\n1.1 Go语言简史\n1.2 语言特性\n1.3 “Hello, world!”\n1.4 编译环境\n1.5 开发工具\n1.6 工程管理\n1.7 问题追踪和调试\n1.8 如何寻求帮助\n本章小结\n第2章 顺序编程\n2.1 变量、常量和类型\n2.1.1 变量\n2.1.2 常量\n2.1.3 类型\n2.2 流程控制\n2.2.1 条件语句\n2.2.2 选择语句\n2.2.3 循环\n2.2.4 跳转语句\n2.3 函数\n2.3.1 函数调用\n2.3.2 不定参数\n2.3.3 多返回值\n2.3.4 匿名函数与闭包\n2.4 错误处理\n2.4.1 error接口\n2.4.2 defer\n2.4.3 panic和recover\n本章小结\n第3章 面向对象编程\n3.1 类型系统\n3.1.1 给类型添加方法\n3.1.2 值语义和引用语义\n3.2 结构体\n3.2.1 初始化\n3.2.2 匿名组合\n3.2.3 成员可访问性\n3.3 接口\n3.3.1 其他语言中的接口\n3.3.2 非侵入式接口\n3.3.3 接口赋值\n3.3.4 接口查询\n3.3.5 类型查询\n3.3.6 Any类型\n本章小结\n第4章 工程管理\n4.1 Go命令行工具\n4.2 代码风格\n4.3 工程组织\n4.4 单元测试\n4.5 文档管理\n4.6 工程构建\n4.7 包的管理与分发\n4.8 跨平台开发\n4.8.1 Go语言的跨平台能力\n4.8.2 交叉编译\n4.8.3 Android支持\n本章小结\n第5章 并发编程\n5.1 初识Goroutine\n5.1.1 基本用法\n5.1.2 Goroutine通信\n5.2 Channel\n5.2.1 基本用法\n5.2.2 关闭\n5.2.3 变量的传递\n5.2.4 单向Channel\n5.2.5 超时处理\n5.3 多核并行化\n5.4 同步机制\n5.4.1 sync包简介\n5.4.2 同步锁\n5.4.3 Once类型\n本章小结\n第6章 网络编程\n6.1 HTTP编程\n6.1.1 客户端编程\n6.1.2 开发HTTP服务器\n6.2 JSON\n6.2.1 JSON简介\n6.2.2 编码\n6.2.3 解码\n6.2.4 未知类型的解码\n6.2.5 流式读写\n6.3 网站开发\n6.3.1 一个最简单的网站\n6.3.2 开发一个相册网站\n6.3.2.1 新建工程\n6.3.2.2 实现网络服务\n6.3.2.3 网页模板渲染\n6.3.2.4 缓存\n6.3.2.5 错误处理\n6.3.2.6 防止程序崩溃\n6.3.2.7 资源分离\n6.3.2.8 重构\n6.4 更多资源\n本章小结\n第7章 进阶话题\n7.1 Go语言中的内存管理\n7.2 反射\n7.3 语言交互性CGO\n7.4 链接符号\n7.5 Goroutine实现机制\n7.6 接口的奥秘\n本章小结\n第8章 开发工具\n8.1 Go语言开发工具\n8.2 gEdit\n8.3 Goclipse - 使用Eclipse开发和调试Go程序\n8.4 VIM\n8.5 Nodepad++，Windows上的Go开发环境搭建\n8.6 GolangIDE\n本章小结\n附录 Go语言包参考","pages":"300","images":{"small":"http:\/\/img5.douban.com\/spic\/s11162016.jpg","large":"http:\/\/img5.douban.com\/lpic\/s11162016.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s11162016.jpg"},"alt":"http:\/\/book.douban.com\/subject\/11577300\/","id":"11577300","publisher":"人民邮电出版社","isbn10":"7115290369","isbn13":"9787115290366","title":"Go语言编程","url":"http:\/\/api.douban.com\/v2\/book\/11577300","alt_title":"","author_intro":"许式伟\n七牛云存储CEO，曾任盛大创新院资深研究员、金山软件技术总监、WPS Office 2005首席架构师。开源爱好者，发布过包括WINX、TPL等十余个C++开源项目，拥有超过15年的C\/C++开发经验。在接触Go语言后即可被其大道至简、少即是多的设计哲学所倾倒。七牛云存储是国内第一个吃螃蟹的团队，核心服务完全采用Go语言实现。\n吕桂华\n七牛云存储联合创始人，曾在金山软件、盛大游戏等公司担任架构师和部门经理等职务，在企业级系统和大型网游平台领域有较多涉猎。拥有十余年的C\/C++大型项目开发经验，也曾在Java和.NET平台上探索多年。同样被Go语言的魅力所吸引而不可自拔，希望能为推广这门优秀的语言尽自己的绵薄之力。","summary":"这本书从整体的写作风格来说，会以介绍 Go 语言特性为主，示例则尽量采用作者平常的实践，而不是一个没有太大实际意义的语法示范样例。\n本书作者背景极强，许式伟为原金山WPS首席架构师、曾是盛大创新院研究员，目前是国内Go语言实践圈子公认的Go语言专家。参与本书写作的几位作者都是实际用Go语言开发的项目的开发人员，有较强的实战经验。\n本书以介绍Go语言特性为主，示例则尽量采用作者开发团队平常的实践，内容涉及内存管理（堆和栈）、错误处理、OOP、并发编程等关键话题。 这本书面向的读者是所有打算用Go语言的开发者，主要包括目前使用C、C++、Java、C#的开发人员，甚至一些Python、PHP开发人员也可能转为 Go 程序员。","price":"49.00元"},{"rating":{"max":10,"numRaters":115,"average":"8.9","min":0},"subtitle":"编写高质量C语言代码","author":["Steve Maguire"],"pubdate":"2009.2","tags":[{"count":185,"name":"编程","title":"编程"},{"count":179,"name":"C","title":"C"},{"count":82,"name":"C语言","title":"C语言"},{"count":51,"name":"Programming","title":"Programming"},{"count":50,"name":"程序设计","title":"程序设计"},{"count":44,"name":"计算机","title":"计算机"},{"count":36,"name":"经典","title":"经典"},{"count":36,"name":"C\/C++","title":"C\/C++"}],"origin_title":"Writing Solid Code","image":"http:\/\/img5.douban.com\/mpic\/s3529626.jpg","binding":"","translator":[],"catalog":"1 a hypothetical compiler\n2 assert yourself\n3 fortify your subsystems\n4 step through your code\n5 candy-machine interfaces\n6 risky business\n7 treacheries of the trade\n8 the rest is attitude\nepilogue where do you go from here?\nappendix a coding checklists\nappendix b memory logging routines\nappendix c answers\nreferences\nindex","pages":"256","images":{"small":"http:\/\/img5.douban.com\/spic\/s3529626.jpg","large":"http:\/\/img5.douban.com\/lpic\/s3529626.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s3529626.jpg"},"alt":"http:\/\/book.douban.com\/subject\/3406939\/","id":"3406939","publisher":"人民邮电出版社","isbn10":"7115193169","isbn13":"9787115193162","title":"编程精粹","url":"http:\/\/api.douban.com\/v2\/book\/3406939","alt_title":"Writing Solid Code","author_intro":"","summary":"编写高质量的、没有bug的程序，是每位程序员所追求的目标。但随着软件规模越来越大，功能日趋复杂，这一目标变得越来越困难。\n本书揭示了微软公司应对质量挑战、开发出世界级代码的技术内幕，作者在自己不断探索、实践和思考的基础上，系统总结了多年来指导微软各团队的经验，将其凝聚为许多切实可行的编程实践指导，可谓字字珠玑。正因如此，本书被公认为与《代码大全》齐名的编程技术名著，曾于1993年荣获有软件开发奥斯卡奖之称的Jolt生产效率大奖。书中内容主要针对C语言，但其中的思想对目前的各主流语言编程也完全适用。","price":"45.00元"},{"rating":{"max":10,"numRaters":273,"average":"9.5","min":0},"subtitle":"","author":["W.Richard Stevens Stephen A.Rago","Stephen A. Rago"],"pubdate":"2006-2","tags":[{"count":215,"name":"unix","title":"unix"},{"count":104,"name":"编程","title":"编程"},{"count":104,"name":"programming","title":"programming"},{"count":75,"name":"linux","title":"linux"},{"count":70,"name":"Linux\/Unix","title":"Linux\/Unix"},{"count":57,"name":"计算机","title":"计算机"},{"count":43,"name":"APUE","title":"APUE"},{"count":35,"name":"经典","title":"经典"}],"origin_title":"Advanced Programming in the UNIX Environment","image":"http:\/\/img3.douban.com\/mpic\/s1726893.jpg","binding":"平装","translator":[],"catalog":"Chapter 1. UNIX System Overview 1\n1.1      Introduction    1\n1.2      UNIX Architecture    1\n1.3      Logging In    2\n1.4      Files and Directories    4\n1.5      Input and Output    8\n1.6      Programs and Processes    10\n1.7      Error Handling    14\n1.8      User Identification    16\n1.9      Signals    18\n1.10     Time Values    20\n1.11     System Calls and Library Functions    21\n1.12     Summary    23\nChapter 2. UNIX Standardization and Implementations 25\n2.1      Introduction    25\n2.2      UNIX Standardization    25\n2.2.1  ISO C   25\n2.2.2  IEEE POSIX    26\n2.2.3  The Single UNIX Specification    29\n2.2.4  FIPS   33\n2.3      UNIX System Implementations    33\n2.3.1  UNIX System V Release 4    33\n2.3.2  4.4BSD    34\n2.3.3  FreeBSD    35\n2.3.4  Linux    35\n2.3.5  Mac OS X    35\n2.3.6  Solaris    35\n2.3.7  Other UNIX Systems    36\n2.4      Relationship of Standards and Implementations    36\n2.5      Limits    36\n2.5.1  ISO C Limits   38\n2.5.2  POSlX Limits   38\n2.5.3  XSl Limits   40\n2.5.4        sysconf, pathconf, and fpathconf Functions    41\n2.5.5  Indeterminate Runtime Limits    48\n2.6      Options    52\n2.7      Feature Test Macros    55\n2.8      Primitive System Data Types    56\n2.9      Conflicts Between Standards    56\n2.10     Summary    58\nChapter 3. File I\/0 59\n3.1      Introduction    59\n3.2      File Descriptors    59\n3.3      open Function    60\n3.4      creat Function    62\n3.5      close Function    63\n3.6      1 seek Function    63\n3.7      read Function    67\n3.8      write Function    68\n3.9      I\/O Efficiency    68\n3.10     File Sharing    70\n3.11     Atomic Operations    74\n3.12     dup and dup2 Functions    76\n3.13     sync, fsync, and fdatasync Functions    77\n3.14     fcnt 1 Function    78\n3.15     ioct 1 Function    83\n3.16     \/dev\/fd    84\n3.17     Summary    85\nChapter 4. Files and Directories 87\n4.1      Introduction    87\n4.2      stat, fstat, and lstat Functions    87\n4.3      File Types    88\n4.4      Set-User-ID and Set-Group-ID    91\n4.5      File Access Permissions    92\n4.6     Ownership of New Files and Directories   95\n4.7      access Function    95\n4.8      umask Function    97\n4.9      chmod and f chmod Functions    99\n4.10           Sticky  Bit         101\n4.11     chown, fchown, and lchown Functions    102\n4.12     File Size    103\n4.13    File Truncation    105\n4.14     File Systems    105\n4.15     link, unlink, remove, and rename Functions    108\n4.16    Symbolic Links    112\n4.17     syml ink and readlink Functions    115\n4.18     File Times    115\n4.19     ut ime Function    116\n4.20     mkdir and rmdir Functions    119\n4.21     Reading Directories    120\n4.22     chdir, fchdir, and getcwd Functions    125\n4.23     Device Special Files    127\n4.24    Summary of File Access Permission Bits    130\n4.25     Summary    130\nChapter 5. Standard I\/O Library 133\n5.1      Introduction    133\n5.2      Streams and FILE Objects    133\n5.3      Standard Input, Standard Output, and Standard Error    135\n5.4      Buffering    135\n5.5      Opening a Stream    138\n5.6     Reading and Writing a Stream    140\n5.7     Line-at-a-Time I\/O    142\n5.8     Standard I\/O Efficiency    143\n5.9      Binary I\/O    145\n5.10     Positioning a Stream    147\n5.11     Formatted I\/O    149\n5.12     Implementation Details    153\n5.13     Temporary Files    155\n5.14     Alternatives to Standard I\/O    159\n5.15     Summary    159\nChapter 6. System Data Files and Information 161\n6.1      Introduction    161\n6.2      Password File    161\n6.3      Shadow Passwords    165\n6.4      Group File    166\n6.5      Supplementary Group IDs    167\n6.6      Implementation Differences    169\n6.7      Other Data Files    169\n6.8      Login Accounting    170\n6.9      System Identification    171\n6.10     Time and Date Routines    173\n6.11     Summary    177\nChapter 7. Process Environment 179\n7.1      Introduction    179\n7.2      main Function    179\n7.3      Process Termination    180\n7.4      Command-Line Arguments    185\n7.5      Environment List    185\n7.6      Memory Layout of a C Program    186\n7.7      Shared Libraries    188\n7.8      Memory Allocation    189\n7.9      Environment Variables    192\n7.10     set j mp and longj mp Functions    195\n7.11     getrlimit and setrlimit Functions    202\n7.12     Summary    206\nChapter 8. Process Control 209\n8.1      Introduction    209\n8.2      Process Identifiers    209\n8.3      fork Function    211\n8.4      vfork Function    216\n8.5      exit Functions    218\n8.6      wait and waitpid Functions    220\n8.7      waitid Function    226\n8.8      wait3 and wait4 Functions    227\n8.9      Race Conditions    227\n8.10     exec Functions    231\n8.11     Changing User IDs and Group IDs    237\n8.12     Interpreter Files    242\n8.13     system Function    246\n8.14     Process Accounting    250\n8.15     User Identification    256\n8.16     Process Times    257\n8.17     Summary   259\nChapter 9. Process Relationships 261\n9.1      Introduction    261\n9.2      Terminal Logins    261\n9.3      Network Logins    266\n9.4      Process Groups    269\n9.5      Sessions    270\n9.6      Controlling Terminal    272\n9.7      tcgetpgrp, tcsetpgrp, and tcgetsid Functions    273\n9.8      Job Control    274\n9.9      Shell Execution of Programs    278\n9.10     Orphaned Process Groups    282\n9.11     FreeBSD Implementation    285\n9.12     Summary    287\nChapter 10. Signals 289\n10.1     Introduction    289\n10.2     Signal Concepts    289\n10.3     signal Function    298\n10.4     Unreliable Signals    301\n10.5     Interrupted System Calls    303\n10.6     Reentrant Functions    305\n10.7     s IGCLD Semantics   308\n10.8     Reliable-Signal Terminology and Semantics    310\n10.9     kill and raise Functions    311\n10.10    alarm and pause Functions    313\n10.11    Signal Sets    318\n10.12    sigprocmask Function    320\n10.13    s igpending Function    322\n10.14    sigaction Function    324\n10.15    sigsetjmp and siglongjmp Functions    329\n10.16    s igsuspend Function    333\n10.17    abort Function    340\n10.18    sys t em Function    342\n10.19    s I eep Function    347\n10.20   Job-Control Signals   349\n10.21    Additional Features    352\n10.22    Summary   353\nChapter 11. Threads 355\n11.1     Introduction    355\n11.2     Thread Concepts    355\n11.3    Thread Identification   356\n11.4     Thread Creation    357\n11.5     Thread Termination    360\n11.6     Thread Synchronization    368\n11.7     Summary   385\nChapter 12. Thread Control 387\n12.1     Introduction    387\n12.2    Thread Limits   387\n12.3    Thread Attributes   388\n12.4     Synchronization Attributes    393\n12.5     Reentrancy    401\n12.6     Thread-Specific Data    406\n12.7     Cancel Options   410\n12.8     Threads and Signals   413\n12.9     Threads and fork    416\n12.10    Threads and I\/O   420\n12.11    Summary    420\nChapter 13. Daemon Processes 423\n13.1     Introduction    423\n13.2     Daemon Characteristics   423\n13.3     Coding Rules    425\n13.4     Error Logging    428\n13.5     Single-Instance Daemons    432\n13.6     Daemon Conventions   434\n13.7     Client-Server Model    439\n13.8     Summary    439\nChapter 14. Advanced I\/O 441\n14.1     Introduction    441\n14.2     Nonblocking I\/O    441\n14.3     Record Locking    444\n14.4     STREAMS    460\n14.5     I\/O Multiplexing    472\n14.5.1       select and pselect Functions    474\n14.5.2      pol 1 Function    479\n14.6    Asynchronous I\/O   481\n14.6.1       System V Asynchronous I\/O    481\n14.6.2      BSD Asynchronous I\/O    482\n14.7     readv and writev Functions    483\n14.8     readn and writen Functions    485\n14.9     Memory-Mapped I\/O    487\n14.10    Summary    492\nChapter 15. Interprocess Communication 495\n15.1     Introduction   495\n15.2     Pipes    496\n15.3     popen and pclose Functions    503\n15.4     Cop rocesses    510\n15.5     FIFOs   514\n15.6    XSI IPC    518\n15.6.1      Identifiers and Keys   518\n15.6.2      Permission Structure    520\n15.6.3      Configuration Limits    521\n15.6.4      Advantages and Disadvantages   521\n15.7    Message Queues   522\n15.8    Semaphores   527\n15.9     Shared Memory    533\n15.10    Client-Server Properties    541\n15.11    Summary    543\nChapter 16. Network IPC: Sockets 545\n16.1     Introduction    545\n16.2     Socket Descriptors   546\n16.3     Addressing    549\n16.3.1       Byte Ordering    549\n16.3.2      Address Formats    551\n16.3.3      Address Lookup   553\n16.3.4      Associating Addresses with Sockets    560\n16.4     Connection Establishment    561\n16.5     Data Transfer    565\n16.6     Socket Options    579\n16.7     Out-of-Band Data    581\n16.8     Nonblocking and Asynchronous I\/O    582\n16.9     Summary    583\nChapter 17. Advanced IPC 585\n17.1     Introduction    585\n17.2     STREAMS-Based Pipes    585\n17.2.1       Naming STREAMS Pipes    589\n17.2.2      Unique Connections    590\n17.3     UNIX Domain Sockets    594\n17.3.1       Naming UNIX Domain Sockets    595\n17.3.2      Unique Connections    597\n17.4     Passing File Descriptors    601\n17.4.1      Passing File Descriptors over STREAMS-Based Pipes   604\n17.4.2      Passing File Descriptors over UNIX Domain Sockets    606\n17.5     An Open Server, Version 1    615\n17.6     An Open Server, Version 2    620\n17.7     Summary    629\nChapter 18. Terminal I\/O 631\n18.1     Introduction    631\n18.2     Overview    631\n18.3     Special Input Characters    638\n18.4     Getting and Setting Terminal Attributes    643\n18.5     Terminal Option Flags    643\n18.6     stty Command    651\n18.7     Baud Rate Functions    652\n18.8     Line Control Functions    653\n18.9     Terminal Identification    654\n18.10    Canonical Mode    660\n18.11    Noncanonical Mode    663\n18.12    Terminal Window Size    670\n18.13     termcap, terminfo, and curses    672\n18.14    Summary    673\nChapter 19. Pseudo Terminals 675\n19.1     Introduction    675\n19.2     Overview    675\n19.3     Opening Pseudo-Terminal Devices    681\n19.3.1       STREAMS-Based Pseudo Terminals    683\n19.3.2      BSD-Based Pseudo Terminals    686\n19.3.3      Linux-Based Pseudo Terminals    689\n19.4     pty fork Function    691\n19.5    pty Program   694\n19.6     Using the pty Program    698\n19.7     Advanced Features    705\n19.8     Summary    706\nChapter 20. A Database Library 709\n20.1     Introduction    709\n20.2     History    709\n20.3     The Library    710\n20.4     Implementation Overview    712\n20.5     Centralized or Decentralized?    716\n20.6     Concurrency    718\n20.7     Building the Library    719\n20.8     Source Code    719\n20.9     Performance    747\n20.10    Summary    752\nChapter 21. Communicating with a Network Printer 753\n21.1     Introduction    753\n21.2     The Internet Printing Protocol    753\n21.3     The Hypertext Transfer Protocol    756\n21.4     Printer Spooling    757\n21.5     Source Code    758\n21.6     Summary    805\nAppendix A. Function Prototypes 807\nAppendix B. Miscellaneous Source Code 843\nB.1      Our Header File    843\nB.2      Standard Error Routines    846\nAppendix C. Solutions to Selected Exercises 853\nBibliography 885\nIndex 891","pages":"927","images":{"small":"http:\/\/img3.douban.com\/spic\/s1726893.jpg","large":"http:\/\/img3.douban.com\/lpic\/s1726893.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s1726893.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1692629\/","id":"1692629","publisher":"人民邮电出版社","isbn10":"7115144842","isbn13":"9787115144843","title":"UNIX环境高级编程","url":"http:\/\/api.douban.com\/v2\/book\/1692629","alt_title":"Advanced Programming in the UNIX Environment","author_intro":"W.Richard Stevens备受赞誉的已帮技术作家，生前著有多种经典的传世之作，包括《UNIX网络编程》（两卷本）、《TCP\/IP详解》（三卷本）和本书第1版。\nStephen A.Rago资源UNIX程序员，是当年贝尔实验室的UNIX系统V版本4的开发人员之一，著有《UNIX系统V网络编程》，并曾担任本书第1版的技术审校。他目前是ENC管理人员，专门从事文件服务器和文件系统方向的研究。","summary":"本书是被誉为UNIX编程“圣经”的Advanced Programming in the UNIX Environment一书的更新版。在本书第一版出版后的十几年中，UNIX行业已经有了巨大的变化，特别是影响UNIX编程接口的有关标准变化很大。本书在保持了前一版的风格的基础上，根据最新的标准对内容进行了修订和增补，反映了最新的技术发展。书中除了介绍UNIX文件和目录、标准I\/O库、系统数据文件和信息、进程环境、进程控制、进程关系、信号、线程、线程控制、守护进程、各种I\/O、进程间通信、网络IPC、伪终端等方面的内容，还在此基础上介绍了多个应用示例，包括如何创建数据库函数库以及如何与网络打印机通信等。此外还在附录中给出了函数原型和部分习题的答案。\n本书内容权威，概念清晰，阐述精辟，对于所有层次UNIX程序员都是一本不可或缺的参考书。","price":"99.00元"},{"rating":{"max":10,"numRaters":297,"average":"7.9","min":0},"subtitle":"","author":["Geoffrey James"],"pubdate":"2006","tags":[{"count":181,"name":"编程","title":"编程"},{"count":112,"name":"哲学","title":"哲学"},{"count":89,"name":"计算机","title":"计算机"},{"count":55,"name":"程序设计","title":"程序设计"},{"count":44,"name":"Programming","title":"Programming"},{"count":40,"name":"软件工程","title":"软件工程"},{"count":33,"name":"思维","title":"思维"},{"count":32,"name":"道","title":"道"}],"origin_title":"","image":"http:\/\/img5.douban.com\/mpic\/s1877368.jpg","binding":"平装","translator":["郭海"],"catalog":"","pages":"344","images":{"small":"http:\/\/img5.douban.com\/spic\/s1877368.jpg","large":"http:\/\/img5.douban.com\/lpic\/s1877368.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s1877368.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1899158\/","id":"1899158","publisher":"电子工业出版社","isbn10":"712102344X","isbn13":"9787121023446","title":"编程之道","url":"http:\/\/api.douban.com\/v2\/book\/1899158","alt_title":"","author_intro":"","summary":"本书出自美国一位资深的程序设计师Geoffrey James之手。他以一种幽默、辛辣的眼光审视着发生在程序设计室里的各种故事，并运用东方的哲学思想进行深层次的思考和理解。本书语言优美、比喻生动，叙述了这些看似简单但蕴含深奥道理的故事。.\r\n本书配以中英文对照，使从事软件开发人员、软件项目管理人员、软件工程研究人员，以及广大电脑爱好者在阅读这些故事的同时，还领略到本书英文原文的文采。..\r\n至今为止已重印12次的《编程之道》，自发行以来，不断受到来自各方面的青睐和好评。\r\n该书一出版，《纽约时报》和《科学家》杂志就节选了该书的内容；美国的许多全国性报刊，包括《迈阿密先驱报》和众多广播电台，像“美国公众广播电台”，均高度评价了该书 ；该书是美国Prentice Hall Book Club的特别推介读物，并被《电脑购买者》杂志评为最受欢迎的十本书之一。... \r\n\r\n\r\n序\r\n程序员的心灵鸡汤\r\n——读杰弗雷·詹姆斯的《编程之道》\r\n《编程之道》是一本另类的计算机图书，它没有教你编程技巧，也没有教你开发工具和方法，而是用富有哲理的故事和短小精悍的语言来启发我们的思考。\r\n程序的源头来自西方科学，而“道”来自东方哲学，故这本书颇有东方古典的韵味。\r\n以老庄关于“道”学说为中心的学术流派——“道家”深深地影响了中国几千年的文化思想。我猜想作者反复读过中国老子和庄子的书，东西方文化早已在他心中融会贯通。\r\n从编程之“道”我不由得想起庄子的一个脍炙人口的故事，庖丁解牛：“庖丁为文惠君解牛，手之所触，肩之所倚，足之所覆，膝之所跻，砉（音hua）然响然，奏刀劐（音huo）然，莫不中音，合於桑林之舞，乃中经首之会。文惠君曰：‘嘻，善哉！技艺至此乎？’庖丁释刀对曰：‘臣之所好者道也，近乎技矣。始臣之解牛之时，所见无非全牛者；三年之后，未曾见全牛者也；方今之时，臣以神遇而不以目视，官知止而神欲行。……提刀而立，为之四顾，为之踌躇满志，善刀而藏之’”。\r\n有人说程序是一门艺术，程序高手就是艺术大师，写程序充满了成就感；也有人说写程序应该是一种体力活，程序员应该是蓝领干的活，写程序也充满了无奈感。其实不管说法如何，写程序是一门技艺，写程序的最高境界应该是“技近乎道”。这样的绝顶高手现实存在吗？有，我记得有本Delphi书籍的作者就写过这样的一个故事，他在Borland工作，有次运行测试程序出现故障，正好Anders Hejlsberg和另外一个高手看到，Anders马上就和那个高手讨论这是哪个系统的代码有问题。在Anders眼里，整个计算机系统对他而言几乎是透明的。\r\n如何修炼自己的技艺呢？第一要掌握正确的方法和技巧，没有掌握方法，一味蛮干，再努力也是不会成功的；第二要坚持不断的磨练，这里还可以举一个脍炙人口的故事“卖油翁”作佐证，卖油翁可以滴油穿针孔而不沾的惊人技巧和神箭手的高超射术相比，高手技巧只是由于“惟手熟尔”，“无他”；第三要“悟”，如何才能“悟”，才能“技近乎道”？“汝果欲学诗,功夫在诗外”，《编程之道》给我们练的是诗外的功夫，埋头修炼的同时，也要抬头看看周围的世界，净下心来思考思考。\r\n程序员也许是天下最古怪的行业，因为几乎所有的行业都在使用信息化工具，他们要和各种各样的行业打交道，程序员是用自己的语言来描述和创造这样的工具。这也使得程序员这门职业与众不同，程序员面对的是代码和机器，却创造了一个信息化的世界。\r\n程序员比较孤独，程序员也不太容易管理，《编程之道》充分展示了程序员独特的文化，虽然书中涉及的技术比较陈旧，但这丝毫不影响其内容的价值，甚至时间越长，越证明程序员文化的独特性，不会因为计算机技术的进步而不存在。\r\n《编程之道》可以长备程序员的案头，累了困了，换换脑筋，读读其中的故事，虽然短小，但要言不繁,都是作者日积月累的甘苦之谈,实践之谈，明白之谈。\r\n你看了可以会心一笑，可以有所体悟。“开卷有益”，这也是作者最大的心愿了。\r\n《程序员》杂志及CSDN总裁蒋涛\r\n2006年7月于北京\r\n\r\n关于《编程之道》及其作者\r\n当您进入Internet，并在Yahoo或Infoseek等查找机制中输入(The Tao of Programming) (本书的英文名)后，您将会惊奇地发现，这本书的出现频率是如此之高，竟然有500多个站点贴有该书的内容！该书的流行程度，则不言而喻了。\r\n更有意思的是，这本书中的很多佳句或构思，在美国被印在了T恤衫、咖啡杯等商品上，成为这些商品促销的手段之一。可见，这本书当时在美国极为风靡，与其说它导致了一段流行时尚，不如说它形成了一个文化热点。\r\n至今为止已重印12次的《编程之道》，自发行以来，不断受到来自各方面的青睐和好评。\r\n该书一出版，《纽约时报》和《科学家》杂志就节选了该书的内容；美国的许多全国性报刊，包括《迈阿密先驱报》和众多广播电台，像“美国公众广播电台”，均高度评价了该书 ；该书是美国Prentice Hall Book Club的特别推介读物，并被《电脑购买者》杂志评为最受欢迎的十本书之一。\r\n本书的作者杰弗雷·詹姆士(Geoffrey James)毕业于美国加利福尼亚大学，1977年开始在一家大型电脑公司任软件工程师。1984年他因设计和运用了一种先进的电脑辅助排版系统而荣获美国的“卓越技术奖章”。他还为一些主要电脑供应商制定过全球营销计划。\r\n杰弗雷曾执教于加利福尼亚大学、华盛顿大学和波士顿大学，教授技术与管理的课程，并多次应邀在国际会议上发表演讲。他至今为止写了七本书，最近的一本新书《电子精英的经营智慧》在出版后的三周内便销售一空。\r\n步入中年的杰弗雷·詹姆士现在是Institute for Business Wisdom的执行董事，该学会倡导“应用文化动力学”的理念，即把最好的管理技术结合进最成功的高科技企业，并将此管理技术推广到其他行业的企业。该学会的域名：\r\nhttp:\/\/www.businesswisdom.com。您若想对作者有更多的了解，除了此站点外，您还可以访问http:\/\/www.upside.com或http:\/\/www.datamation.com来检索他最新的文章，这些文章主要论述高科技产业的发展和趋势，及其企业的管理和产品营销。\r\n有趣的是，杰弗雷对中国的文化和历史特别感兴趣，尤其是中国的太极拳。他每天早晨起来都要练太极拳，至今为止已练了20多年。据作者本人说，他当初写这本《编程之道》的时候，其灵感的产生和构思的形成，就得益于每天早晨太极拳练完后的那种玄妙的感觉。\r\n\r\n译者序\r\n如今程序设计类的图书可谓是层出不穷，其中绝大部分是以教程、使用手册和编程技巧为主，它们都是用来处理一些技术性问题的。\r\n然而，怎样领悟程序设计的内涵和精髓呢？那些程序员编程时是一种怎样的思维方式？他们的工作、生活是个什么样子 ？他们在想些什么？作为一名经理如何同他们相处并充分发挥他们的积极性 ？涉及这些方面的书却寥寥无几。但没有并不代表不重要──随着我国程序设计事业从起步到发展，这些方面的内容显得越来越重要，我们越来越希望了解它们。\r\n美国是个软件产业和程序设计水平处于领先地位的国家，我们是不是可以从那里借鉴点什么呢？这本《编程之道》便是出自美国的一位善于进行哲学性思考、有十多年工作经验的程序设计师——Geoffrey James之手。\r\n在这本书中，作者以一种幽默、辛辣的眼光审视着发生在美国的程序设计室里的各种各样的小故事，与此同时，他还运用东方的哲学思想进行深层次的思考和理解，即进行“道”式的思考和理解。简单的故事蕴含深奥的领悟，是本书的最大特色。\r\n本书不光语言优美、比喻生动，而且在结构上颇具匠心。\r\n本书在美国出版时分为三册──《编程之道》、《编程之禅》和《计算机寓言──信息时代的启示》，经与作者协商，决定将中英文对照译本汇总为一本以《编程之道》的书名出版。\r\n1.《编程之道》\r\n作者在该书中的构思新颖而奇特。作者作为一名计算机考古的业余爱好者，偶然发现了在程序设计业内传说的《编程之道》。这其中的内容，每个程序员都想知道，但谁也没有见到过。这就有点像金庸的小说《射雕英雄传》中的《九阴真经》。于是作者便将它“翻译”成此书，公之于众。全书共分为九篇：\r\n第一篇 \t静寂的空宇\r\n第二篇 \t古代的大师\r\n第三篇 \t设计\r\n第四篇 \t编码\r\n第五篇 \t维护\r\n第六篇 \t管理\r\n第七篇 \t公司里的学问\r\n第八篇 \t硬件和软件\r\n第九篇 \t尾声\r\n2.《编程之禅》\r\n在该书中，作者借用中国传统文化中的五行——“木”“火”“土”“金”“水”来代表与计算机相关的概念，并以此将多个富有禅宗色彩的故事有机地组织起来。全书共分为五篇：\r\n第一篇 \t木\r\n第二篇 \t火\r\n第三篇 \t土\r\n第四篇 \t金\r\n第五篇 \t水\r\n3.《计算机寓言集──信息时代的启示》\r\n在该书中，作者以四季——“秋”“冬”“春”“夏”来组织全书的结构。全书共分为四篇：\r\n第一篇 \t秋──虚幻与真实\r\n第二篇 \t冬──战争与死亡\r\n第三篇 \t春──真爱与新生\r\n第四篇 \t夏──启示\r\n我们将此书献给那些爱笑也爱思考的程序设计者，以及那些与程序设计者打交道的管理人员，当然他们也爱笑爱思考！\r\n译者\r\n2006年3月于北京","price":"28.00元"},{"rating":{"max":10,"numRaters":216,"average":"9.0","min":0},"subtitle":"","author":["Brian Goetz","Tim Peierls","Joshua Bloch","Joseph Bowbeer","David Holmes","Doug Lea"],"pubdate":"2012-2","tags":[{"count":380,"name":"Java","title":"Java"},{"count":302,"name":"并发","title":"并发"},{"count":233,"name":"多线程","title":"多线程"},{"count":85,"name":"编程","title":"编程"},{"count":62,"name":"java","title":"java"},{"count":43,"name":"计算机","title":"计算机"},{"count":27,"name":"线程","title":"线程"},{"count":20,"name":"Programming","title":"Programming"}],"origin_title":"Java Concurrency in Practice","image":"http:\/\/img3.douban.com\/mpic\/s7663093.jpg","binding":"平装","translator":["童云兰"],"catalog":"对本书的赞誉\n译者序\n前　言\n第1章　简介1\n1.1　并发简史1\n1.2　线程的优势2\n1.2.1　发挥多处理器的强大能力2\n1.2.2　建模的简单性3\n1.2.3　异步事件的简化处理3\n1.2.4　响应更灵敏的用户界面4\n1.3　线程带来的风险4\n1.3.1　安全性问题5\n1.3.2　活跃性问题7\n1.3.3　性能问题7\n1.4　线程无处不在7\n第一部分　基础知识\n第2章　线程安全性11\n2.1　什么是线程安全性13\n2.2　原子性14\n2.2.1　竞态条件15\n2.2.2　示例：延迟初始化中的竞态条件16\n2.2.3　复合操作17\n2.3　加锁机制18\n2.3.1　内置锁20\n2.3.2　重入21\n2.4　用锁来保护状态22\n2.5　活跃性与性能23\n第3章　对象的共享27\n3.1　可见性27\n3.1.1　失效数据28\n3.1.2　非原子的64位操作29\n3.1.3　加锁与可见性30\n3.1.4　Volatile变量 30\n3.2　发布与逸出32\n3.3　线程封闭35\n3.3.1　Ad-hoc线程封闭35\n3.3.2　栈封闭36\n3.3.3　ThreadLocal类37\n3.4　不变性38\n3.4.1　Final域39\n3.4.2　示例：使用Volatile类型来发布不可变对象40\n3.5　安全发布41\n3.5.1　不正确的发布：正确的对象被破坏42\n3.5.2 　不可变对象与初始化安全性42\n3.5.3　安全发布的常用模式43\n3.5.4　事实不可变对象44\n3.5.5　可变对象44\n3.5.6　安全地共享对象44\n第4章　对象的组合46\n4.1　设计线程安全的类46\n4.1.1　收集同步需求47\n4.1.2　依赖状态的操作48\n4.1.3　状态的所有权48\n4.2　实例封闭49\n4.2.1　Java监视器模式51\n4.2.2　示例：车辆追踪51\n4.3　线程安全性的委托53\n4.3.1　示例：基于委托的车辆追踪器54\n4.3.2　独立的状态变量55\n4.3.3　当委托失效时56\n4.3.4　发布底层的状态变量57\n4.3.5　示例：发布状态的车辆追踪器58\n4.4　在现有的线程安全类中添加功能59\n4.4.1　客户端加锁机制60\n4.4.2　组合62\n4.5　将同步策略文档化62\n第5章　基础构建模块66\n5.1　同步容器类66\n5.1.1　同步容器类的问题66\n5.1.2　迭代器与Concurrent-ModificationException68\n5.1.3　隐藏迭代器69\n5.2　并发容器70\n5.2.1　ConcurrentHashMap71\n5.2.2　额外的原子Map操作72\n5.2.3　CopyOnWriteArrayList72\n5.3　阻塞队列和生产者-消费者模式73\n5.3.1　示例：桌面搜索75\n5.3.2　串行线程封闭76\n5.3.3　双端队列与工作密取77\n5.4　阻塞方法与中断方法77\n5.5　同步工具类78\n5.5.1　闭锁79\n5.5.2　FutureTask80\n5.5.3　信号量82\n5.5.4　栅栏83\n5.6　构建高效且可伸缩的结果缓存85\n第二部分　结构化并发应用程序\n第6章　任务执行93\n6.1　在线程中执行任务93\n6.1.1　串行地执行任务94\n6.1.2　显式地为任务创建线程94\n6.1.3　无限制创建线程的不足95\n6.2　Executor框架96\n6.2.1　示例：基于Executor的Web服务器97\n6.2.2　执行策略98\n6.2.3　线程池98\n6.2.4　Executor的生命周期99\n6.2.5　延迟任务与周期任务101\n6.3　找出可利用的并行性102\n6.3.1　示例：串行的页面渲染器102\n6.3.2　携带结果的任务Callable与Future103\n6.3.3　示例：使用Future实现页面渲染器104\n6.3.4　在异构任务并行化中存在的局限106\n6.3.5　CompletionService:Executor与BlockingQueue106\n6.3.6　示例：使用CompletionService实现页面渲染器107\n6.3.7　为任务设置时限108\n6.3.8　示例：旅行预定门户网站109\n第7章　取消与关闭111\n7.1　任务取消111\n7.1.1　中断113\n7.1.2　中断策略116\n7.1.3　响应中断117\n7.1.4　示例：计时运行118\n7.1.5　通过Future来实现取消120\n7.1.6　处理不可中断的阻塞121\n7.1.7　采用newTaskFor来封装非标准的取消122\n7.2　停止基于线程的服务124\n7.2.1　示例：日志服务124\n7.2.2　关闭ExecutorService127\n7.2.3　“毒丸”对象128\n7.2.4　示例：只执行一次的服务129\n7.2.5　shutdownNow的局限性130\n7.3　处理非正常的线程终止132\n7.4　JVM关闭135\n7.4.1　关闭钩子135\n7.4.2　守护线程136\n7.4.3　终结器136\n第8章　线程池的使用138\n8.1　在任务与执行策略之间的隐性耦合138\n8.1.1　线程饥饿死锁139\n8.1.2　运行时间较长的任务140\n8.2　设置线程池的大小140\n8.3　配置ThreadPoolExecutor141\n8.3.1　线程的创建与销毁142\n8.3.2　管理队列任务142\n8.3.3　饱和策略144\n8.3.4　线程工厂146\n8.3.5　在调用构造函数后再定制ThreadPoolExecutor147\n8.4　扩展 ThreadPoolExecutor148\n8.5　递归算法的并行化149\n第9章　图形用户界面应用程序156\n9.1　为什么GUI是单线程的156\n9.1.1　串行事件处理157\n9.1.2　Swing中的线程封闭机制158\n9.2　短时间的GUI任务160\n9.3　长时间的GUI任务161\n9.3.1　取消162\n9.3.2　进度标识和完成标识163\n9.3.3　SwingWorker165\n9.4　共享数据模型165\n9.4.1　线程安全的数据模型166\n9.4.2　分解数据模型166\n9.5　其他形式的单线程子系统167\n第三部分　活跃性、性能与测试\n第10章　避免活跃性危险169\n10.1　死锁169\n10.1.1　锁顺序死锁170\n10.1.2　动态的锁顺序死锁171\n10.1.3　在协作对象之间发生的死锁174\n10.1.4　开放调用175\n10.1.5　资源死锁177\n10.2　死锁的避免与诊断178\n10.2.1　支持定时的锁178\n10.2.2　通过线程转储信息来分析死锁178\n10.3　其他活跃性危险180\n10.3.1　饥饿180\n10.3.2　糟糕的响应性181\n10.3.3　活锁181\n第11章　性能与可伸缩性183\n11.1　对性能的思考183\n11.1.1　性能与可伸缩性184\n11.1.2　评估各种性能权衡因素185\n11.2　Amdahl定律186\n11.2.1　示例：在各种框架中隐藏的串行部分188\n11.2.2　Amdahl定律的应用189\n11.3　线程引入的开销189\n11.3.1　上下文切换190\n11.3.2　内存同步190\n11.3.3　阻塞192\n11.4　减少锁的竞争192\n11.4.1　缩小锁的范围（“快进快出”）193\n11.4.2　减小锁的粒度195\n11.4.3　锁分段196\n11.4.4　避免热点域197\n11.4.5　一些替代独占锁的方法198\n11.4.6　监测CPU的利用率199\n11.4.7　向对象池说“不”200\n11.5　示例：比较Map的性能200\n11.6　减少上下文切换的开销201\n第12章　并发程序的测试204\n12.1　正确性测试205\n12.1.1　基本的单元测试206\n12.1.2　对阻塞操作的测试207\n12.1.3　安全性测试208\n12.1.4　资源管理的测试212\n12.1.5　使用回调213\n12.1.6　产生更多的交替操作214\n12.2　性能测试215\n12.2.1　在PutTakeTest中增加计时功能215\n12.2.2　多种算法的比较217\n12.2.3　响应性衡量218\n12.3　避免性能测试的陷阱220\n12.3.1　垃圾回收220\n12.3.2　动态编译220\n12.3.3　对代码路径的不真实采样222\n12.3.4　不真实的竞争程度222\n12.3.5　无用代码的消除223\n12.4　其他的测试方法224\n12.4.1　代码审查224\n12.4.2　静态分析工具224\n12.4.3　面向方面的测试技术226\n12.4.4　分析与监测工具226\n第四部分　高级主题\n第13章　显式锁227\n13.1　Lock与 ReentrantLock227\n13.1.1　轮询锁与定时锁228\n13.1.2　可中断的锁获取操作230\n13.1.3　非块结构的加锁231\n13.2　性能考虑因素231\n13.3　公平性232\n13.4　在synchronized和ReentrantLock之间进行选择234\n13.5　读-写锁235\n第14章　构建自定义的同步工具238\n14.1　状态依赖性的管理238\n14.1.1　示例：将前提条件的失败传递给调用者240\n14.1.2　示例：通过轮询与休眠来实现简单的阻塞241\n14.1.3　条件队列243\n14.2　使用条件队列244\n14.2.1　条件谓词244\n14.2.2　过早唤醒245\n14.2.3　丢失的信号246\n14.2.4　通知247\n14.2.5　示例：阀门类248\n14.2.6　子类的安全问题249\n14.2.7　封装条件队列250\n14.2.8　入口协议与出口协议250\n14.3　显式的Condition对象251\n14.4　Synchronizer剖析253\n14.5　AbstractQueuedSynchronizer254\n14.6　java.util.concurrent同步器类中的 AQS257\n14.6.1　ReentrantLock257\n14.6.2　Semaphore与CountDownLatch258\n14.6.3　FutureTask259\n14.6.4　ReentrantReadWriteLock259\n第15章　原子变量与非阻塞同步机制261\n15.1　锁的劣势261\n15.2　硬件对并发的支持262\n15.2.1　比较并交换263\n15.2.2　非阻塞的计数器264\n15.2.3　JVM对CAS的支持265\n15.3　原子变量类265\n15.3.1　原子变量是一种“更好的volatile”266\n15.3.2　性能比较：锁与原子变量267\n15.4　非阻塞算法270\n15.4.1　非阻塞的栈270\n15.4.2　非阻塞的链表272\n15.4.3　原子的域更新器274\n15.4.4　ABA问题275\n第16章　Java内存模型277\n16.1　什么是内存模型，为什么需要它277\n16.1.1　平台的内存模型278\n16.1.2　重排序278\n16.1.3　Java内存模型简介280\n16.1.4　借助同步281\n16.2　发布283\n16.2.1　不安全的发布283\n16.2.2　安全的发布284\n16.2.3　安全初始化模式284\n16.2.4　双重检查加锁286\n16.3　初始化过程中的安全性287\n附录A　并发性标注289\n参考文献291","pages":"293","images":{"small":"http:\/\/img3.douban.com\/spic\/s7663093.jpg","large":"http:\/\/img3.douban.com\/lpic\/s7663093.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s7663093.jpg"},"alt":"http:\/\/book.douban.com\/subject\/10484692\/","id":"10484692","publisher":"机械工业出版社华章公司","isbn10":"711137004X","isbn13":"9787111370048","title":"Java并发编程实战","url":"http:\/\/api.douban.com\/v2\/book\/10484692","alt_title":"Java Concurrency in Practice","author_intro":"本书作者都是Java Community Process JSR 166专家组（并发工具）的主要成员，并在其他很多JCP专家组里任职。Brian Goetz有20多年的软件咨询行业经验，并著有至少75篇关于Java开发的文章。Tim Peierls是“现代多处理器”的典范，他在BoxPop.biz、唱片艺术和戏剧表演方面也颇有研究。Joseph Bowbeer是一个Java ME专家，他对并发编程的兴趣始于Apollo计算机时代。David Holmes是《The Java Programming Language》一书的合著者，任职于Sun公司。Joshua Bloch是Google公司的首席Java架构师，《Effective Java》一书的作者，并参与著作了《Java Puzzlers》。Doug Lea是《Concurrent Programming》一书的作者，纽约州立大学 Oswego分校的计算机科学教授。","summary":"本书深入浅出地介绍了Java线程和并发，是一本完美的Java并发参考手册。书中从并发性和线程安全性的基本概念出发，介绍了如何使用类库提供的基本并发构建块，用于避免并发危险、构造线程安全的类及验证线程安全的规则，如何将小的线程安全类组合成更大的线程安全类，如何利用线程来提高并发应用程序的吞吐量，如何识别可并行执行的任务，如何提高单线程子系统的响应性，如何确保并发程序执行预期任务，如何提高并发代码的性能和可伸缩性等内容，最后介绍了一些高级主题，如显式锁、原子变量、非阻塞算法以及如何开发自定义的同步工具类。\n本书适合Java程序开发人员阅读。","price":"69.00元"},{"rating":{"max":10,"numRaters":165,"average":"9.3","min":0},"subtitle":"","author":["W.Richard Stevens","Bill Fenner","Andrew M. Rudoff"],"pubdate":"2010-6","tags":[{"count":246,"name":"UNIX","title":"UNIX"},{"count":198,"name":"网络编程","title":"网络编程"},{"count":104,"name":"网络","title":"网络"},{"count":69,"name":"编程","title":"编程"},{"count":52,"name":"linux","title":"linux"},{"count":46,"name":"计算机","title":"计算机"},{"count":42,"name":"Network","title":"Network"},{"count":35,"name":"programming","title":"programming"}],"origin_title":"Unix Network Programming, Volume 1: The Sockets Networking API (3rd Edition)","image":"http:\/\/img5.douban.com\/mpic\/s4437258.jpg","binding":"平装","translator":["杨继张"],"catalog":"第一部分 简介和tcp\/ip\n第1章 简介\t2\n1.1 概述\t2\n1.2 一个简单的时间获取客户程序\t5\n1.3 协议无关性\t9\n1.4 错误处理：包裹函数\t10\n1.5 一个简单的时间获取服务器程序\t12\n1.6 本书中客户\/服务器程序示例索引表\t14\n1.7 osi模型\t16\n1.8 bsd网络支持历史\t17\n1.9 测试用网络及主机\t19\n1.10 unix标准\t22\n1.11 64位体系结构\t24\n1.12 小结\t25\n习题\t25\n第2章 传输层：tcp、udp和sctp\t27\n2.1 概述\t27\n2.2 总图\t27\n2.3 用户数据报协议（udp）\t29\n2.4 传输控制协议（tcp）\t30\n.2.5 流控制传输协议（sctp）\t31\n2.6 tcp连接的建立和终止\t31\n2.7 time_wait状态\t37\n2.8 sctp关联的建立和终止\t38\n2.9 端口号\t42\n2.10 tcp端口号与并发服务器\t43\n2.11 缓冲区大小及限制\t45\n2.12 标准因特网服务\t50\n2.13 常见因特网应用的协议使用\t51\n2.14 小结\t52\n习题\t53\n第二部分 基本套接字编程\n第3章 套接字编程简介\t56\n3.1 概述\t56\n3.2 套接字地址结构\t56\n3.3 值—结果参数\t61\n3.4 字节排序函数\t63\n3.5 字节操纵函数\t66\n3.6 inet_aton、inet_addr和inet_ntoa函数\t67\n3.7 inet_pton和inet_ntop函数\t68\n3.8 sock_ntop和相关函数\t70\n3.9 readn、writen和readline函数\t72\n3.10 小结\t76\n习题\t76\n第4章 基本tcp套接字编程\t77\n4.1 概述\t77\n4.2 socket函数\t77\n4.3 connect函数\t80\n4.4 bind函数\t81\n4.5 listen函数\t84\n4.6 accept函数\t88\n4.7 fork和exec函数\t90\n4.8 并发服务器\t91\n4.9 close函数\t93\n4.10 getsockname和getpeername函数\t94\n4.11 小结\t96\n习题\t96\n第5章 tcp客户\/服务器程序示例\t97\n5.1 概述\t97\n5.2 tcp回射服务器程序：main函数\t97\n5.3 tcp回射服务器程序：str_echo函数\t98\n5.4 tcp回射客户程序：main函数\t99\n5.5 tcp回射客户程序：str_cli函数\t100\n5.6 正常启动\t101\n5.7 正常终止\t102\n5.8 posix信号处理\t103\n5.9 处理sigchld信号\t106\n5.10 wait和waitpid函数\t108\n5.11 accept返回前连接中止\t111\n5.12 服务器进程终止\t112\n5.13 sigpipe信号\t113\n5.14 服务器主机崩溃\t114\n5.15 服务器主机崩溃后重启\t115\n5.16 服务器主机关机\t116\n5.17 tcp程序例子小结\t116\n5.18 数据格式\t117\n5.19 小结\t120\n习题\t120\n第6章 i\/o复用：select和poll函数\t122\n6.1 概述\t122\n6.2 i\/o模型\t122\n6.3 select函数\t127\n6.4 str_cli函数（修订版）\t132\n6.5 批量输入\t133\n6.6 shutdown函数\t136\n6.7 str_cli函数（再修订版）\t137\n6.8 tcp回射服务器程序（修订版）\t138\n6.9 pselect函数\t142\n6.10 poll函数\t144\n6.11 tcp回射服务器程序（再修订版）\t146\n6.12 小结\t148\n习题\t149\n第7章 套接字选项\t150\n7.1 概述\t150\n7.2 getsockopt和setsockopt函数\t150\n7.3 检查选项是否受支持并获取默认值\t152\n7.4 套接字状态\t156\n7.5 通用套接字选项\t156\n7.6 ipv4套接字选项\t168\n7.7 icmpv6套接字选项\t169\n7.8 ipv6套接字选项\t169\n7.9 tcp套接字选项\t171\n7.10 sctp套接字选项\t173\n7.11 fcntl函数\t182\n7.12 小结\t184\n习题\t184\n第8章 基本udp套接字编程\t186\n8.1 概述\t186\n8.2 recvfrom和sendto函数\t187\n8.3 udp回射服务器程序：main函数\t187\n8.4 udp回射服务器程序：dg_echo函数\t188\n8.5 udp回射客户程序：main函数\t190\n8.6 udp回射客户程序：dg_cli函数\t190\n8.7 数据报的丢失\t191\n8.8 验证接收到的响应\t191\n8.9 服务器进程未运行\t193\n8.10 udp程序例子小结\t194\n8.11 udp的connect函数\t196\n8.12 dg_cli函数（修订版）\t199\n8.13 udp缺乏流量控制\t200\n8.14 udp中的外出接口的确定\t203\n8.15 使用select函数的tcp和udp回射服务器程序\t204\n8.16 小结\t206\n习题\t207\n第9章 基本sctp套接字编程\t208\n9.1 概述\t208\n9.2 接口模型\t208\n9.3 sctp_bindx函数\t212\n9.4 sctp_connectx函数\t213\n9.5 sctp_getpaddrs函数\t213\n9.6 sctp_freepaddrs函数\t213\n9.7 sctp_getladdrs函数\t214\n9.8 sctp_freeladdrs函数\t214\n9.9 sctp_sendmsg函数\t214\n9.10 sctp_recvmsg函数\t215\n9.11 sctp_opt_info函数\t215\n9.12 sctp_peeloff函数\t216\n9.13 shutdown函数\t216\n9.14 通知\t217\n9.15 小结\t221\n习题\t222\n第10章 sctp客户\/服务器程序例子\t223\n10.1 概述\t223\n10.2 sctp一到多式流分回射服务器程序：main函数\t223\n10.3 sctp一到多式流分回射客户程序：main函数\t225\n10.4 sctp流分回射客户程序：sctpstr_cli函数\t226\n10.5 探究头端阻塞\t228\n10.6 控制流的数目\t233\n10.7 控制终结\t233\n10.8 小结\t234\n习题\t235\n第11章 名字与地址转换\t236\n11.1 概述\t236\n11.2 域名系统\t236\n11.3 gethostbyname函数\t239\n11.4 gethostbyaddr函数\t242\n11.5 getservbyname和getservbyport函数\t242\n11.6 getaddrinfo函数\t245\n11.7 gai_strerror函数\t250\n11.8 freeaddrinfo函数\t251\n11.9 getaddrinfo函数：ipv6\t251\n11.10 getaddrinfo函数：例子\t253\n11.11 host_serv函数\t254\n11.12 tcp_connect函数\t254\n11.13 tcp_listen函数\t257\n11.14 udp_client函数\t261\n11.15 udp_connect函数\t263\n11.16 udp_server函数\t264\n11.17 getnameinfo函数\t266\n11.18 可重入函数\t267\n11.19 gethostbyname_r和gethostbyaddr_r函数\t270\n11.20 作废的ipv6地址解析函数\t271\n11.21 其他网络相关信息\t272\n11.22 小结\t273\n习题\t274\n第三部分 高级套接字编程\n第12章 ipv4与ipv6的互操作性\t278\n12.1 概述\t278\n12.2 ipv4客户与ipv6服务器\t278\n12.3 ipv6客户与ipv4服务器\t281\n12.4 ipv6地址测试宏\t283\n12.5 源代码可移植性\t284\n12.6 小结\t284\n习题\t285\n第13章 守护进程和inetd超级服务器\t286\n13.1 概述\t286\n13.2 syslogd守护进程\t286\n13.3 syslog函数\t287\n13.4 daemon_init函数\t289\n13.5 inetd守护进程\t293\n13.6 daemon_inetd函数\t297\n13.7 小结\t299\n习题\t299\n第14章 高级i\/o函数\t300\n14.1 概述\t300\n14.2 套接字超时\t300\n14.3 recv和send函数\t305\n14.4 readv和writev函数\t306\n14.5 recvmsg和sendmsg函数\t307\n14.6 辅助数据\t310\n14.7 排队的数据量\t313\n14.8 套接字和标准i\/o\t313\n14.9 高级轮询技术\t316\n14.10 t\/tcp：事务目的tcp\t320\n14.11 小结\t322\n习题\t323\n第15章 unix域协议\t324\n15.1 概述\t324\n15.2 unix域套接字地址结构\t324\n15.3 socketpair函数\t326\n15.4 套接字函数\t327\n15.5 unix域字节流客户\/服务器程序\t327\n15.6 unix域数据报客户\/服务器程序\t329\n15.7 描述符传递\t330\n15.8 接收发送者的凭证\t337\n15.9 小结\t340\n习题\t340\n第16章 非阻塞式i\/o\t341\n16.1 概述\t341\n16.2 非阻塞读和写：str_cli函数（修订版）\t342\n16.3 非阻塞connect\t351\n16.4 非阻塞connect：时间获取客户程序\t352\n16.5 非阻塞connect：web客户程序\t354\n16.6 非阻塞accept\t362\n16.7 小结\t363\n习题\t363\n第17章 ioctl操作\t365\n17.1 概述\t365\n17.2 ioctl函数\t365\n17.3 套接字操作\t366\n17.4 文件操作\t367\n17.5 接口配置\t367\n17.6 get_ifi_info函数\t369\n17.7 接口操作\t378\n17.8 arp高速缓存操作\t378\n17.9 路由表操作\t380\n17.10 小结\t381\n习题\t381\n第18章 路由套接字\t382\n18.1 概述\t382\n18.2 数据链路套接字地址结构\t382\n18.3 读和写\t383\n18.4 sysctl操作\t390\n18.5 get_ifi_info函数\t394\n18.6 接口名字和索引函数\t397\n18.7 小结\t401\n习题\t401\n第19章 密钥管理套接字\t402\n19.1 概述\t402\n19.2 读和写\t403\n19.3 倾泻安全关联数据库\t404\n19.4 创建静态安全关联\t407\n19.5 动态维护安全关联\t412\n19.6 小结\t415\n习题\t416\n第20章 广播\t417\n20.1 概述\t417\n20.2 广播地址\t418\n20.3 单播和广播的比较\t419\n20.4 使用广播的dg_cli函数\t422\n20.5 竞争状态\t424\n20.6 小结\t431\n习题\t432\n第21章 多播\t433\n21.1 概述\t433\n21.2 多播地址\t433\n21.3 局域网上多播和广播的比较\t436\n21.4 广域网上的多播\t438\n21.5 源特定多播\t440\n21.6 多播套接字选项\t441\n21.7 mcast_join和相关函数\t445\n21.8 使用多播的dg_cli函数\t450\n21.9 接收ip多播基础设施会话声明\t451\n21.10 发送和接收\t454\n21.11 sntp：简单网络时间协议\t457\n21.12 小结\t461\n习题\t461\n第22章 高级udp套接字编程\t462\n22.1 概述\t462\n22.2 接收标志、目的ip地址和接口索引\t462\n22.3 数据报截断\t467\n22.4 何时用udp代替tcp\t467\n22.5 给udp应用增加可靠性\t469\n22.6 捆绑接口地址\t478\n22.7 并发udp服务器\t482\n22.8 ipv6分组信息\t483\n22.9 ipv6路径mtu控制\t486\n22.10 小结\t487\n习题\t488\n第23章 高级sctp套接字编程\t489\n23.1 概述\t489\n23.2 自动关闭的一到多式服务器程序\t489\n23.3 部分递送\t490\n23.4 通知\t492\n23.5 无序的数据\t495\n23.6 捆绑地址子集\t496\n23.7 确定对端和本端地址信息\t497\n23.8 给定ip地址找出关联id\t500\n23.9 心搏和地址不可达\t501\n23.10 关联剥离\t502\n23.11 定时控制\t503\n23.12 何时改用sctp代替tcp\t505\n23.13 小结\t506\n习题\t506\n第24章 带外数据\t507\n24.1 概述\t507\n24.2 tcp带外数据\t507\n24.3 sockatmark函数\t513\n24.4 tcp带外数据小结\t519\n24.5 客户\/服务器心搏函数\t520\n24.6 小结\t524\n习题\t524\n第25章 信号驱动式i\/o\t525\n25.1 概述\t525\n25.2 套接字的信号驱动式i\/o\t525\n25.3 使用sigio的udp回射服务器程序\t527\n25.4 小结\t532\n习题\t533\n第26章 线程\t534\n26.1 概述\t534\n26.2 基本线程函数：创建和终止\t535\n26.3 使用线程的str_cli函数\t537\n26.4 使用线程的tcp回射服务器程序\t538\n26.5 线程特定数据\t542\n26.6 web客户与同时连接\t549\n26.7 互斥锁\t552\n26.8 条件变量\t555\n26.9 web客户与同时连接（续）\t558\n26.10 小结\t560\n习题\t560\n第27章 ip选项\t561\n27.1 概述\t561\n27.2 ipv4选项\t561\n27.3 ipv4源路径选项\t562\n27.4 ipv6扩展首部\t569\n27.5 ipv6步跳选项和目的地选项\t569\n27.6 ipv6路由首部\t573\n27.7 ipv6粘附选项\t577\n27.8 历史性ipv6高级api\t578\n27.9 小结\t579\n习题\t579\n第28章 原始套接字\t580\n28.1 概述\t580\n28.2 原始套接字创建\t580\n28.3 原始套接字输出\t581\n28.4 原始套接字输入\t582\n28.5 ping程序\t584\n28.6 traceroute程序\t596\n28.7 一个icmp消息守护程序\t608\n28.8 小结\t622\n习题\t622\n第29章 数据链路访问\t623\n29.1 概述\t623\n29.2 bpf：bsd分组过滤器\t623\n29.3 dlpi：数据链路提供者接口\t625\n29.4 linux：sock_packet和\npf_packet\t626\n29.5 libpcap：分组捕获函数库\t627\n29.6 libnet：分组构造与输出函数库\t627\n29.7 检查udp的校验和字段\t628\n29.8 小结\t645\n习题\t645\n第30章 客户\/服务器程序设计范式\t646\n30.1 概述\t646\n30.2 tcp客户程序设计范式\t648\n30.3 tcp测试用客户程序\t649\n30.4 tcp迭代服务器程序\t650\n30.5 tcp并发服务器程序，每个客户一个子进程\t650\n30.6 tcp预先派生子进程服务器程序，accept无上锁保护\t653\n30.7 tcp预先派生子进程服务器程序，accept使用文件上锁保护\t659\n30.8 tcp预先派生子进程服务器程序，accept使用线程上锁保护\t662\n30.9 tcp预先派生子进程服务器程序，传递描述符\t663\n30.10 tcp并发服务器程序，每个客户一个线程\t667\n30.11 tcp预先创建线程服务器程序，每个线程各自accept\t669\n30.12 tcp预先创建线程服务器程序，主线程统一accept\t671\n30.13 小结\t673\n习题\t674\n第31章 流\t675\n31.1 概述\t675\n31.2 概貌\t675\n31.3 getmsg和putmsg函数\t678\n31.4 getpmsg和putpmsg函数\t679\n31.5 ioctl函数\t680\n31.6 tpi：传输提供者接口\t680\n31.7 小结\t689\n习题\t689\n附录a ipv4、ipv6、icmpv4和\nicmpv6\t690\n附录b 虚拟网络\t704\n附录c 调试技术\t708\n附录d 杂凑的源代码\t714\n附录e 精选习题答案\t726\n参考文献\t756\n索引\t763","pages":"804","images":{"small":"http:\/\/img5.douban.com\/spic\/s4437258.jpg","large":"http:\/\/img5.douban.com\/lpic\/s4437258.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s4437258.jpg"},"alt":"http:\/\/book.douban.com\/subject\/4859464\/","id":"4859464","publisher":"人民邮电出版社","isbn10":"711522840X","isbn13":"9787115228406","title":"UNIX网络编程 卷1：套接字联网API（第3版）","url":"http:\/\/api.douban.com\/v2\/book\/4859464","alt_title":"Unix Network Programming, Volume 1: The Sockets Networking API (3rd Edition)","author_intro":"W. Richard Stevens（1951—1999） 国际知名的UNIX和网络专家，备受赞誉的技术作家。生前著有《TCP\/IP详解》（三卷）、《UNIX环境高级编程》和《UNIX网络编程》（两卷），均为不朽的经典著作。\nBill Fenner  AT&T实验室的主要技术人员，专攻IP多播、网络管理和测量，他是IETF路由的领域主管之一，负责审批作为RFC出版的所有路由相关文档。\nAndrew M. Rudoff  Sun公司的资深软件工程师，专攻网络、操作系统内核、文件系统和高可用性软件体系结构。","summary":"这是一部传世之作！顶级网络编程专家Bill Fenner和Andrew M. Rudoff应邀执笔，对W. Richard Stevens的经典作品进行修订。书中吸纳了近几年网络技术的发展，增添了IPv6、SCTP协议和密钥管理套接字等内容，深入讨论了最新的关键标准、实现和技术。\n书中的所有示例都是在UNIX系统上测试通过的真实的、可运行的代码，继承了Stevens一直强调的理念：“学习网络编程的最好方法就是下载这些程序，对其进行修改和改进。只有这样实际编写代码才能深入理解有关概念和方法。”读者可以从图灵网站（www.turingbook.com）本书网页免费注册下载这些示例的源代码。\n本书为UNIX网络编程提供全面的指导，是网络研究和开发人员公认的权威参考书，无论网络编程的初学者还是网络专家都会大受裨益。","price":"129.00元"},{"rating":{"max":10,"numRaters":140,"average":"7.9","min":0},"subtitle":"","author":["Peter Seibel"],"pubdate":"2011-10","tags":[{"count":292,"name":"Lisp","title":"Lisp"},{"count":133,"name":"函数式编程","title":"函数式编程"},{"count":90,"name":"编程","title":"编程"},{"count":58,"name":"计算机","title":"计算机"},{"count":51,"name":"编程语言","title":"编程语言"},{"count":44,"name":"Programming","title":"Programming"},{"count":42,"name":"程序设计","title":"程序设计"},{"count":39,"name":"lisp","title":"lisp"}],"origin_title":"Practical Common Lisp","image":"http:\/\/img3.douban.com\/mpic\/s8479473.jpg","binding":"平装","translator":["田春"],"catalog":"第1 章 绪言：为什么是Lisp　　1\n1.1 为什么是Lisp　　2\n1.2 Lisp 的诞生　　4\n1.3 本书面向的读者　　6\n第2 章 周而复始：REPL 简介　　8\n2.1 选择一个Lisp 实现　　8\n2.2 安装和运行Lisp in a Box　　 10\n2.3 放开思想：交互式编程　　 10\n2.4 体验REPL　　11\n2.5 Lisp 风格的“Hello, World” 　 　12\n2.6 保存工作成果　　13\n第3 章 实践：简单的数据库　　17\n3.1 CD 和记录　　17\n3.2 录入CD　　18\n3.3 查看数据库的内容　　19\n3.4 改进用户交互　　21\n3.5 保存和加载数据库　　 23\n3.6 查询数据库　　24\n3.7 更新已有的记录——WHERE 再战江湖　　28\n3.8 消除重复，获益良多　　 29\n3.9 总结　　33\n第4 章 语法和语义　　34\n4.1 括号里都可以有什么　　34\n4.2 打开黑箱　　34\n4.3 S-表达式　　36\n4.4 作为Lisp 形式的S-表达式　　 38\n4.5 函数调用　　39\n4.6 特殊操作符　　39\n4.7 宏　　41\n4.8 真、假和等价　　42\n4.9 格式化Lisp 代码　　 43\n第5 章 函数　　46\n5.1 定义新函数　　 46\n5.2 函数形参列表　　 47\n5.3 可选形参　　48\n5.4 剩余形参　　49\n5.5 关键字形参　　 50\n5.6 混合不同的形参类型　　51\n5.7 函数返回值　　52\n5.8 作为数据的函数——高阶函数　　 53\n5.9 匿名函数　　 55\n第6 章 变量　　 57\n6.1 变量的基础知识　　 57\n6.2 词法变量和闭包　　60\n6.3 动态变量　　 61\n6.4 常量　　65\n6.5 赋值　　65\n6.6 广义赋值　　66\n6.7 其他修改位置的方式　　67\n第7 章 宏：标准控制构造　　69\n7.1 WHEN 和UNLESS　　 70\n7.2 COND　　 71\n7.3 AND、OR 和NOT 　　 72\n7.4 循环　　 72\n7.5 DOLIST 和DOTIMES 　　 73\n7.6 DO 　　 74\n7.7 强大的LOOP 　　76\n第8 章 如何自定义宏　　　78\n8.1 Mac 的故事：只是一个故事　　78\n8.2 宏展开期和运行期　　79\n8.3 DEFMACRO 　　80\n8.4 示例宏：do-primes 　　81\n8.5 宏形参　　　82\n8.6 生成展开式　　83\n8.7 堵住漏洞　　84\n8.8 用于编写宏的宏　　88\n8.9 超越简单宏　　90\n第9 章 实践：建立单元测试框架　　91\n9.1 两个最初的尝试　　91\n9.2 重构　　92\n9.3 修复返回值　　94\n9.4 更好的结果输出　　95\n9.5 抽象诞生　　97\n9.6 测试层次体系　　97\n9.7 总结　　99\n第10 章 数字、字符和字符串　　101\n10.1 数字　　101\n10.2 字面数值　　102\n10.3 初等数学　　104\n10.4 数值比较　　106\n10.5 高等数学　　107\n10.6 字符　　107\n10.7 字符比较　　107\n10.8 字符串　　108\n10.9 字符串比较　　109\n第11 章 集合　　111\n11.1 向量　　111\n11.2 向量的子类型　　113\n11.3 作为序列的向量　　114\n11.4 序列迭代函数　　114\n11.5 高阶函数变体　　116\n11.6 整个序列上的操作　　117\n11.7 排序与合并　　118\n11.8 子序列操作　　118\n11.9 序列谓词　　119\n11.10 序列映射函数　　120\n11.11 哈希表　　120\n11.12 哈希表迭代　　122\n第12 章 LISP 名字的由来：列表处理　　123\n12.1 “没有列表”　　123\n12.2 函数式编程和列表　　126\n12.3 “破坏性”操作　　127\n12.4 组合回收性函数和共享结构　　129\n12.5 列表处理函数　　131\n12.6 映射　　132\n12.7 其他结构　　133\n第13 章 超越列表：点对单元的其他用法　　134\n13.1 树　　134\n13.2 集合　　136\n13.3 查询表：alist 和plist　　137\n13.4 DESTRUCTURING-BIND 　　141\n第14 章 文件和文件I\/O 　　143\n14.1 读取文件数据　　143\n14.2 读取二进制数据　　145\n14.3 批量读取　　145\n14.4 文件输出　　145\n14.5 关闭文件　　146\n14.6 文件名　　147\n14.7 路径名如何表示文件名　　149\n14.8 构造新路径名　　150\n14.9 目录名的两种表示方法　　152\n14.10 与文件系统交互　　153\n14.11 其他I\/O 类型　　154\n第15 章 实践：可移植路径名库　　157\n15.1 API　　157\n15.2 *FEATURES*和读取期条件化　　157\n15.3 列目录　　159\n15.4 测试文件的存在　　162\n15.5 遍历目录树　　164\n第16 章 重新审视面向对象：广义函数　　165\n16.1 广义函数和类　　166\n16.2 广义函数和方法　　167\n16.3 DEFGENERIC　　168\n16.4 DEFMETHOD 　　169\n16.5 方法组合　　171\n16.6 标准方法组合　　172\n16.7 其他方法组合　　173\n16.8 多重方法　　174\n16.9 未完待续　　176\n第17 章 重新审视面向对象：类　　177\n17.1 DEFCLASS　　177\n17.2 槽描述符　　178\n17.3 对象初始化　　179\n17.4 访问函数　　182\n17.5 WITH-SLOTS 和WITHACCESSORS　　185\n17.6 分配在类上的槽　　186\n17.7 槽和继承　　187\n17.8 多重继承　　188\n17.9 好的面向对象设计　　190\n第18 章 一些FORMAT 秘诀　　191\n18.1 FORMAT 函数　　192\n18.2 FORMAT 指令　　193\n18.3 基本格式化　　194\n18.4 字符和整数指令　　194\n18.5 浮点指令　　196\n18.6 英语指令　　197\n18.7 条件格式化　　198\n18.8 迭代　　199\n18.9 跳，跳，跳　　201\n18.10 还有更多　　202\n第19 章 超越异常处理：状况和再启动　　203\n19.1 Lisp 的处理方式　　204\n19.2 状况　　205\n19.3 状况处理器　　205\n19.4 再启动　　207\n19.5 提供多个再启动　　210\n19.6 状况的其他用法　　211\n第20 章 特殊操作符　　213\n20.1 控制求值　　213\n20.2 维护词法环境　　 213\n20.3 局部控制流　　 216\n20.4 从栈上回退　　219\n20.5 多值　　 223\n20.6 EVAL-WHEN　　224\n20.7 其他特殊操作符　　 227\n第21 章 编写大型程序：包和符号　　 228\n21.1 读取器是如何使用包的　　228\n21.2 包和符号相关的术语　　 230\n21.3 三个标准包　　230\n21.4 定义你自己的包　　232\n21.5 打包可重用的库　　234\n21.6 导入单独的名字　　235\n21.7 打包技巧　　 236\n21.8 包的各种疑难杂症　　 237\n第22 章 高阶LOOP　　240\n22.1 LOOP 的组成部分　　 240\n22.2 迭代控制　　241\n22.3 计数型循环　　241\n22.4 循环集合和包　　242\n22.5 等价?然后迭代　　243\n22.6 局部变量　　244\n22.7 解构变量　　 245\n22.8 值汇聚　　245\n22.9 无条件执行　　247\n22.10 条件执行　　247\n22.11 设置和拆除　　248\n22.12 终止测试　　250\n22.13 小结　　251\n第23 章 实践：垃圾邮件过滤器　　 252\n23.1 垃圾邮件过滤器的核心　　252\n23.2 训练过滤器　　255\n23.3 按单词来统计　　257\n23.4 合并概率　　259\n23.5 反向卡方分布函数　　261\n23.6 训练过滤器　　262\n23.7 测试过滤器　　263\n23.8 一组工具函数　　265\n23.9 分析结果　　266\n23.10 接下来的工作　　268\n第24 章 实践：解析二进制文件　　269\n24.1 二进制文件　　　269\n24.2 二进制格式基础　　270\n24.3 二进制文件中的字符串　　271\n24.4 复合结构　　273\n24.5 设计宏　　274\n24.6 把梦想变成现实　　275\n24.7 读取二进制对象　　277\n24.8 写二进制对象　　279\n24.9 添加继承和标记的结构　　280\n24.10 跟踪继承的槽　　281\n24.11 带有标记的结构　　284\n24.12 基本二进制类型　　285\n24.13 当前对象栈　　288\n第25 章 实践：ID3 解析器　　290\n25.1 ID3v2 标签的结构　　291\n25.2 定义包　　292\n25.3 整数类型　　292\n25.4 字符串类型　　294\n25.5 ID3 标签头　　297\n25.6 ID3 帧　　298\n25.7 检测标签补白　　300\n25.8 支持ID3 的多个版本　　301\n25.9 版本化的帧基础类　　303\n25.10 版本化的具体帧类　　304\n25.11 你实际需要哪些帧　　305\n25.12 文本信息帧　　307\n25.13 评论帧　　　　309\n25.14 从ID3 标签中解出信息　　310\n第26 章 实践：用AllegroServe 进行Web 编程　　315\n26.1 30 秒介绍服务器端Web 编程　　315\n26.2 AllegroServe 　　317\n26.3 用AllegroServe 生成动态内容　　320\n26.4 生成HTML 　　321\n26.5 HTML 宏　　324\n26.6 查询参数　　325\n26.7 cookie 　　327\n26.8 小型应用框架　　329\n26.9 上述框架的实现　　330\n第27 章 实践：MP3 数据库　　334\n27.1 数据库　　334\n27.2 定义模式　　336\n27.3 插入值　　338\n27.4 查询数据库　　340\n27.5 匹配函数　　342\n27.6 获取结果　　344\n27.7 其他数据库操作　　346\n第28 章 实践：Shoutcast 服务器　　348\n28.1 Shoutcast 协议　　348\n28.2 歌曲源　　349\n28.3 实现Shoutcast 　　351\n第29 章 实践：MP3 浏览器　　357\n29.1 播放列表　　357\n29.2 作为歌曲源的播放列表　　359\n29.3 操作播放列表　　362\n29.4 查询参数类型　　365\n29.5 样板HTML 　　367\n29.6 浏览页　　368\n29.7 播放列表　　371\n29.8 查找播放列表　　373\n29.9 运行应用程序　　374\n第30 章 实践：HTML 生成库，解释器部分　　375\n30.1 设计一个领域相关语言　　375\n30.2 FOO 语言　　376\n30.3 字符转义　　379\n30.4 缩进打印器　　380\n30.5 HTML 处理器接口　　381\n30.6 美化打印器后台　　382\n30.7 基本求值规则　　385\n30.8 下一步是什么　　389\n第31 章 实践：HTML 生成库，编译器部分　　390\n31.1 编译器　　390\n31.2 FOO 特殊操作符　　395\n31.3 FOO 宏　　399\n31.4 公共API　　401\n31.5 结束语　　 403\n第32 章 结论：下一步是什么　　404\n32.1 查找Lisp 库　　404\n32.2 与其他语言接口　　406\n32.3 让它工作，让它正确，让它更快　　 406\n32.4 交付应用程序　　 413\n32.5 何去何从　　 415","pages":"417","images":{"small":"http:\/\/img3.douban.com\/spic\/s8479473.jpg","large":"http:\/\/img3.douban.com\/lpic\/s8479473.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s8479473.jpg"},"alt":"http:\/\/book.douban.com\/subject\/6859720\/","id":"6859720","publisher":"人民邮电","isbn10":"7115263744","isbn13":"9787115263742","title":"实用Common Lisp编程","url":"http:\/\/api.douban.com\/v2\/book\/6859720","alt_title":"Practical Common Lisp","author_intro":"Peter Seibel  从作家演变成程序员，又从程序员演变成作家，其职业生涯可谓一波三折。他在获得英语专业学士学位后做过一段时间的记者工作，后来被Web所吸引。在20世 纪90年代早期，他用Perl建立了Mother Jones杂志和Organic Online网站。他作为WebLogic的早期雇员参与了Java革命，随后又在加州大学伯克利分校教授Java编程。他也是第二代Lisp程序员之 一，并曾经是Symbolics的早期股东。2003年他辞去技术工作，潜心研究Lisp，并凭借本书获得Jolt生产效率大奖。2009年出版了名噪一 时的访谈录《编程人生》（Coders at Work）。","summary":"由塞贝尔编著的《实用Common Lisp编程》是一本不同寻常的Common Lisp入门书。《实用Common Lisp编程》首先从作者的学习经过及语言历史出发，随后用21个章节讲述了各种基础知识，主要包括：REPL及Common Lisp的各种实现、S-表达式、函数与变量、标准宏与自定义宏、数字与字符以及字符串、集合与向量、列表处理、文件与文件I\/O处理、类、FORMAT格式、符号与包，等等。而接下来的9个章节则翔实地介绍了几个有代表性的实例，其中包含如何构建垃圾过滤器、解析二进制文件、构建ID3解析器，以及如何编写一个完整的MP3 Web应用程序等内容。最后还对一些未介绍内容加以延伸。\n    《实用Common Lisp编程》内容适合Common Lisp初学者及对之感兴趣的相关人士。","price":"89.00元"},{"rating":{"max":10,"numRaters":295,"average":"8.0","min":0},"subtitle":"","author":["Jasmin Blanchette","Mark Summerfield"],"pubdate":"2008-8","tags":[{"count":250,"name":"QT","title":"QT"},{"count":186,"name":"C++","title":"C++"},{"count":136,"name":"GUI","title":"GUI"},{"count":70,"name":"编程","title":"编程"},{"count":49,"name":"计算机","title":"计算机"},{"count":37,"name":"界面","title":"界面"},{"count":36,"name":"Qt4","title":"Qt4"},{"count":31,"name":"C\/C++","title":"C\/C++"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s5934624.jpg","binding":"","translator":["闫锋欣"],"catalog":"第一部 分Ql基础============================================\n第1章 Qt入门\n1.1 Hello Qt\n第2章 创建对话框\n2.1 子类化QI)ialog\n2.2 深入介绍信号和槽\n第3章 创建主窗口\n第4章 实现应用程序的功能\n4.1 中央窗口部件\n第5章 创建自定义窗口部件\n第二部分 Ot中级============================================\n第6章 布局管理\n第7章 事件处理\n第8章 二维图形\n第9章 拖放\n第10章 项视图类\n第11章 容器类\n第12章 输入与输出\n12.1 读取和写入二进制数据\n第13章 数据库\n第14章 多线程\n第15章 网络\n15.1写FTP客户端\n第16章 XML\n16.1 使用QXmlStreamReader读取XML\n第17章 提供在线帮助\n第三部分 Qt高级============================================\n第18章 国际化\n第19章 自定义外观\n第20章 三维图形\n第21章 创建插件\n第22章 应用程序脚本\n第23章 平台相关特性\n第24章 嵌入式编程\n24.1 从Ot／Embedded Linux开始\n第四部分 附录\n附录A Qt的获取和安装\n附录B 编译Qt应用程序\n附录C Qt Jambi简介\n附录D 面向Java和C#程序员的C++简介\nD.1 C++入门\nD.2 主要语言之间的差异\nD.3 c++标准库","pages":"492","images":{"small":"http:\/\/img3.douban.com\/spic\/s5934624.jpg","large":"http:\/\/img3.douban.com\/lpic\/s5934624.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s5934624.jpg"},"alt":"http:\/\/book.douban.com\/subject\/3173123\/","id":"3173123","publisher":"电子工业出版社","isbn10":"7121070383","isbn13":"9787121070389","title":"C++GUI Qt4编程","url":"http:\/\/api.douban.com\/v2\/book\/3173123","alt_title":"","author_intro":"","summary":"《C++GUIQt4编程》(第2版)详细讲述了用最新的Qt版本进行图形用户界面应用程序开发的各个方面。前5章主要涉及Qt基础知识，后两个部分主要讲解Qt的中高级编程，包括布局管理、事件处理、二维／三维图形、拖放、项视图类、容器类、输入／输出、数据库、多线程、网络、XML、国际化、嵌入式编程等内容。对于《C++GUIQt4编程》(第2版)讲授的大量Qt4编程原理和实践，都可以轻易将其应用于Qt4．4、Qt4．5以及后续版本的Qt程序开发过程中。","price":"65.00元"},{"rating":{"max":10,"numRaters":213,"average":"8.7","min":0},"subtitle":"","author":["Brian W.Kernighan","Rob Pike"],"pubdate":"1999-10","tags":[{"count":214,"name":"UNIX","title":"UNIX"},{"count":104,"name":"编程","title":"编程"},{"count":62,"name":"programming","title":"programming"},{"count":46,"name":"Linux","title":"Linux"},{"count":39,"name":"计算机","title":"计算机"},{"count":33,"name":"程序设计","title":"程序设计"},{"count":32,"name":"Linux\/Unix","title":"Linux\/Unix"},{"count":29,"name":"经典","title":"经典"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s1075305.jpg","binding":"平装(无盘)","translator":["陈向群\/等"],"catalog":"译者序\n序言\n第1章  初学UNIX\n第2章  文件系统\n第3章  shell的使用\n第4章  过滤程序\n第5章  shell编程\n第6章  使用标准I\/O编程\n第7章  UNIX系统调用\n第8章  程序开发\n第9章  文档处理\n第10章  结束语\n附录A  编辑器概述\n附录B  hoc手册\n附录C  hoc清单","pages":"255","images":{"small":"http:\/\/img3.douban.com\/spic\/s1075305.jpg","large":"http:\/\/img3.douban.com\/lpic\/s1075305.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s1075305.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1033144\/","id":"1033144","publisher":"机械工业出版社","isbn10":"7111071158","isbn13":"9787111071150","title":"UNIX编程环境","url":"http:\/\/api.douban.com\/v2\/book\/1033144","alt_title":"","author_intro":"","summary":"\n      ","price":"24.00"},{"rating":{"max":10,"numRaters":179,"average":"8.9","min":0},"subtitle":"","author":["Eric S. Raymond"],"pubdate":"2011-1","tags":[{"count":266,"name":"UNIX","title":"UNIX"},{"count":154,"name":"编程","title":"编程"},{"count":104,"name":"哲学","title":"哲学"},{"count":85,"name":"程序设计","title":"程序设计"},{"count":73,"name":"计算机","title":"计算机"},{"count":61,"name":"经典","title":"经典"},{"count":53,"name":"计算机科学","title":"计算机科学"},{"count":48,"name":"文化","title":"文化"}],"origin_title":"The Art of UNIX Programming","image":"http:\/\/img3.douban.com\/mpic\/s6476712.jpg","binding":"","translator":["姜宏","何源","蔡晓俊"],"catalog":"序 xxv\npart i 1\n第1章 哲学 3\n1.1 文化？什么文化 3\n1.2 unix的生命力 4\n1.3 反对学习unix文化的理由 5\n1.4 unix之失 6\n1.5 unix之得 7\n1.5.1 开源软件 7\n1.5.2 跨平台可移植性和开放标准 8\n1.5.3 internet和万维网 8\n1.5.4 开源社区 9\n1.5.5 从头到脚的灵活性 9\n1.5.6 unix hack之趣 10\n1.5.7 unix的经验别处也可适用 11\n1.6 unix哲学基础 11\n1.6.1 模块原则：使用简洁的接口拼合简单的部件 14\n1.6.2 清晰原则: 清晰胜于机巧 14\n1.6.3 组合原则：设计时考虑拼接组合 15\n1.6.4 分离原则: 策略同机制分离，接口同引擎分离 16\n.1.6.5 简洁原则：设计要简洁，复杂度能低则低 17\n1.6.6 吝啬原则: 除非确无它法，不要编写庞大的程序 18\n1.6.7 透明性原则：设计要可见，以便审查和调试 18\n1.6.8 健壮原则: 健壮源于透明与简洁 18\n1.6.9 表示原则: 把知识叠入数据以求逻辑质朴而健壮 19\n1.6.10 通俗原则：接口设计避免标新立异 20\n1.6.11 缄默原则：如果一个程序没什么好说的，就保持沉默 20\n1.6.12 补救原则: 出现异常时，马上退出并给出足量错误信息 21\n1.6.13 经济原则: 宁花机器一分，不花程序员一秒 22\n1.6.14 生成原则: 避免手工hack，尽量编写程序去生成程序 22\n1.6.15 优化原则: 雕琢前先得有原型，跑之前先学会走 23\n1.6.16 多样原则:决不相信所谓“不二法门”的断言 24\n1.6.17 扩展原则: 设计着眼未来，未来总比预想快 24\n1.7 unix哲学之一言以蔽之 25\n1.8 应用unix哲学 26\n1.9 态度也要紧 26\n第2章 历史——双流记 29\n2.1 unix的起源及历史，1969－1995 29\n2.1.1 创世纪：1969－1971 30\n2.1.2 出埃及记：1971－1980 32\n2.1.3 tcp\/ip 和unix内战：1980－1990 35\n2.1.4 反击帝国：1991－1995 41\n2.2 黑客的起源和历史：1961－1995 43\n2.2.1 游戏在校园的林间：1961－1980 44\n2.2.2 互联网大融合与自由软件运动：1981－1991 45\n2.2.3 linux 和实用主义者的应对：1991－1998 48\n2.3 开源运动：1998年及之后 49\n2.4 unix的历史教训 51\n第3章 对比： unix哲学同其他哲学的比较 53\n3.1 操作系统的风格元素 53\n3.1.1 什么是操作系统的统一性理念 54\n3.1.2 多任务能力 54\n3.1.3 协作进程 55\n3.1.4 内部边界 57\n3.1.5 文件属性和记录结构 57\n3.1.6 二进制文件格式 58\n3.1.7 首选用户界面风格 58\n3.1.8 目标受众 59\n3.1.9 开发的门坎 60\n3.2 操作系统的比较 61\n3.2.1 vms 61\n3.2.2 macos 64\n3.2.3 os\/2 65\n3.2.4 windows nt 68\n3.2.5 beos 71\n3.2.6 mvs 72\n3.2.7 vm\/cms 74\n3.2.8 linux 76\n3.3 种什么籽，得什么果 78\npart ii 81\n第4章 模块性：保持清晰，保持简洁 83\n4.1 封装和最佳模块大小 85\n4.2 紧凑性和正交性 87\n4.2.1 紧凑性 87\n4.2.2 正交性 89\n4.2.3 spot原则 91\n4.2.4 紧凑性和强单一中心 92\n4.2.5 分离的价值 94\n4.3 软件是多层的 95\n4.3.1 自顶向下和自底向上 95\n4.3.2 胶合层 97\n4.3.3 实例分析：被视为薄胶合层的c语言 98\n4.4 程序库 99\n4.4.1 实例分析：gimp插件 100\n4.5 unix和面向对象语言 101\n4.6 模块式编码 103\n第5章 文本化：好协议产生好实践 105\n5.1 文本化的重要性 107\n5.1.1 实例分析：unix口令文件格式 109\n5.1.2 实例分析：.newsrc格式 110\n5.1.3 实例分析：png图形文件格式 111\n5.2 数据文件元格式 112\n5.2.1 dsv 风格 113\n5.2.2 rfc 822 格式 114\n5.2.3 cookie-jar格式 115\n5.2.4 record-jar格式 116\n5.2.5 xml 117\n5.2.6 windows ini 格式 119\n5.2.7 unix文本文件格式的约定 120\n5.2.8 文件压缩的利弊 122\n5.3 应用协议设计 123\n5.3.1 实例分析：smtp，一个简单的套接字协议 124\n5.3.2 实例分析：pop3，邮局协议 124\n5.3.3 实例分析：imap，互联网消息访问协议 126\n5.4 应用协议元格式 127\n5.4.1 经典的互联网应用元协议 127\n5.4.2 作为通用应用协议的http 128\n5.4.3 beep：块可扩展交换协议 130\n5.4.4 xml-rpc，soap和jabber 131\n第6章 透明性：来点儿光 133\n6.1 研究实例 135\n6.1.1 实例分析：audacity 135\n6.1.2 实例分析：fetchmail的–v选项 136\n6.1.3 实例分析：gcc 139\n6.1.4 实例分析：kmail 140\n6.1.5 实例分析：sng 142\n6.1.6 实例分析：terminfo数据库 144\n6.1.7 实例分析：freeciv数据文件 146\n6.2 为透明性和可显性而设计 148\n6.2.1 透明性之禅 149\n6.2.2 为透明性和可显性而编码 150\n6.2.3 透明性和避免过度保护 151\n6.2.4 透明性和可编辑的表现形式 152\n6.2.5 透明性、故障诊断和故障恢复 153\n6.3 为可维护性而设计 154\n第7章 多道程序设计： 分离进程为独立的功能 157\n7.1 从性能调整中分离复杂度控制 159\n7.2 unix ipc 方法的分类 160\n7.2.1 把任务转给专门程序 160\n7.2.2 管道、重定向和过滤器 161\n7.2.3 包装器 166\n7.2.4 安全性包装器和bernstein链 167\n7.2.5 从进程 168\n7.2.6 对等进程间通信 169\n7.3 要避免的问题和方法 176\n7.3.1 废弃的unix ipc方法 176\n7.3.2 远程过程调用 178\n7.3.3 线程——恐吓或威胁 180\n7.4 在设计层次上的进程划分 181\n第8章 微型语言：寻找歌唱的乐符 183\n8.1 理解语言分类法 185\n8.2 应用微型语言 187\n8.2.1 案例分析：sng 187\n8.2.2 案例分析：正则表达式 188\n8.2.3 案例分析：glade 191\n8.2.4 案例分析：m4 193\n8.2.5 案例分析：xslt 194\n8.2.6 案例分析：the documenter's workbench tools 195\n8.2.7 案例分析：fetchmail的运行控制语法 199\n8.2.8 案例分析：awk 200\n8.2.9 案例分析：postscript 202\n8.2.10 案例分析：bc和dc 203\n8.2.11 案例分析：emacs lisp 205\n8.2.12 案例分析：javascript 205\n8.3 设计微型语言 206\n8.3.1 选择正确的复杂度 207\n8.3.2 扩展和嵌入语言 209\n8.3.3 编写自定义语法 210\n8.3.4 宏—慎用 210\n8.3.5 语言还是应用协议 212\n第9章 生成：提升规格说明的层次 215\n9.1 数据驱动编程 216\n9.1.1 实例分析：ascii 217\n9.1.2 实例分析：统计学的垃圾邮件统计 218\n9.1.3 实例分析：fetchmailconf中的元类改动 219\n9.2 专用代码的生成 225\n9.2.1 实例分析：生成ascii显示的代码 225\n9.2.2 实例分析：为列表生成html代码 227\n第10章 配置：迈出正确的第一步 231\n10.1 什么应是可配置的 231\n10.2 配置在哪里 233\n10.3 运行控制文件 234\n10.3.1 实例分析：.netrc文件 236\n10.3.2 到其它操作系统的可移植性 238\n10.4 环境变量 238\n10.4.1 系统环境变量 238\n10.4.2 用户环境变量 240\n10.4.3 何时使用环境变量 240\n10.4.4 到其它操作系统的可移植性 242\n10.5 命令行选项 242\n10.5.1 从–a到–z的命令行选项 243\n10.5.2 到其它操作系统的可移植性 248\n10.6 如何挑选方法 248\n10.6.1 实例分析：fetchmail 249\n10.6.2 实例分析：xfree86服务器 251\n10.7 论打破规则 252\n第11章 接口：unix环境下的用户接口设计模式 253\n11.1 最小立异原则的应用 254\n11.2 unix接口设计的历史 256\n11.3 接口设计评估 257\n11.4 cli和可视接口之间的权衡 259\n11.4.1 实例分析：编写计算器程序的两种方式 262\n11.5 透明度、表现力和可配置性 264\n11.6 unix接口设计模式 266\n11.6.1 过滤器模式 266\n11.6.2 cantrip模式 268\n11.6.3 源模式 268\n11.6.4 接收器模式 269\n11.6.5 编译器模式 269\n11.6.6 ed模式 270\n11.6.7 roguelike 模式 270\n11.6.8 “引擎和接口分离”模式 273\n11.6.9 cli服务器模式 278\n11.6.10 基于语言的接口模式 279\n11.7 应用unix接口设计模式 280\n11.7.1\n11.8 网页浏览器作为通用前端 281\n11.9 沉默是金 284\n第12章 优化 287\n12.1 什么也别做，就站在那儿 287\n12.2 先估量，后优化 288\n12.3 非定域性之害 290\n12.4 吞吐量和延迟 291\n12.4.1 批操作 292\n12.4.2 重叠操作 293\n12.4.3 缓存操作结果 293\n第13章 复杂度：尽可能简单，但别简过了头 295\n13.1 谈谈复杂度 296\n13.1.1 复杂度的三个来源 296\n13.1.2 接口复杂度和实现复杂度的折中 298\n13.1.3 必然的、可能的和偶然的复杂度 299\n13.1.4 映射复杂度 300\n13.1.5 当简洁性不能胜任 302\n13.2 五个编辑器的故事 302\n13.2.1 ed 304\n13.2.2 vi 305\n13.2.3 sam 306\n13.2.4 emacs 307\n13.2.5 wily 308\n13.3 编辑器的适当规模 309\n13.3.1 甄别复杂度问题 309\n13.3.2 折衷无用 312\n13.3.3 emacs是个反unix传统的论据吗 314\n13.4 软件的适度规模 316\npart iii 319\n第14章 语言：c还是非c 321\n14.1 unix下语言的丰饶 321\n14.2 为什么不是c 323\n14.3 解释型语言和混合策略 325\n14.4 语言评估 325\n14.4.1 c 326\n14.4.2 c++ 327\n14.4.3 shell 330\n14.4.4 perl 332\n14.4.5 tcl 334\n14.4.6 python 336\n14.4.7 java 339\n14.4.8 emacs lisp 342\n14.5 未来趋势 344\n14.6 选择x工具包 346\n第15章 工具：开发的战术 349\n15.1 开发者友好的操作系统 349\n15.2 编辑器选择 350\n15.2.1 了解vi 351\n15.2.2 了解emacs 351\n15.2.3 非虔诚的选择：两者兼用 352\n15.3 专用代码生成器 352\n15.3.1 yacc和lex 353\n15.3.2 实例分析：fetchmailrc的语法 356\n15.3.3 实例分析：glade 356\n15.4 make：自动化编译 357\n15.4.1 make的基本理论 357\n15.4.2 非c\/c++开发中的make 359\n15.4.3 通用生成目标 359\n15.4.4 生成makefile 362\n15.5 版本控制系统 364\n15.5.1 为什么需要版本控制 364\n15.5.2 手工版本控制 365\n15.5.3 自动化的版本控制 366\n15.5.4 unix的版本控制工具 367\n15.6 运行期调试 369\n15.7 性能分析 370\n15.8 使用emacs整合工具 370\n15.8.1 emacs和make 371\n15.8.2 emacs和运行期调试 371\n15.8.3 emacs和版本控制 371\n15.8.4 emacs和profiling 372\n15.8.5 像ide一样，但更强 373\n第16章 重用：论不要重新发明轮子 375\n16.1 猪小兵的故事 376\n16.2 透明性是重用的关键 379\n16.3 从重用到开源 380\n16.4 生命中最美好的就是“开放” 381\n16.5 何处找 384\n16.6 使用开源软件的问题 385\n16.7 许可证问题 386\n16.7.1 开放源码的资格 386\n16.7.2 标准开放源码许可证 388\n16.7.3 何时需要律师 390\npart iv 391\n第17章 可移植性：软件可移植性与遵循标准 393\n17.1 c语言的演化 394\n17.1.1 早期的c语言 395\n17.1.2 c 语言标准 396\n17.2 unix 标准 398\n17.2.1 标准和unix之战 398\n17.2.2 庆功宴上的幽灵 401\n17.2.3 开源世界的unix标准 402\n17.3 ietf和rfc标准化过程 403\n17.4 规格dna，代码rna 405\n17.5 可移植性编程 408\n17.5.1 可移植性和编程语言选择 409\n17.5.2 避免系统依赖性 412\n17.5.3 移植工具 413\n17.6 国际化 413\n17.7 可移植性、开放标准以及开放源码 414\n第18章 文档：向网络世界阐释代码 417\n18.1 文档概念 418\n18.2 unix风格 420\n18.2.1 大文档偏爱 420\n18.2.2 文化风格 421\n18.3 各种unix文档格式 422\n18.3.1 troff和documenter's workbench tools 422\n18.3.2 tex 424\n18.3.3 texinfo 425\n18.3.4 pod 425\n18.3.5 html 426\n18.3.6 docbook 426\n18.4 当前的混乱和可能的出路 426\n18.5 docbook 427\n18.5.1 文档类型定义 427\n18.5.2 其它dtd 428\n18.5.3 docbook 工具链 429\n18.5.4 移植工具 431\n18.5.5 编辑工具 432\n18.5.6 相关标准和实践 433\n18.5.7 sgml 433\n18.5.8 xml-docbook 参考书籍 433\n18.6 编写unix文档的最佳实践 434\n第19章 开放源码：在unix新社区中编程 437\n19.1 unix和开放源码 438\n19.2 与开源开发者协同工作的最佳实践 440\n19.2.1 良好的修补实践 440\n19.2.2 良好的项目、档案文件命名实践 444\n19.2.3 良好的开发实践 447\n19.2.4 良好的发行制作实践 450\n19.2.5 良好的交流实践 454\n19.3 许可证的逻辑：如何挑选 456\n19.4 为什么应使用某个标准许可证 457\n19.5 各种开源许可证 457\n19.5.1 mit或者x consortium许可证 457\n19.5.2 经典bsd许可证 457\n19.5.3 artistic许可证 458\n19.5.4 通用公共许可证 458\n19.5.5 mozilla 公共许可证 459\n第20章 未来：危机与机遇 461\n20.1 unix传统中的必然和偶然 461\n20.2 plan 9：未来之路 464\n20.3 unix设计中的问题 466\n20.3.1 unix文件就是一大袋字节 466\n20.3.2 unix对gui的支持孱弱 467\n20.3.3 文件删除不可撤销 468\n20.3.4 unix假定文件系统是静态的 469\n20.3.5 作业控制设计拙劣 469\n20.3.6 unix api 没有使用异常 470\n20.3.7 ioctl(2)和fcntl(2)是个尴尬 471\n20.3.8 unix安全模型可能太过原始 471\n20.3.9 unix名字种类太多 472\n20.3.10 文件系统可能有害论 472\n20.3.11 朝向全局互联网地址空间 472\n20.4 unix的环境问题 473\n20.5 unix文化中的问题 475\n20.6 信任的理由 477\n附录a 缩写词表 479\n附录b 参考文献 483\n附录c 贡献者 495\n附录d 无根的根：无名师的unix心传 499\ncolophon 510\n索引 511","pages":"530","images":{"small":"http:\/\/img3.douban.com\/spic\/s6476712.jpg","large":"http:\/\/img3.douban.com\/lpic\/s6476712.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s6476712.jpg"},"alt":"http:\/\/book.douban.com\/subject\/5387401\/","id":"5387401","publisher":"电子工业出版社","isbn10":"7121123290","isbn13":"9787121123290","title":"UNIX编程艺术","url":"http:\/\/api.douban.com\/v2\/book\/5387401","alt_title":"The Art of UNIX Programming","author_intro":"《The Art of UNIX Programming》，简称TAOUP，作者Eric S. Raymond，简称ESR。这大概是计算机类书籍中很少见的一本课外读物。TCP\/IP编程之类典型Unix编程书中讲到的东西在这本书里面找不到，所以书里讲到的当然就是别的书里找不到的东西。读者也许需要有相当的Unix背景、或者长期钻研某个专题，才能体会到作者的弦外之音。ESR作为老牌黑客信手拈来的典故，如果不是在Unix里面长期浸淫，大概很难有所共鸣，所以把这当作Unix的一部坊间史话倒也合适。","summary":"本书主要介绍了Unix系统领域中的设计和开发哲学、思想文化体系、原则与经验，由公认的Unix编程大师、开源运动领袖人物之一Eric S. Raymond倾力多年写作而成。包括Unix设计者在内的多位领域专家也为本书贡献了宝贵的内容。本书内容涉及社群文化、软件开发设计与实现，覆盖面广、内容深邃，完全展现了作者极其深厚的经验积累和领域智慧。","price":"69.00元"},{"rating":{"max":10,"numRaters":172,"average":"7.6","min":0},"subtitle":"","author":["Tarek Ziadé"],"pubdate":"2010-1-1","tags":[{"count":279,"name":"python","title":"python"},{"count":93,"name":"编程","title":"编程"},{"count":82,"name":"Python","title":"Python"},{"count":49,"name":"计算机","title":"计算机"},{"count":40,"name":"程序设计","title":"程序设计"},{"count":39,"name":"programming","title":"programming"},{"count":34,"name":"软件开发","title":"软件开发"},{"count":27,"name":"Programming","title":"Programming"}],"origin_title":"Expert Python Programming","image":"http:\/\/img3.douban.com\/mpic\/s4163751.jpg","binding":"","translator":["姚军","夏海轮","译"],"catalog":"第1章　准备工作\n1.1　安装Python\n1.1.1　Python实现版本\n1.1.2　在Linux环境下安装\n1.1.3　在Windows环境下安装\n1.1.4　在Mac OS X环境下安装\n1.2　Python命令行\n1.2.1　定制交互式命令行\n1.2.2　iPython：增强型命令行\n1.3　安装setuptools\n1.3.1　工作原理\n1.3.2　使用EasyInstall安装setuptools\n1.3.3　将MinGW整合到distutils中\n1.4　工作环境\n1.4.1　使用文本编辑器与辅助工具的组合\n1.4.2　使用集成开发环境\n1.5　小结\n第2章　语法最佳实践——低于类级\n2.1　列表推导\n2.2　迭代器和生成器\n2.2.1　生成器\n2.2.2　协同程序\n2.2.3　生成器表达式\n2.2.4　itertools模块\n2.3　装饰器\n2.3.1　如何编写装饰器\n2.3.2　参数检查\n2.3.3　缓存\n2.3.4　代理\n2.3.5　上下文提供者\n2.4　with和contextlib\n2.4.1　contextlib模块\n2.4.2　上下文实例\n2.5　小结\n第3章　语法最佳实践——类级\n3.1　子类化内建类型\n3.2　访问超类中的方法\n3.2.1　理解Python的方法解析顺序\n3.2.2　super的缺陷\n3.3　最佳实践\n3.4　描述符和属性\n3.4.1　描述符\n3.4.2　属性\n3.5　槽\n3.6　元编程\n3.6.1　__new__方法\n3.6.2　__metaclass__方法\n3.7　小结\n第4章　选择好的名称\n4.1　PEP 8和命名最佳实践\n4.2　命名风格\n4.2.1　变量\n4.2.2　函数和方法\n4.2.3　属性\n4.2.4　类\n4.2.5　模块和包\n4.3　命名指南\n4.3.1　使用“has”或“is”前缀命名布尔元素\n4.3.2　用复数形式命名序列元素\n4.3.3　用显式的名称命名字典\n4.3.4　避免通用名称\n4.3.5　避免现有名称\n4.4　参数最佳实践\n4.4.1　根据迭代设计构建参数\n4.4.2　信任参数和测试\n4.4.3　小心使用*args和**kw魔法参数\n4.5　类名\n4.6　模块和包名称\n4.7　使用API\n4.7.1　跟踪冗长\n4.7.2　构建命名空间树\n4.7.3　分解代码\n4.7.4　使用Egg\n4.7.5　使用deprecation过程\n4.8　有用的工具\n4.8.1　Pylint\n4.8.2　CloneDigger\n4.9　小结\n第5章　编写一个包\n第6章　编写一个应用程序\n第7章　使用zc.buildout\n第8章　代码管理\n第9章　生命周期管理\n第10章　编写项目文档\n第11章　测试驱动开发\n第12章　优化：通用原则和剖析技术\n第13章　优化：解决方案\n第14章　有用的设计模式","pages":"306","images":{"small":"http:\/\/img3.douban.com\/spic\/s4163751.jpg","large":"http:\/\/img3.douban.com\/lpic\/s4163751.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s4163751.jpg"},"alt":"http:\/\/book.douban.com\/subject\/4212921\/","id":"4212921","publisher":"人民邮电出版社","isbn10":"7115217033","isbn13":"9787115217035","title":"Python高级编程","url":"http:\/\/api.douban.com\/v2\/book\/4212921","alt_title":"Expert Python Programming","author_intro":"Tarek Ziadé，是巴黎Ingeniweb公司的CTO，其工作方向为Python、Zope、Plone技术和质量保证。他参与Zope社区已经有5年了，并且曾经为Zope自身贡献过代码。\nTarek创建了Afpy，这是法国的Python用户组，并且编写了两本法语的Python书籍。他还在诸如Solutions Linux、Pycon、OSCON和EuroPython等法国及国际会议上发表了许多演讲，并且主持了许多课程。","summary":"《Python高级编程》通过大量的实例，介绍了Python语言的最佳实践和敏捷开发方法，并涉及整个软件生命周期的高级主题，诸如持续集成、版本控制系统、包的发行和分发、开发模式、文档编写等。《Python高级编程》首先介绍如何设置最优的开发环境，然后以Python敏捷开发方法为线索，阐述如何将已被验证的面向对象原则应用到设计中。这些内容为开发人员和项目管理人员提供了整个软件工程中的许多高级概念以及专家级的建议，其中有些内容的意义甚至超出了Python语言本身。\n《Python高级编程》针对具备一定Python基础并希望通过在项目中应用最佳实践和新的开发技术来提升自己的Python开发人员。","price":"45.00元"},{"rating":{"max":10,"numRaters":199,"average":"8.7","min":0},"subtitle":"","author":["David Flanagan","松本行弘"],"pubdate":"2009-1","tags":[{"count":213,"name":"ruby","title":"ruby"},{"count":113,"name":"Ruby","title":"Ruby"},{"count":78,"name":"Programming","title":"Programming"},{"count":67,"name":"编程","title":"编程"},{"count":52,"name":"计算机","title":"计算机"},{"count":42,"name":"O'Reilly","title":"O'Reilly"},{"count":41,"name":"编程语言","title":"编程语言"},{"count":38,"name":"松本行弘","title":"松本行弘"}],"origin_title":"The Ruby Programming Language","image":"http:\/\/img3.douban.com\/mpic\/s11352335.jpg","binding":"平装","translator":["廖志刚","张禾"],"catalog":"第1章 导言 1\n1.1 漫游Ruby 2\n1.2 体验Ruby 11\n1.3 关于本书 15\n1.4 一个Ruby版的Sudoku解答 17\n第2章 Ruby程序的结构和运行 25\n2.1 词法结构 26\n2.2 句法结构 33\n2.3 文件结构 35\n2.4 程序的编码 36\n2.5 Ruby程序的运行 39\n第3章 数据类型和对象 41\n3.1 数字 42\n3.2 文本 46\n3.3 数组 64\n3.4 哈希 67\n3.5 范围 68\n3.6 符号 71\n3.7 True、False和Nil 72\n3.8 对象 72\n第4章 表达式和操作符 85\n4.1 字面量和关键字字面量 86\n4.2 变量引用 87\n4.3 常量引用 88\n4.4 方法调用 89\n4.5 赋值 92\n4.6 操作符 100\n第5章 语句和控制结构 117\n5.1 条件式 118\n5.2 循环 127\n5.3 迭代器和可枚举对象 130\n5.4 代码块 140\n5.5 改变控制流 146\n5.6 异常和异常处理 154\n5.7 BEGIN和END 165\n5.8 线程、纤程和连续体 166\n第6章 方法、Proc、Lambda和闭包 175\n6.1 定义简单方法 177\n6.2 方法名 180\n6.3 方法和圆括号 183\n6.4 方法参数 185\n6.5 Proc和Lambda 192\n6.6 闭包 200\n6.7 Method对象 203\n6.8 函数式编程 205\n第7章 类和模块 213\n7.1 定义一个简单类 214\n7.2 方法可见性：Public、Protected、Private 232\n7.3 子类化和继承 234\n7.4 对象创建和初始化 241\n7.5 模块 247\n7.6 加载和请求模块 252\n7.7 单键方法和Eigenclass 257\n7.8 方法查找 258\n7.9 常量查找 261\n第8章 反射和元编程 265\n8.1 类型、类和模块 266\n8.2 对字符串和块进行求值 268\n8.3 变量和常量 271\n8.4 方法 272\n8.5 钩子方法 277\n8.6 跟踪 279\n8.7 ObjectSpace和GC 281\n8.8 定制控制结构 281\n8.9 缺失的方法和常量 284\n8.10 动态创建方法 287\n8.11 别名链 290\n8.12 领域特定语言 296\n第9章 Ruby平台 303\n9.1 字符串 304\n9.2 正则表达式 310\n9.3 数字和数学运算 321\n9.4 日期和时间 325\n9.5 集合 328\n9.6 文件和目录 350\n9.7 输入\/输出 356\n9.8 网络 366\n9.9 线程和并发 372\n第10章 Ruby环境 389\n10.1 执行Ruby解释器 390\n10.2 顶层环境 394\n10.3 实用性信息抽取和产生报表的快捷方式 403\n10.4 调用操作系统的功能 405\n10.5 安全 409\n索引 413","pages":"431","images":{"small":"http:\/\/img3.douban.com\/spic\/s11352335.jpg","large":"http:\/\/img3.douban.com\/lpic\/s11352335.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s11352335.jpg"},"alt":"http:\/\/book.douban.com\/subject\/3329887\/","id":"3329887","publisher":"电子工业出版社","isbn10":"7121077019","isbn13":"9787121077012","title":"Ruby编程语言","url":"http:\/\/api.douban.com\/v2\/book\/3329887","alt_title":"The Ruby Programming Language","author_intro":"本书详细介绍了Ruby 1.8和1.9版本各方面的内容。在对Ruby进行了简要介绍之后，本书详尽覆盖了以下内容：Ruby的句法和语法结构，数据结构和对象，表达式和操作符，语句和控制结构，方法、proc、lambda和闭包，反射和元编程，Ruby平台。\n本书还包含对Ruby平台上丰富的API的详尽介绍，并用带有详尽注释的代码演示了Ruby进行文本处理、数字运算、集合、输入\/输出、网络开发和并发编程的功能。","summary":"《Ruby编程语言》详细介绍了Ruby 1.8和1.9版本各方面的内容。在对Ruby进行了简要的综述之后，《Ruby编程语言》详细介绍了以下内容：Ruby的句法和语法结构，数据结构和对象，表达式和操作符，语句和控制结构，方法、proc、lambda和闭包，反射和元编程，Ruby平台。《Ruby编程语言》还包含对Ruby平台上丰富的API的详尽介绍，并用带有详尽注释的代码演示了Ruby进行文本处理、数字运算、集合、输入\/输出、网络开发和并发编程的功能。","price":"68.00元"},{"rating":{"max":10,"numRaters":239,"average":"8.6","min":0},"subtitle":"","author":["[美] Larry Wall","Tom Christiansen","Jon Orwant"],"pubdate":"2001-12","tags":[{"count":241,"name":"Perl","title":"Perl"},{"count":91,"name":"编程","title":"编程"},{"count":57,"name":"Programming","title":"Programming"},{"count":56,"name":"O'Reilly","title":"O'Reilly"},{"count":43,"name":"计算机","title":"计算机"},{"count":28,"name":"程序设计","title":"程序设计"},{"count":20,"name":"语言","title":"语言"},{"count":13,"name":"script","title":"script"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s4246875.jpg","binding":"平装16开","translator":["何伟平"],"catalog":"","pages":"1102","images":{"small":"http:\/\/img3.douban.com\/spic\/s4246875.jpg","large":"http:\/\/img3.douban.com\/lpic\/s4246875.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s4246875.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1231697\/","id":"1231697","publisher":"中国电力出版社","isbn10":"7508307305","isbn13":"9787508307305","title":"Perl语言编程","url":"http:\/\/api.douban.com\/v2\/book\/1231697","alt_title":"","author_intro":"Larry Wall是Perl的创造者，也是其他一些流行的Unix自由软件的作者，包括rn新闻阅读器和无处不在的patch程序。从学历来看，Larry实际上是一位语言学家，是加州大学伯克利分校和洛杉矶分校的毕业生。","summary":"这不仅仅是一本关于Perl的书籍，更是一本独一无二的开发者自己介绍该语言及其文化的书籍。Larry Wall是Perl的开发者，他就这种语言的未来发展方向提出了自己的看法。Tom Christiansen是最早的几个拥护者之一，也是少数几个在错综复杂的中游刃有余的人之一。Jon Orwant是《Perl Journal》的主编，该杂志把Perl社区组合成了一个共同的论坛，以进行Perl新的开发。","price":"129.00元"},{"rating":{"max":10,"numRaters":225,"average":"9.1","min":0},"subtitle":"深入数据库体系结构","author":["Thomas Kyte"],"pubdate":"2006-10","tags":[{"count":246,"name":"oracle","title":"oracle"},{"count":147,"name":"数据库","title":"数据库"},{"count":51,"name":"Database","title":"Database"},{"count":43,"name":"计算机","title":"计算机"},{"count":39,"name":"DBA","title":"DBA"},{"count":24,"name":"数据库编程","title":"数据库编程"},{"count":19,"name":"Oracle","title":"Oracle"},{"count":15,"name":"IT","title":"IT"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s5745592.jpg","binding":"平装","translator":["苏金国","王小振"],"catalog":"","pages":"737","images":{"small":"http:\/\/img3.douban.com\/spic\/s5745592.jpg","large":"http:\/\/img3.douban.com\/lpic\/s5745592.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s5745592.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1864527\/","id":"1864527","publisher":"人民邮电出版社","isbn10":"711515032X","isbn13":"9787115150325","title":"Oracle 9i & 10g编程艺术","url":"http:\/\/api.douban.com\/v2\/book\/1864527","alt_title":"","author_intro":"","summary":"《Oracle9i&10g编程艺术:深入数据库体系结构》是讲述Oracle数据库公证的权威指南，凝聚了世界顶尖的Oracle专家Thomas Kyte数十年的宝贵经验和大量真的知灼见。书中深入地分析了Oracle数据库体系结构，包括文件、内存结构以及构成Oracle数据库和实例的度层进程，然后讨论了一些重要的数据库主题，如锁定、并发控制、事务、重做和撤销，还解释了这些内重要性。最后，分析了数据库中的物理结构，如表、索引和数据类型，并介绍通过哪些技术能最优地使用这些物理结构。无论你是程序员还是DBA，要创建和管理稳定、高质量的Oracle系统，归根结底都需要理解Oracle数据库的体系结构。","price":"99.00元"},{"rating":{"max":10,"numRaters":57,"average":"8.3","min":0},"subtitle":"英文版","author":["Alexander Stepanov","Paul McJones"],"pubdate":"2010","tags":[{"count":137,"name":"编程","title":"编程"},{"count":62,"name":"计算机科学","title":"计算机科学"},{"count":52,"name":"计算机","title":"计算机"},{"count":43,"name":"Programming","title":"Programming"},{"count":36,"name":"算法","title":"算法"},{"count":34,"name":"编程的本质","title":"编程的本质"},{"count":34,"name":"C++","title":"C++"},{"count":22,"name":"程序设计","title":"程序设计"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s4239554.jpg","binding":"平装","translator":[],"catalog":"Preface ixAbouttheAuthors xiii1 Foundations  1.1 CategoriesofIdeas:Entity,Species,Genus  1.2 Values  1.3 Objects  1.4 rocedures6  1.5 RegularTypes  1.6 RegularProcedures  1.7 Concepts  1.8 Conclusions142 TransformationsandTheirOrbits1  2.1 Transformations  2.2 Orbits  2.3 CollisionPoint  2.4 MeasuringOrbitSizes  2.5 Actions  2.6 Conclusions3 AssociativeOperations  3.1 Associativity  3.2 ComputingPowers  3.3 ProgramTransformations  3.4 Special-CaseProcedures  3.5 ParameterizingAlgorithms  3.6 LinearRecurrences  3.7 AccumulationProcedures  3.8 Conclusions4 LinearOrderings  4.1 Classi?cationofRelations  4.2 TotalandWeakOrderings  4.3 OrderSelection  4.4 NaturalTotalOrdering  4.5 ClustersofDerivedProcedures  4.6 ExtendingOrder-SelectionProcedures  4.7 Conclusions5 OrderedAlgebraicStructures  5.1 BasicAlgebraicStructures  5.2 OrderedAlgebraicStructures  5.3 Remainder  5.4 GreatestCommonDivisor  5.5 Generalizinggcd  5.6 Steingcd  5.7 Quotient  5.8 QuotientandRemainderforNegativeQuantities  5.9 ConceptsandTheirModels  5.10 ComputerIntegerTypes  5.11 Conclusions6 Iterators  6.1 Readability  6.2 Iterators  6.3 Ranges  6.4 ReadableRanges  6.5IncreasingRanges  6.6 ForwardIterators  6.7 IndexedIterators  6.8 BidirectionalIterators  6.9 Random-AccessIterators  6.1 Conclusions7 CoordinateStructures  7.1 ifurcateCoordinates  7.2 BidirectionalBifurcateCoordinates  7.3 CoordinateStructures  7.4 Isomorphism,Equivalence,andOrdering  7.5 Conclusions8 CoordinateswithMutableSuccessors  8.1 LinkedIterators  8.2 LinkRearrangements  8.3 ApplicationsofLinkRearrangements  8.4 LinkedBifurcateCoordinates  8.5 Conclusions9 Copying  9.1 Writability  9.2 Position-BasedCopying  9.3 Predicate-BasedCopying  9.4 SwappingRanges  9.5 Conclusions10 Rearrangements  10.1 Permutations  10.2 Rearrangements  10.3 ReverseAlgorithms  10.4 RotateAlgorithms  10.5 AlgorithmSelection  10.6 Conclusions11 PartitionandMerging  11.1 Partition  11.2 BalancedReduction  11.3 Merging  11.4 Conclusions12 CompositeObjects  12.1 SimpleCompositeObjects  12.2 DynamicSequences  12.3 UnderlyingType  12.4 ConclusionsAfterwordAppendixA MathematicalNotationAppendixB ProgrammingLanguage  B.1 LanguageDe?nition  B.2 MacrosandTraitStructuresBibliographyIndex","pages":"262","images":{"small":"http:\/\/img3.douban.com\/spic\/s4239554.jpg","large":"http:\/\/img3.douban.com\/lpic\/s4239554.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s4239554.jpg"},"alt":"http:\/\/book.douban.com\/subject\/4722718\/","id":"4722718","publisher":"机械工业出版社","isbn10":"7111300270","isbn13":"9787111300274","title":"编程的本质","url":"http:\/\/api.douban.com\/v2\/book\/4722718","alt_title":"Elements of Programming","author_intro":"Alexander Stepanov于1967～1972年间在莫斯科国立大学学习数学，从1972年开始在苏联，1977年移民美国后在美国从事编程工作。他编写过操作系统、编程工具、编译器和各种库。他在程序设计基础方面的工作先后得到GE、Polytechnic、AT&T、惠普、Silicon Graphics的支持，2002年后是Adobe的支持。1995年因C++标准模板库的设计获Dr.Dobb的程序设计杰出贡献奖。\n\n    Paul McJones于1967～1971年间在加州大学伯克利分校学习工程数学。从1967年开始介入程序设计，涉足的领域包括操作系统、程序设计环境、事务处理系统以及企业和客户应用系统等。他先后在加州大学、IBM、Xerox、Tandem、DEC工作，2003年至今在Adobe公司。1982年他与合作者一起因其论文“The Recovery Manager of the System R Database Manager”获得ACM程序设计系统和语言论文奖。","summary":"本书提供了有关编程的一种与众不同的理解。其主旨是，实际的编程也应像其他科学和工程领域一样基于坚实的数学基础。本书展示了在实际编程语言(如C++)中实现的算法如何在最一般的数学背景中操作。例如，如何定义快速求幂算法，使之能使用任何可交换运算。使用抽象算法将能得到更高效、可靠、安全和经济的软件。\n这不是一本很容易读的书，它也不是能提升你的编程技能的秘诀和技巧汇编。本书的价值是更根本性的，其终极目标是提升你对编程的洞察力。要想从中大获裨益，你需要从头到尾认真学习：阅读代码，证明引理，完成练习。到结束之时，你将看到如何把这里讨论的演绎式方法应用到你的程序中，保证你做出的软件部件能一起工作，并表现出它们所应该表现的行为。\n书中给出的算法和需求针对某些被操作的类型。有关这些描述的代码(也可以通过Web得到)采用C++的一个小子集书写，这样做是为了让所有有经验的程序员都能理解。这个小子集可以看做一种特殊语言，是由Sean Parent和Bjarne Stroustrup一起设计的。\n无论你是一位软件开发者，还是其他以编程作为一项重要活动的专业人员，或者是一名在校的学生，你都会逐渐理解本书的经验丰富的作者多年来一直在教授和阐释的道理：数学对于编程是绝好的东西，理论对于实际是绝好的东西。","price":"49.00元"},{"rating":{"max":10,"numRaters":68,"average":"8.5","min":0},"subtitle":"本书是极负盛名的C语言入门经典教材，其第一版发行至今已有二十年的历史 !","author":["（美）Stephen Kochan"],"pubdate":"2006年","tags":[{"count":212,"name":"c语言","title":"c语言"},{"count":63,"name":"计算机","title":"计算机"},{"count":57,"name":"编程","title":"编程"},{"count":54,"name":"入门","title":"入门"},{"count":53,"name":"c","title":"c"},{"count":45,"name":"程序设计","title":"程序设计"},{"count":44,"name":"C语言编程","title":"C语言编程"},{"count":27,"name":"教程","title":"教程"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s26387712.jpg","binding":"平装","translator":["张小潘"],"catalog":"","pages":"543","images":{"small":"http:\/\/img3.douban.com\/spic\/s26387712.jpg","large":"http:\/\/img3.douban.com\/lpic\/s26387712.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s26387712.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1786294\/","id":"1786294","publisher":"电子社博文视点资讯有限公司","isbn10":"7121007355","isbn13":"9787121007354","title":"C语言编程：一本全面的C语言入门教程（第三版）","url":"http:\/\/api.douban.com\/v2\/book\/1786294","alt_title":"Programming in C：A Complete introduction to the C programming language，Third Edition","author_intro":"","summary":"本书是极负盛名的C语言入门经典教材，其第一版发行至今已有20年的历史。本书内容详实全面，由浅入深，示例丰富，并在每个章节后面附有部分习题，非常适合读者自学使用。除此之外，《C语言编程》一书对于C语言标准的最新进展、C语言常见开发工具以及管理C语言大型项目等重要方面，也进行了深入浅出的说明。","price":"59"},{"rating":{"max":10,"numRaters":121,"average":"7.4","min":0},"subtitle":"","author":["Susan Lammers"],"pubdate":"2012-1","tags":[{"count":116,"name":"编程","title":"编程"},{"count":99,"name":"计算机","title":"计算机"},{"count":79,"name":"程序人生","title":"程序人生"},{"count":30,"name":"IT","title":"IT"},{"count":26,"name":"计算机科学","title":"计算机科学"},{"count":26,"name":"软件开发","title":"软件开发"},{"count":25,"name":"传记","title":"传记"},{"count":25,"name":"编程经验","title":"编程经验"}],"origin_title":"","image":"http:\/\/img5.douban.com\/mpic\/s24509127.jpg","binding":"平装","translator":["李琳骁","吴咏炜","张菁"],"catalog":"第1 篇  查尔斯·西蒙尼　　 1\n第2 篇  巴特勒·兰普森　　 17\n第3 篇  约翰·沃诺克　　 31\n第4 篇  加里·基尔代尔　　 47\n第5 篇  比尔·盖茨　　 61\n第6 篇  约翰·佩奇　　 79\n第7 篇  C.韦恩·莱特莱夫　　 95\n第8 篇  丹·布兰克林　　 115\n第9 篇  鲍勃·弗兰克斯顿　　 135\n第10 篇  乔纳森·萨奇　　 145\n第11 篇  雷·奥奇　　157\n第12 篇  彼得·罗伊森　　 173\n第13 篇  鲍勃·卡尔　　 187\n第14 篇  杰夫·拉斯金　　 207\n第15 篇  安迪·赫兹菲尔德　　 227\n第16 篇  岩谷徹　　241\n第17 篇  斯科特·金　　 249\n第18 篇  加隆·兰尼尔　　 261\n第19 篇  迈克尔·霍利　　 275\n词汇表　　 292\n附 录　　 301","ebook_url":"http:\/\/read.douban.com\/ebook\/387679\/","pages":"357","images":{"small":"http:\/\/img5.douban.com\/spic\/s24509127.jpg","large":"http:\/\/img5.douban.com\/lpic\/s24509127.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s24509127.jpg"},"alt":"http:\/\/book.douban.com\/subject\/7007204\/","id":"7007204","publisher":"人民邮电","isbn10":"7115264317","isbn13":"9787115264312","title":"编程大师访谈录","url":"http:\/\/api.douban.com\/v2\/book\/7007204","alt_title":"","author_intro":"Susan Lammers\n现居华盛顿州西雅 图市，是手机应用开发公司Flying Sofa的合伙人，也是风险投资资助的创业公司Headbone Interactive的董事长及创始人，这家公司专为互联网、电视及其他面向儿童的媒体开发交互式多媒体软件。Susan是多媒体领域的先锋，曾是微软 公司早期的多媒体出版部联合出版人和总监，负责微软最早的交互式媒体项目，包括微软的电子百科全书Encarta（英卡塔）。\n1990年，Lammers离开微软，加入一家创业公司，成为该公司的第三位员工。这家公司现名Corbis，已跻身世界最大的数字图像代理公司之列。Corbis由比尔•盖茨创立，旨在开发自然语言图像的大型数据库并进行交互式电视程序设计。\nLammers毕业于斯坦福大学，拥有英语文学士学位。","summary":"《编程大师访谈录》是对19位计算机行业先驱的采访实录，采访对象包括查尔斯•西蒙尼、比尔•盖茨、安迪•赫兹菲尔德、雷•奥奇、杰夫•拉斯金等。访谈涉及他们软件创造过程的灵感、技术、编程习惯、动机、反思，以及对未来软件的畅想等。问答中集结了这些计算机先驱的精辟言论，处处闪烁着智慧的火花。\n《编程大师访谈录》适合IT从业人员阅读。","ebook_price":"25.00","price":"59.00元"},{"rating":{"max":10,"numRaters":160,"average":"8.2","min":0},"subtitle":"第一卷：深入理解计算机","author":["Hyde R"],"pubdate":"2006-4-1","tags":[{"count":97,"name":"编程","title":"编程"},{"count":53,"name":"计算机","title":"计算机"},{"count":45,"name":"程序设计","title":"程序设计"},{"count":39,"name":"编程卓越之道","title":"编程卓越之道"},{"count":30,"name":"Programming","title":"Programming"},{"count":26,"name":"计算机科学","title":"计算机科学"},{"count":24,"name":"计算机结构","title":"计算机结构"},{"count":17,"name":"系统原理","title":"系统原理"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s1654414.jpg","binding":"","translator":["韩东海"],"catalog":"","pages":"445","images":{"small":"http:\/\/img3.douban.com\/spic\/s1654414.jpg","large":"http:\/\/img3.douban.com\/lpic\/s1654414.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s1654414.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1760738\/","id":"1760738","publisher":"电子工业出版社","isbn10":"7121024047","isbn13":"9787121024047","title":"编程卓越之道","url":"http:\/\/api.douban.com\/v2\/book\/1760738","alt_title":"WRITE GREAT CODE:Volume 1:Understanding the Machine","author_intro":"","summary":"各位程序员一定希望自己编写的代码是能让老板赞赏、满意的代码；是能让客户乐意掏钱购买的代码；是能让使用者顺利使用的代码；是能让同行欣赏赞誉的代码；是能让自己引以为豪的卓越代码。本书作者为希望能编写出卓越代码的人提供了自己积累的关于卓越编程的真知灼见。它弥补了计算机科学和工程课程中被忽略的一个部分——底层细节，而这正是构建卓越代码的基石。具体内容包括：计算机数据表示法，二进制数学运算与位运算，内存组织与内存访问，数据类型及其表示，布尔逻辑与数字设计，CPU体系结构，CPU指令集的体系结构，内存体系与内存组织，计算机系统如何与外界通信等。...","price":"49.80"},{"rating":{"max":10,"numRaters":51,"average":"8.5","min":0},"subtitle":"For Xcode 4","author":["Joe Conway","Aaron Hillegass"],"pubdate":"2012-3-20","tags":[{"count":159,"name":"iOS","title":"iOS"},{"count":143,"name":"iOS编程","title":"iOS编程"},{"count":70,"name":"iPhone开发","title":"iPhone开发"},{"count":47,"name":"编程","title":"编程"},{"count":27,"name":"Programming","title":"Programming"},{"count":26,"name":"计算机","title":"计算机"},{"count":13,"name":"iphone","title":"iphone"},{"count":8,"name":"MACOS","title":"MACOS"}],"origin_title":"iOS Programming: The Big Nerd Ranch Guide (2nd Edition)","image":"http:\/\/img5.douban.com\/mpic\/s9042517.jpg","binding":"平装","translator":["夏伟频","李骏"],"catalog":"简介\ti\n本书适合哪些读者\ti\n第二版有哪些更新？\ti\n教学理念\tii\n如何使用本书\tiii\n本书是如何组织的\tiii\n代码风格\tv\n版式说明\tvi\n开发所需的硬件与软件\tvi\n第1章  第一个简单的iOS应用\t1\n1.1  创建Xcode项目\t2\n1.2  创建界面\t5\n1.3  模型-视图-控制器\t10\n1.4  声明\t13\n声明实例变量\t13\n声明方法\t14\n1.5  创建关联\t15\n设置指针\t15\n设置目标（target）和动作（action）\t17\n关联小结\t19\n1.6  实现方法\t20\n1.7  针对模拟器构建并运行应用\t21\n1.8  安装应用\t23\n1.9  应用图标\t24\n1.10  启动图片\t27\n第2章  Objective-C\t31\n2.1  对象\t31\n2.2  使用实例\t32\n创建对象\t32\n发送消息\t33\n释放对象\t34\n2.3  编写命令行工具RandomPossessions\t35\nNSString\t38\nNSArray与NSMutableArray\t39\n2.4  子类化Objective-C类\t40\n实例变量\t44\n存取方法\t45\n实例方法\t48\n初始化方法\t49\n其他初始化方法与初始化方法链\t52\n类方法\t53\n测试子类\t55\n2.5  异常与控制台窗口\t56\n2.6  快速枚举\t57\n2.7  练习\t58\n第3章  内存管理\t59\n3.1  内存管理基础\t59\nC语言的内存管理\t59\n通过对象管理内存\t61\n3.2  引用计数\t61\n使用retain计数\t61\n使用autorelease\t64\n存取方法和内存管理\t67\n实现dealloc\t69\n通过属性机制简化存取方法\t70\ncopy和mutableCopy\t72\nRetain计数规则\t73\n3.3  深入学习：再谈内存管理\t74\n第4章  委托机制与Core Location\t77\n4.1  项目、目标和框架\t77\n4.2  Core Location\t79\n通过CLLocationManager获取更新数据\t81\n4.3  委托机制\t82\n协议\t83\n协议方法\t84\n委托机制、控制器对象和内存管理\t85\n4.4  使用调试器\t86\n4.5  练习：方位\t91\n4.6  深入学习：构建阶段、编译器错误和连接器错误\t91\n预处理（Preprocessing）\t92\n编译\t93\n连接\t94\n第5章  MapKit与文本输入\t97\n5.1  对象图\t97\n5.2  MapKit框架\t99\n5.3  界面属性\t99\n5.4  设置MapView对象的委托对象\t102\n使用文档\t103\n创建MKAnnotation子类\t108\n标记位置\t112\n完成Whereami\t113\n5.5  练习：扩充标注\t114\n5.6  练习：根据地理位置获取城市信息\t114\n第6章  创建UIView子类\t115\n6.1  创建自定义视图\t116\ndrawRect:方法\t116\n创建UIView实例\t118\n6.2  绘制文字和阴影\t120\n6.3  使用UIScrollView\t121\n6.4  实现缩放功能\t122\n6.5  隐藏状态条\t123\n6.6  练习：颜色\t125\n6.7  深入学习：Retain循环\t125\n6.8  深入学习：重画视图\t125\n第7章  视图控制对象\t127\n7.1  视图控制对象与XIB文件\t127\n7.2  使用视图控制对象\t129\n创建UITabBarController对象\t130\n创建视图控制对象和标签项\t131\n为视图控制对象创建视图\t135\n深入浅出XIB：介绍文件所有者\t137\n7.3  视图的显示和消失\t142\n7.4  视图控制对象的生命周期与内存过低警告\t142\n7.5  UIViewController子类与模板\t146\n7.6  练习：地图标签\t147\n第8章  方向感应器\t149\n8.1  设置方向感应器\t149\n8.2  获取方向感应器数据\t151\n8.3  加速方向与加速数值\t151\n8.4  使用加速感应器数据\t151\n8.5  使加速感应器数据更“平滑”\t152\n8.6  侦测摇动\t153\n8.7  练习：改变颜色\t155\n8.8  深入学习：滤波与频率\t155\n8.9  深入学习：Retina显示屏\t156\n第9章  通告机制与设备转动\t159\n9.1  通告中心\t159\n9.2  UIDevice通告\t160\n9.3  自动转屏\t161\n用代码设置自动缩放掩码与按位运算符\t167\n9.4  强制使用横排模式\t169\n9.5  练习：设备近身通告\t170\n深入学习：覆盖自动转屏\t170\n第10章  UITableView与UITableViewController\t171\n10.1  编写Homepwner应用\t171\n10.2  UITableViewController\t172\n创建UITableViewController子类\t173\n10.3  UITableView数据源\t176\nPossessionStore：单实例对象\t177\n实现数据源方法\t180\n10.4  UITableViewCell对象\t182\n创建并获取UITableViewCell对象\t183\n重用UITableViewCell对象\t185\n10.5  代码片段库\t186\n10.6  练习：表格段\t189\n第11章  编辑UITableView\t191\n11.1  编辑模式\t191\n11.2  增加行\t197\n11.3  删除行\t198\n11.4  移动行\t199\n第12章  UINavigationController\t203\n12.1  UINavigationController\t204\nUINavigationBar\t207\n12.2  加入额外的UIViewController\t211\n12.3  UINavigationController的导航功能\t217\n将视图控制对象压入栈\t217\n视图控制对象之间的数据传递\t219\n视图的显示和消失\t221\n12.4  练习：数字键盘（Number Pad）\t221\n第13章  相机\t223\n13.1  通过UIImageView显示图片\t223\n通过UIImagePickerController拍摄照片\t226\nImageStore\t231\nNSDictionary\t232\n创建并使用键\t234\n隐藏键盘\t237\n13.2  练习：删除图片\t238\n13.2  深入：摄像\t238\n第14章  UIPopoverController与模态视图控制对象\t241\n14.1  将Homepwner改写为通用应用\t242\n14.2  UIPopoverController\t244\n14.3  模态视图控制对象\t246\n关闭模态视图控制对象\t249\n模式视图控制对象的样式\t250\n编写视图控制对象的委托协议\t252\n模态视图控制对象的过渡动画\t254\n第15章  保存、读取与多任务处理\t257\n15.1  应用沙盒\t257\n获取文件路径\t258\n15.2  固化\t260\n对象的固化\t260\n对象的解固\t262\n15.3  应用状态、状态切换与多任务处理\t265\n15.4  通过NSData保存数据\t269\n15.5  再谈内存过低警告\t271\n15.6  “模型-视图-控制器-存储”设计模式\t272\n15.7  练习：为Whereami增加固化功能\t272\n15.8  深入：应用状态的切换\t272\n15.9  深入：文件系统的读取和写入\t273\n15.10  深入：程序包\t276\n第16章  创建UITableViewCell子类\t279\n16.1  创建HomepwnerItemCell\t280\n创建子视图\t281\n子视图的布局\t282\n使用UITableViewCell子类对象\t283\n16.2  处理图片\t284\n16.3  练习：辅助指示视图\t289\n16.4  练习：缩小原图\t289\n第17章  Core Data\t291\n17.1  对象-关系映射\t291\n17.2  用Core Data重写PossessionStore的数据保存功能\t291\n模型文件\t292\nNSManagedObject与NSManagedObject子类\t297\n更新PossessionStore\t301\n为Homepwner增加AssetType功能\t307\n17.3  再谈SQL\t311\n17.4  各种保存机制的优缺点\t314\n17.5  练习：增加AssetType对象\t315\n17.6  练习：AssetType对象的iPad界面\t315\n第18章  本地化\t317\n18.1  通过NSLocale实现国际化\t318\n18.2  资源的本地化\t319\n18.3  NSLocalizedString与字符串对照表\t322\n18.4  练习：增加一套本地化资源\t325\n18.5  深入：NSBundle在国际化中的作用\t325\n第19章  设置\t327\n19.1  更新Whereami\t327\n19.2  NSUserDefaults\t329\n19.3  深入：“设置”应用\t331\n第20章  触摸事件与UIResponder\t333\n20.1  触摸事件\t334\n20.2  创建TouchTracker应用\t335\n20.3  处理触摸事件并创建线条对象\t337\n20.4  响应对象链\t340\n20.5  练习：保存和读取\t341\n20.6  练习：圆圈\t341\n20.7  深入学习：UIControl\t341\n第21章  Instruments\t343\n21.1  静态分析器\t343\n21.2  Instruments\t345\n21.3  Allocations组件\t345\nAllocations组件的设置选项\t350\n内存堆快照分析\t352\nTime Profiler组件\t353\n21.3  Xcode方案\t355\n创建新方案\t357\n21.4  构建设置\t359\n第22章  Core Animation Layer\t363\n22.1  层与视图的关系\t363\n22.2  创建CALayer对象\t364\n22.3  层的显示内容\t367\n22.4  隐式可动画属性\t369\n22.5  深入：通过代码生成显示内容\t371\n22.6  深入：层、位图与上下文\t372\n22.7  练习：动态生成层的显示内容\t374\n第23章  通过CAAnimation控制动画\t375\n23.1  动画对象\t375\n23.2  通过CABasicAnimation实现旋转动画\t378\n速度控制函数\t381\n动画结束后的处理\t382\n23.3  通过CAKeyframeAnimation实现弹跳动画\t383\n23.4  练习：更多动画效果\t384\n23.5  深入：外观层和模型层\t384\n第24章  Block对象与范畴\t387\n24.1  为TouchDrawView上色\t387\n24.2  Block对象\t389\nBlock对象与变量\t389\n捕获变量\t393\n通过其他内建的方法使用Block对象\t396\n通过Block对象保持代码的短小精练\t396\n24.3  范畴\t397\n24.4  深入学习：内存管理与Block对象\t400\n24.5  深入学习：比较多种回调机制实现途径的优缺点\t403\n第15章  Web服务与UIWebView\t405\n25.1  Web服务\t406\n编写Nerdfeed\t407\n从指定的URL获取数据\t408\n使用NSURLConnection\t410\n解析XML数据\t412\n日志输出技巧\t423\n25.2  UIWebView\t424\n25.3  深入学习：NSXMLParser\t426\n25.4  深入学习：HTTP请求主体\t427\n25.5  深入学习：认证信息\t429\n25.6  练习：解析并显示更多数据\t430\n25.7  练习：加强UIWebView\t430\n第26章  UISplitViewController\t431\n26.1  在Nerdfeed中使用UISplitViewController\t432\n26.2  主、从视图控制对象间的通信\t436\n26.3  在竖排模式下显示主视图控制对象\t442\n26.4  将Nerdfeed改写为通用应用\t445\n第27章  多媒体播放与后台运行\t449\n27.1  创建MediaPlayer应用\t449\n27.2  系统声音\t452\n注册系统声音\t452\n播放系统声音\t453\n27.3  播放压缩格式的音频文件\t454\n27.4  播放视频文件\t455\nMPMoviePlayerViewController\t457\n视频文件的预读\t458\n27.5  后台运行\t458\n后台运行规则\t459\n其他形式的后台运行\t460\n27.6  底层API\t462\n27.7  练习：录音\t462\n第15章  Bonjour与Web服务端\t463\n28.1  Bonjour\t463\n创建CocoaServer\t464\n发布Bonjour服务\t467\n通过Bonjour查找服务\t469\n28.2  HTTP通信\t473\n用Objective-C编写Web服务端\t473\n获取服务端的网络地址信息\t474\n字节序\t475\n创建服务请求\t475\n接收Web请求\t477\n28.3  深入学习：TXTRecords\t479\n第29章  推送通知与网络编程\t481\n29.1  设置客户端，为接收推送通知做准备\t482\n注册客户端\t482\n创建并设置针对推送通知的provisioning profile\t483\n29.2  投递推送通知\t486\n向provider发送设备token\t486\n29.3  发送推送通知\t488\n通过NSStream和Apple服务器创建网络连接\t488\n通过NSStream建立网络连接\t489\n为Apple服务器提供数据\t493\n处理投递错误\t497\n再谈针对流连接的数据读取\t498\n29.4  几种额外的客户端通知处理机制\t498\n声音和图标标记\t499\n通过推送通知传送自定义数据\t500\n29.5  正式的通知服务器以及其他发布事宜\t502\n29.6  深入学习：反馈服务\t502\n第30章  后记\t503\n30.1  接下来做什么\t503\n30.2  结束语\t503\n索引\t505","pages":"544","images":{"small":"http:\/\/img5.douban.com\/spic\/s9042517.jpg","large":"http:\/\/img5.douban.com\/lpic\/s9042517.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s9042517.jpg"},"alt":"http:\/\/book.douban.com\/subject\/10483197\/","id":"10483197","publisher":"华中科技大学出版社","isbn10":"7560976972","isbn13":"9787560976976","title":"iOS编程","url":"http:\/\/api.douban.com\/v2\/book\/10483197","alt_title":"iOS Programming: The Big Nerd Ranch Guide (2nd Edition)","author_intro":"Joe Conway是Big Nerd Ranch的资深教师，自iOS平台发布以来一直从事相关的咨询服务。Joe毕业于美国威斯康辛大学，在Mac OS X早期即开始编写Objective-C和Cocoa代码。他编写了Big Nerd Ranch的“iOS新手培训课程”教材。该教材广受好评，是本书的原型。\nAaron Hillegass曾就职于NeXT公司和苹果公司，目前在Big Nerd Ranch教授iOS编程课程。Aaron在NeXT时编写了第一本OpenStep教材（OpenStep是Cocoa的前身）。本书以Big Nerd Ranch的教学课程为基础，涵盖了近20年OpenStep和Cocoa的开发成果。","summary":"本书针对Xcode 4编写，涵盖了开发iOS应用所需知道的方方面面。从Objective-C基础知识到新增加的语言特性；从AppKit库到常见的Cocoa设计模式；从Xcode技巧到Instruments，等等。如果读者刚接触iOS编程，那么阅读本书的第一章和第二章能快让你速入门。如果读者已经 有大量的iOS编程经验，那么通读本书可以拾遗补缺。无论读者是开发新的应用，还是为应用增加新功能，十之八九能在书中找到答案或是解决思路。\n除了内容全，本书的另一个特点是教读者以正确的方法解决问题。Objective-C的习惯约定有哪些（例如命名约定，内存管理约定）？创建子类时如何处理初始化方法？Cocoa的常见设计模式有哪些？如何选择数据保存方法？等等。所有这些问题，如果读者自己摸索，自己查阅散落于各处文档的知识点，难免费时费力。本书已经将这些知识整理、归纳并清楚地呈现在读者面前。\n目前，iOS开发针对的设备有iPhone、iPod touch和iPad。因为使用的是同一个体系，所以本书介绍的绝大部分内容均可通用。对于有差异的部分（例如iPad界面），本书也做了一定的介绍。\n此外，作者在编写本书时使用的是当时最新的iOS SDK，其中包括4.1版本的Xcode。虽然iOS SDK一直在升级，但在本书译者翻译完全书之际，绝大部分和SDK有关的内容都是有效的。","price":"88.00元"},{"rating":{"max":10,"numRaters":152,"average":"8.3","min":0},"subtitle":"","author":["Mark Lutz"],"pubdate":"2006","tags":[{"count":213,"name":"python","title":"python"},{"count":72,"name":"Programming","title":"Programming"},{"count":57,"name":"编程","title":"编程"},{"count":35,"name":"计算机","title":"计算机"},{"count":20,"name":"Python","title":"Python"},{"count":17,"name":"web开发","title":"web开发"},{"count":17,"name":"程序设计语言","title":"程序设计语言"},{"count":15,"name":"技术","title":"技术"}],"origin_title":"","image":"http:\/\/img5.douban.com\/mpic\/s2396946.jpg","binding":"","translator":[],"catalog":"","pages":"1596","images":{"small":"http:\/\/img5.douban.com\/spic\/s2396946.jpg","large":"http:\/\/img5.douban.com\/lpic\/s2396946.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s2396946.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1915868\/","id":"1915868","publisher":"东南大学出版社","isbn10":"7564105704","isbn13":"9787564105709","title":"Python编程（第三版·英文影印版）","url":"http:\/\/api.douban.com\/v2\/book\/1915868","alt_title":"","author_intro":"","summary":"《Python编程 第三版》已经成为Python用户的行业标准，且更加完善。第三版进行的更新反映了当前的最佳实践以及在语言的最新版本Python 2.5中引入的大量改变。\n无论是新手还是老手，你都会发现这本经过彻底更新的书确实名副其实，它教给你编写代码的正确途径。它以清晰而简练的方式解释了Python语言的语法以及编程技巧，并辅以大量例子阐明正确的使用方法和通用特性。通过阅读这本全面的指南，你将学习到如何将Python运用到实际问题中，例如：\n·用户图形界面编程\n·并行处理\n·网络应用程序\n·Internet脚本编程\n·数据库管理\n从深入讨论核心概念开始，再到完整的程序，《Python编程 第三版》逐一覆盖这些领域。书中确有大型的程序示例，但只在你已经掌握了足够的知识，能够理解技术和代码后才会出现。\n在学习过程中，你也会学到如何在实际规模的程序中使用Python——诸如面向对象编程和代码重用概念皆是贯穿全书的副题。如果你对Python 程序设计感兴趣，就需要这本O'Reilly经典书籍长伴你的左右。实践中的建议、代码的片断和程序设计模式，这些财富都可以在日常生活中得到应用——使你的生活更轻松更高效。","price":"138.00元"},{"rating":{"max":10,"numRaters":120,"average":"8.3","min":0},"subtitle":"编写卓越的代码","author":["（美）古德利弗（Goodliffe, P.）著"],"pubdate":"2008年","tags":[{"count":97,"name":"编程","title":"编程"},{"count":72,"name":"程序设计","title":"程序设计"},{"count":46,"name":"编程艺术","title":"编程艺术"},{"count":36,"name":"软件工程","title":"软件工程"},{"count":29,"name":"软件开发","title":"软件开发"},{"count":29,"name":"编程匠艺","title":"编程匠艺"},{"count":26,"name":"计算机","title":"计算机"},{"count":26,"name":"Programming","title":"Programming"}],"origin_title":"","image":"http:\/\/img5.douban.com\/mpic\/s3432749.jpg","binding":"平装","translator":["韩江，陈玉译"],"catalog":"","pages":"582 页","images":{"small":"http:\/\/img5.douban.com\/spic\/s3432749.jpg","large":"http:\/\/img5.douban.com\/lpic\/s3432749.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s3432749.jpg"},"alt":"http:\/\/book.douban.com\/subject\/3210669\/","id":"3210669","publisher":"电子工业出版社","isbn10":"7121069806","isbn13":"9787121069802","title":"编程匠艺","url":"http:\/\/api.douban.com\/v2\/book\/3210669","alt_title":"","author_intro":"Pete Goodliffe是一位软件开发专家，他在软件“食物链”上从未驻足不前。他在各种各样的项目中使用过许多种语言。他还在教授和指导程序员方面有着丰富的经验，并且常年为ACCU的C Vu杂志（www.accu.org）撰写栏目“编程的职业化”。Pete痴迷于编写出色的、没有错误的代码，这使得他有更多的时间与自己的孩子共度好时光","summary":"内容介绍：\n如果你可以编写出合格的代码，但是想更进一步、创作出组织良好而且易于理解的代码，并希望成为一名真正的编程专家或提高现有的职业技能，那么《编程匠艺—— 编写卓越的代码》都会为你给出答案。本书的内容遍及编程的各个要素，如代码风格、变量命名、错误处理和安全性等。此外，本书还对一些更广泛的编程问题进行了探讨，如有效的团队合作、开发过程和文档编写，等等。本书各章的末尾均提供一些思考问题，这些问题回顾了各章中的一些关键概念，可以促使你像专家一样思考，从而使本书成...","price":"79.00元"},{"rating":{"max":10,"numRaters":130,"average":"8.2","min":0},"subtitle":"拥抱变化","author":["贝克"],"pubdate":"2006-5","tags":[{"count":112,"name":"极限编程","title":"极限编程"},{"count":84,"name":"软件工程","title":"软件工程"},{"count":74,"name":"XP","title":"XP"},{"count":45,"name":"敏捷","title":"敏捷"},{"count":43,"name":"敏捷开发","title":"敏捷开发"},{"count":37,"name":"软件开发","title":"软件开发"},{"count":34,"name":"编程","title":"编程"},{"count":31,"name":"项目管理","title":"项目管理"}],"origin_title":"Extreme Programming Explained","image":"http:\/\/img5.douban.com\/mpic\/s24501447.jpg","binding":"","translator":["雷剑文","陈振冲, 李明树"],"catalog":"","pages":"301","images":{"small":"http:\/\/img5.douban.com\/spic\/s24501447.jpg","large":"http:\/\/img5.douban.com\/lpic\/s24501447.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s24501447.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1790225\/","id":"1790225","publisher":"电子","isbn10":"7121025299","isbn13":"9787121025297","title":"解析极限编程（第二版）（中英文对照）","url":"http:\/\/api.douban.com\/v2\/book\/1790225","alt_title":"Extreme Programming Explained","author_intro":"Kent Beck应是XP的绝对大师了.","summary":"本书是经典之作。作者在书中提出了一些想法，诸如让开发者为自己的代码写自动化测试，让整个团队每周做计划，因为这些当时很激进的改进小团队开发的想法，这本书获了奖。五年来许多东西改变了，完全重写的第二版将XP的范围扩展到任何大小的团队，建议了基于以下几点的持续改进流程：与卓越软件开发一致的五个核心价值观：11个原则将这些价值观付诸行动；13个基本实践和11个扩展实践帮助你推动开发超越当前的业务和技术决策；通过建立富有信息的共享工作空间来改进团队协作。\n　　无论你是有一个已经和客户紧密联系在一起的小团队，还是有一个在大组织或跨国组织中的大团队，你都会在中发现如下的思想去挑战、启发和鼓励你及你的团队成员去切实改进你们的软件开发。\n\n　　极限编程，通常称为XP，是一种针对业务和软件开发的规则，其作用在于将两者的力量集中在共同的、可以达到的目标上，使XP团队以可持续的步调生产优质的软件。本书是在《解析极限编程》第一版面世的5年之后，作者重新考虑，整理和重构XP的基础上写成的，也是作者不断参与软件开发项目的心路历程和对XP的许多新的深刻理解。\n　　本书共分两部分。第1部分包括第1章至第16章，阐述了实现XP过程的方方面面；第2部分包括第17章至25章，内容着重于对XP的理解上升到哲学的高度来看待XP的生命力。\n　　本书配有中英文对照，语言通畅、富有实用性和可读性，适合于软件开发人员、软件项目管理人员、软件工程研究人员，以及广大电脑爱好者阅读并领略英文原文的风采。","price":"39.00元"},{"rating":{"max":10,"numRaters":222,"average":"8.1","min":0},"subtitle":"","author":["埃克尔(美)"],"pubdate":"2000-01","tags":[{"count":165,"name":"C++","title":"C++"},{"count":49,"name":"计算机","title":"计算机"},{"count":48,"name":"编程","title":"编程"},{"count":39,"name":"编程思想","title":"编程思想"},{"count":19,"name":"C++编程思想","title":"C++编程思想"},{"count":19,"name":"programming","title":"programming"},{"count":19,"name":"经典","title":"经典"},{"count":18,"name":"软件开发","title":"软件开发"}],"origin_title":"","image":"http:\/\/img5.douban.com\/mpic\/s9142918.jpg","binding":"平装","translator":["刘宗田\/等"],"catalog":"目 录\n译者序\n前言\n第1章 对象的演化\n1.1基本概念\n1.1.1对象：特性十行为\n1.1.2继承：类型关系\n1.1.3多态性\n1.1.4操作概念：OOP程序像什么\n1.2为什么C＋＋会成功\n1.2.1较好的C\n1.2.2采用渐进的学习方式\n1.2.3运行效率\n1.2.4系统更容易表达和理解\n1.2.5“库”使你事半功倍\n1.2.6错误处理\n1.2.7大程序设计\n1.3方法学介绍\n1.3.1复杂性\n1.3.2内部原则\n1.3.3外部原则\n1.3.4对象设计的五个阶段\n1.3.5方法承诺什么\n1.3.6方法应当提供什么\n1.4起草：最小的方法\n1.4.1前提\n1.4.2高概念\n1.4.3论述（treatment）\n1.4.4结构化\n1.4.5开发\n1.4.6重写\n1.4.7逻辑\n1.5其他方法\n1.5.1Booch\n1.5.2责任驱动的设计（RDD）\n1.5.3对象建模技术（OMT）\n1.6为向OOP转变而采取的策略\n1.6.1逐步进入OOP\n1.6.2管理障碍\n1.7小结\n第2章 数据抽象\n2.1声明与定义\n2.2一个袖珍C库\n2.3放在一起：项目创建工具\n2.4什么是非正常\n2.5基本对象\n2.6什么是对象\n2.7抽象数据类型\n2.8对象细节\n2.9头文件形式\n2.10嵌套结构\n2.11小结\n2.12练习\n第3章 隐藏实现\n3.1设置限制\n3.2C＋＋的存取控制\n3.3友元\n3.3.1嵌套友元\n3.3.2它是纯的吗\n3.4对象布局\n3.5类\n3.5.1用存取控制来修改stash\n3.5.2用存取控制来修改stack\n3.6句柄类（handleclasses）\n3.6.1可见的实现部分\n3.6.2减少重复编译\n3.7小结\n3.8练习\n第4章 初始化与清除\n4.1用构造函数确保初始化\n4.2用析构函数确保清除\n4.3清除定义块\n4.3.1for循环\n4.3.2空间分配\n4.4含有构造函数和析构函数的stash\n4.5含有构造函数和析构函数的stack\n4.6集合初始化\n4.7缺省构造函数\n4.8小结\n4.9练习\n第5章 函数重载与缺省参数\n5.1范围分解\n5.1.1用返回值重载\n5.1.2安全类型连接\n5.2重载的例子\n5.3缺省参数\n5.4小结\n5.5练习\n第6章 输入输出流介绍\n6.1为什么要用输入输出流\n6.2解决输入输出流问题\n6.2.1预先了解操作符重载\n6.2.2插入符与提取符\n6.2.3通常用法\n6.2.4面向行的输入\n6.3文件输入输出流\n6.4输入输出流缓冲\n6.5在输入输出流中查找\n6.6strstreams\n6.6.1为用户分配的存储\n6.6.2自动存储分配\n6.7输出流格式化\n6.7.1内部格式化数据\n6.7.2例子\n6.8格式化操纵算子\n6.9建立操纵算子\n6.10输入输出流实例\n6.10.1代码生成\n6.10.2一个简单的数据记录\n6.11小结\n6.12练习\n第7章 常量\n7.1值替代\n7.1.1头文件里的const\n7.1.2const的安全性\n7.1.3集合\n7.1.4与C语言的区别\n7.2指针\n7.2.1指向const的指针\n7.2.2const指针\n7.2.3赋值和类型检查\n7.3函数参数和返回值\n7.3.1传递const值\n7.3.2返回const值\n7.3.3传递和返回地址\n7.4类\n7.4.1类里的const和enum\n7.4.2编译期间类里的常量\n7.4.3const对象和成员函数\n7.4.4只读存储能力\n7.5可变的（volatile）\n7.6小结\n7.7练习\n第8章 内联函数\n8.1预处理器的缺陷\n8.2内联函数\n8.2.1类内部的内联函数\n8.2.2存取函数\n8.3内联函数和编译器\n8.3.1局限性\n8.3.2赋值顺序\n8.3.3在构造函数和析构函数里隐藏行为\n8.4减少混乱\n8.5预处理器的特点\n8.6改进的错误检查\n8.7小结\n8.8练习\n第9章 命名控制\n9.1来自C语言中的静态成员\n9.1.1函数内部的静态变量\n9.1.2控制连接\n9.1.3其他的存储类型指定符\n9.2名字空间\n9.2.1产生一个名字空间\n9.2.2使用名字空间\n9.3C＋＋中的静态成员\n9.3.1定义静态数据成员的存储\n9.3.2嵌套类和局部类\n9.3.3静态成员函数\n9.4静态初始化的依赖因素\n9.5转换连接指定\n9.6小结\n9.7练习\n第10章 引用和拷贝构造函数\n10.1C＋＋中的指针\n10.2C＋十中的引用\n10.2.1函数中的引用\n10.2.2参数传递准则\n10.3拷贝构造函数\n10.3.1传值方式传递和返回\n10.3.2拷贝构造函数\n10.3.3缺省拷贝构造函数\n10.3.4拷贝构造函数方法的选择\n10.4指向成员的指针（简称成员指针）\n10.5小结\n10.6练习\n第11章 运算符重载\n11.1警告和确信\n11.2语法\n11.3可重载的运算符\n11.3.1一元运算符\n11.3.2二元运算符\n11.3.3参数和返回值\n11.3.4与众不同的运算符\n11.3.5不能重载的运算符\n11.4非成员运算符\n11.5重载赋值符\n11.6自动类型转换\n11.6.1构造函数转换\n11.6.2运算符转换\n11.6.3一个理想的例子：strings\n11.6.4自动类型转换的缺陷\n11.7小结\n11.8练习\n第12章 动态对象创建\n12.1对象创建\n12.1.1C从堆中获取存储单元的方法\n12.1.2运算符new\n12.1.3运算符delete\n12.1.4一个简单的例子\n12.1.5内存管理的开销\n12.2重新设计前面的例子\n12.2.1仅从堆中创建string类\n12.2.2stash指针\n12.2.3stack例子\n12.3用于数组的new和delete\n12.4用完内存\n12.5重载new和de1ete\n12.5.1重载全局new和delete\n12.5.2为一个类重载new和delete\n12.5.3为数组重载new和delete\n12.5.4构造函数调用\n12.5.5对象放置\n12.6小结\n12.7练习\n第13章 继承和组合\n13.1组合语法\n13.2继承语法\n13.3构造函数的初始化表达式表\n13.3.1成员对象初始化\n13.3.2在初始化表达式表中的内置类型\n13.4组合和继承的联合\n13.4.1构造函数和析构函数的次序\n13.4.2名字隐藏\n13.4.3非自动继承的函数\n13.5组合与继承的选择\n13.5.1子类型设置\n13.5.2专门化\n13.5.3私有继承\n13.6保护\n13.7多重继承\n13.8渐增式开发\n13.9向上映射\n13.9.1为什么“向上映射”\n13.9.2组合与继承\n13.9.3指针和引用的向上映射\n13.9.4危机\n13.10小结\n13.11练习\n第14章 多态和虚函数\n14.1向上映射\n14.2问题\n14.3虚函数\n14.4C＋＋如何实现晚捆绑\n14.4.1存放类型信息\n14.4.2对虚函数作图\n14.4.3撩开面纱\n14.4.4安装vpointer\n14.4.5对象是不同的\n14.5为什么需要虚函数\n14.6抽象基类和纯虚函数\n14.7继承和VTABLE\n14.8虚函数和构造函数\n14.8.1构造函数调用次序\n14.8.2虚函数在构造函数中的行为\n14.9析构函数和虚拟析构函数\n14.10小结\n14.11练习\n第15章 模板和包容器类\n15.1包容器和循环子\n15.2模板综述\n15.2.1C方法\n15.2.2Smalltalk方法\n15.2.3模板方法\n15.3模板的语法\n15.3.1非内联函数定义\n15.3.2栈模板（thestackasatemplate）\n15.3.3模板中的常量\n15.4stash&stack模板\n15.4.1所有权问题\n15.4.2stash模板\n15.4.3stack模板\n15.5字符串和整型\n15.5.1栈上的字符串\n15.5.2整型\n15.6向量\n15.6.1“无穷”向量\n15.6.2集合\n15.6.3关联数组\n15.7模板和继承\n15.7.1设计和效率\n15.7.2防止模板膨胀\n15.8多态性和包容器\n15.9包容器类型\n15.10函数模板\n15.10.1存储分配系统\n15.10.2为tstack提供函数\n15.10.3成员函数模板\n15.11控制实例\n15.12小结\n15.13练习\n第16章 多重继承\n16.1概述\n16.2子对象重叠\n16.3向上映射的二义性\n16.4虚基类\n16.4.1“最晚辈派生”类和虚基初始化\n16.4.2使用缺省构造函数向虚基“警告”\n16.5开销\n16.6向上映射\n16.7避免MI\n16.8修复接口\n16.9小结\n16.10练习\n第17章 异常处理\n17.1C语言的出错处理\n17.2抛出异常\n17.3异常捕获\n17.3.1try块\n17.3.2异常处理器\n17.3.3异常规格说明\n17.3.4更好的异常规格说明\n17.3.5捕获所有异常\n17.3.6异常的重新抛出\n17.3.7未被捕获的异常\n17.4清除\n17.5构造函数\n17.6异常匹配\n17.7标准异常\n17.8含有异常的程序设计\n17.8.1何时避免异常\n17.8.2异常的典型使用\n17.9开销\n17.10小结\n17.11练习\n第18章 运行时类型识别\n18.1例子――shape\n18.2什么是RTTI\n18.3语法细节\n18.3.1对于内部类型的typeid（）\n18.3.2产生合适的类型名字\n18.3.3非多态类型\n18.3.4映射到中间级\n18.3.5void指针\n18.3.6 用模板来使用RTTI\n18.4引用\n18.5多重继承\n18.6合理使用RTTI\n18.7RTTI的机制及花费\n18.8创建我们自己的RTTI\n18.9新的映射语法\n18.9.1staticcast\n18.9.2constcast\n18.9.3reinterpret＿cast\n18.10小结\n18.11练习\n附录A 其他性能\n附录B 编程准则\n附录C 模拟虚构造函数\n","pages":"421","images":{"small":"http:\/\/img5.douban.com\/spic\/s9142918.jpg","large":"http:\/\/img5.douban.com\/lpic\/s9142918.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s9142918.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1057170\/","id":"1057170","publisher":"机械工业出版社","isbn10":"7111071166","isbn13":"9787111071167","title":"C++编程思想","url":"http:\/\/api.douban.com\/v2\/book\/1057170","alt_title":"","author_intro":"","summary":"\n      ","price":"39.00"},{"rating":{"max":10,"numRaters":95,"average":"9.5","min":0},"subtitle":"进程间通信","author":["W.Richard Stevens"],"pubdate":"2009-11","tags":[{"count":177,"name":"UNIX","title":"UNIX"},{"count":170,"name":"网络编程","title":"网络编程"},{"count":55,"name":"网络","title":"网络"},{"count":41,"name":"Linux","title":"Linux"},{"count":40,"name":"计算机","title":"计算机"},{"count":30,"name":"编程","title":"编程"},{"count":28,"name":"Programming","title":"Programming"},{"count":25,"name":"经典","title":"经典"}],"origin_title":"UNIX Network Programming, Volume 2: Interprocess Communications (2nd Edition)","image":"http:\/\/img5.douban.com\/mpic\/s6096698.jpg","binding":"平装","translator":[],"catalog":"part ⅰ introduction\nchapter 1 introduction\n1.1 introduction\n1.2 processes, threads, and the sharing of information\n1.3 persistence of ipc objects\n1.4 name spaces\n1.5 effect of fork, exec, and exit on ipc objects\n1.6 error handling: wrapper functions\n1.7 unix standards\n1.8 road map to ipc examples in the text\n1.9 summary\nchapter 2 posix ipc\n2.1 introduction\n2.2 ipc names\n2.3 creating and opening ipc channels\n2.4 ipc permissions\n2.5 summary\nchapter 3 system v ipc\n3.1 introduction\n3.2 key_t keys and ft:ok function\n. 3.3 ipc_perm structure\n3.4 creating and opening ipc channels\n3.5 ipc permissions\n3.6 identifier reuse\n3.7 ipcs and ~porto programs\n3.8 kernel limits\n3.9 summary\npart 2 message passing\npart 3 synchronization\npart 2 shared memory\npart 2 remote procedure calls\nepilogue\nappendix a\nappendix b\nappendix c\nbibliography\nindex","pages":"561","images":{"small":"http:\/\/img5.douban.com\/spic\/s6096698.jpg","large":"http:\/\/img5.douban.com\/lpic\/s6096698.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s6096698.jpg"},"alt":"http:\/\/book.douban.com\/subject\/4118577\/","id":"4118577","publisher":"人民邮电出版社","isbn10":"7115215111","isbn13":"9787115215116","title":"UNIX网络编程 卷2","url":"http:\/\/api.douban.com\/v2\/book\/4118577","alt_title":"UNIX Network Programming, Volume 2: Interprocess Communications (2nd Edition)","author_intro":"W.Richarqd Stevens，国际知名的LINIX和网络专家，备受赞誉的技术作家。他1951年2月5日出生于赞比亚，后随父母回到美国。中学时就读于弗吉尼亚菲什伯恩军事学校，1973年获得密歇根大学航空和航天工程学士学位。1975年至1982年，他在亚利桑那州图森市的基特峰国家天文合从事计算机编程工作，业余时间喜爱飞行运动，做过兼职飞行教练。这期间他分别在1978年和1982年获得亚利桑那大学系统工程硕士和博士学位。此后他去康涅狄格州纽黑文的健康系统国际公司任主管计算机服务的副总裁。1990年他回到图森，从事专业技术写作和咨询工作。写下了多种经典的传世之作，包括《TCP\/IP详解》（三卷）、《UNIX环境高级编程》和《UNIX网络编程》（两卷）。Steverls于1999年9月1日去世，年仅48岁。2000年他被国际权威机构USENIX追授“终身成就奖”。","summary":"《UNIX网络编程 卷2:进程间通信(英文版·第2版)》是一部UNIX网络编程的经典之作。进程间通信(IPC)几乎是所有Unix程序性能的关键，理解IPC也是理解如何开发不同主机间网络应用程序的必要条件。《UNIX网络编程 卷2:进程间通信(英文版·第2版)》从对Posix IPC和System V IPC的内部结构开始讨论，全面深入地介绍了4种IPC形式：消息传递(管道、FIFO、消息队列)、同步(互斥锁、条件变量、读写锁、文件与记录锁、信号量)、共享内存(匿名共享内存、具名共享内存)及远程过程调用(Solaris 门、Sun RPC)。附录中给出了测量各种IPC形式性能的方法。\n《UNIX网络编程 卷2:进程间通信(英文版·第2版)》内容详尽且具权威性，几乎每章都提供精选的习题，并提供了部分习题的答案，是网络研究和开发人员理想的参考书。","price":"89.00元"},{"rating":{"max":10,"numRaters":127,"average":"7.4","min":0},"subtitle":"运用ACE和模式消除复杂性","author":["[美]Douglas C.Schmidt，Stephen D.Huston  著，於春景  译"],"pubdate":"2004-6-1","tags":[{"count":154,"name":"C++","title":"C++"},{"count":132,"name":"网络编程","title":"网络编程"},{"count":63,"name":"ace","title":"ace"},{"count":33,"name":"编程","title":"编程"},{"count":28,"name":"设计模式","title":"设计模式"},{"count":23,"name":"网络","title":"网络"},{"count":22,"name":"Network","title":"Network"},{"count":19,"name":"计算机","title":"计算机"}],"origin_title":"C++ Network Programming, Volume I: Mastering Complexity with ACE and Patterns","image":"http:\/\/img3.douban.com\/mpic\/s1122522.jpg","binding":"","translator":[],"catalog":"","pages":"303","images":{"small":"http:\/\/img3.douban.com\/spic\/s1122522.jpg","large":"http:\/\/img3.douban.com\/lpic\/s1122522.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s1122522.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1165791\/","id":"1165791","publisher":"华中科技","isbn10":"7560930662","isbn13":"9787560930664","title":"C++网络编程（卷1）","url":"http:\/\/api.douban.com\/v2\/book\/1165791","alt_title":"C++ Network Programming, Volume I: Mastering Complexity with ACE and Patterns","author_intro":"","summary":"","price":"35.00元"},{"rating":{"max":10,"numRaters":149,"average":"8.0","min":0},"subtitle":"拥抱变化","author":["[美] Kent Beck"],"pubdate":"2002-6","tags":[{"count":105,"name":"敏捷开发","title":"敏捷开发"},{"count":69,"name":"软件工程","title":"软件工程"},{"count":51,"name":"XP","title":"XP"},{"count":35,"name":"软件开发","title":"软件开发"},{"count":30,"name":"agile","title":"agile"},{"count":28,"name":"项目管理","title":"项目管理"},{"count":25,"name":"计算机","title":"计算机"},{"count":20,"name":"编程","title":"编程"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s1302282.jpg","binding":"平装16开","translator":["唐东铭"],"catalog":"第1部分 问题\n第1章 风险：基本的问题\n第2章 开发情节\n第3章 软件开发的经济学\n……\n第2部分 解决方案\n第10章 简短概述\n第11章 这如何奏效\n第12章 管理策略\n……\n第3部分 实现XP\n第19章 采用XP\n第20章 改进XP\n第21章 理想的XP项目的生命期\n……\n附录A 参考书目与注释\n附录B 词汇表","pages":"190","images":{"small":"http:\/\/img3.douban.com\/spic\/s1302282.jpg","large":"http:\/\/img3.douban.com\/lpic\/s1302282.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s1302282.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1099376\/","id":"1099376","publisher":"人民邮电出版社","isbn10":"711510378X","isbn13":"9787115103789","title":"解析极限编程","url":"http:\/\/api.douban.com\/v2\/book\/1099376","alt_title":"","author_intro":"","summary":"极限编程（XP）是一种经历过实践考验的轻量级软件开发方法学。《解析极限编程》是XP宣言，也是第一本有关XP的图书。\n全书共分三部分，第1部分包括第1章至第9章，通过讨论创建新的软件开发规范中要解决的问题的不同层面来设定极限编程的前提。第2部分包括第10章至第18章，内容着重于如何将第一部分中的抽象概念转化为具体方法论的实践，这部分不会确切地说明如何执行这些实践，而是要讨论它们的大体结构，同时提供了一套指导性的准则和策略。第3部分包括第19章至第27章，该部分讨论了如何将上一部分中的策略确切地付诸实践。","price":"29.00元"},{"rating":{"max":10,"numRaters":110,"average":"8.6","min":0},"subtitle":"Big Nerd Ranch入门经典","author":["[美] Aaron Hillegass"],"pubdate":"2012-9-25","tags":[{"count":154,"name":"Objectiv-C","title":"Objectiv-C"},{"count":114,"name":"iOS","title":"iOS"},{"count":90,"name":"编程","title":"编程"},{"count":49,"name":"入门","title":"入门"},{"count":36,"name":"Objective-C","title":"Objective-C"},{"count":22,"name":"基础","title":"基础"},{"count":19,"name":"iPhone","title":"iPhone"},{"count":17,"name":"Big_Nerd_Ranch_Guide","title":"Big_Nerd_Ranch_Guide"}],"origin_title":"Objective-C Programming: The Big Nerd Ranch Guide","image":"http:\/\/img3.douban.com\/mpic\/s22704633.jpg","binding":"平装","translator":["夏伟频","李骏"],"catalog":"第1部分  入门\t1\n第1章  读者与本书\t3\n1.1  C与Objective-C\t3\n1.2  主要内容及阅读方式\t4\n1.3  程序员要走的道路\t4\n第2章  第一个程序\t7\n2.1  安装Apple开发工具软件\t7\n2.2  Xcode入门\t7\n2.3  从哪里开始编写代码\t9\n2.4  如何运行程序\t13\n2.5  程序是如何产生的\t14\n2.6  不要半途而废\t15\n第2部分  如何编程\t17\n第3章  变量与类型\t19\n3.1  类型\t19\n3.2  使用变量的程序\t20\n3.3  练习\t22\n第4章  if和else\t23\n4.1  布尔变量\t24\n4.2  else if\t25\n4.3  深入学习：条件运算符（三元运算符）\t25\n4.4  练习\t26\n第5章  函数\t27\n5.1  应该在何时使用函数\t27\n5.2  如何编写并使用函数\t27\n5.3  函数间是如何协同工作的\t30\n5.4  局部变量、帧和栈\t32\n5.5  递归\t34\n5.6  通过调试器查看帧\t35\n5.7  return\t37\n5.8  全局变量与静态变量\t39\n5.9  练习\t40\n第6章  数字\t41\n6.1  printf()\t41\n6.2  整数\t42\n6.3  浮点数\t46\n6.4  练习\t47\n第7章  循环\t49\n7.1  while循环\t49\n7.2  for循环\t50\n7.3  break\t51\n7.4  continue\t52\n7.5  do-while循环\t53\n7.6  练习\t54\n第8章  地址与指针\t55\n8.1  获取地址\t55\n8.2  用指针保存地址\t56\n8.3  通过地址访问数据\t57\n8.4  不同类型的数据所占用的字节大小\t57\n8.5  NULL\t58\n8.6  指针声明的代码规范\t59\n8.7  练习\t59\n第9章  通过引用传递\t61\n9.1  编写通过引用传递参数的函数\t62\n9.2  不要对NULL取值\t64\n第10章  结构\t65\n10.1  练习\t66\n第11章  堆\t69\n第3部分  Objective-C与Foundation\t73\n第12章  对象\t75\n12.1  创建并使用对象\t75\n12.2  消息详解\t77\n12.3  内存中的对象\t79\n12.4  id\t79\n12.5  练习\t80\n第13章  再谈消息\t81\n13.1  消息的嵌套发送\t81\n13.2  多个实参\t82\n13.3  向nil发送消息\t82\n13.4  练习\t83\n第14章  NSString\t85\n14.1  练习\t86\n第15章  NSArray\t87\n15.1  NSMutableArray\t89\n15.2  练习\t90\n第16章  开发文档\t93\n16.1  参考页\t94\n16.2  快速帮助\t96\n16.3  其他文档功能和开发资源\t98\n第17章  第一个自定义类\t101\n17.1  存取方法\t103\n17.2  用点号调用存取方法\t104\n17.2  属性\t105\n17.4  self\t106\n17.5  多个实现文件\t106\n17.6  练习\t106\n第18章  继承\t109\n18.1  覆盖方法\t112\n18.2  super\t113\n18.3  练习\t113\n第19章  对象实例变量\t115\n19.1  对象所有权与ARC\t117\n19.2  练习\t123\n第20章  避免内存泄露\t125\n20.1  Retain循环\t127\n20.2  弱引用\t129\n20.3  弱引用的自动置零特性\t130\n20.4  深入学习：手动引用计数和ARC历史\t131\n第21章  Collection类\t135\n21.1  NSArray\/NSMutableArray\t135\n21.2  NSSet\/NSMutableSet\t138\n21.3  NSDictionary\/NSMutableDictionary\t140\n21.4  C语言基本类型\t142\n21.5  Collection对象与nil\t142\n21.6  练习\t143\n第22章  常量\t145\n22.1  预处理指令\t145\n22.2  #include与#import\t146\n22.3  #define\t146\n22.4  全局变量\t147\n22.5  比较#define与全局变量\t149\n第23章  通过NSString和NSData将数据写入文件\t151\n23.1  将NSString对象写入文件\t151\n23.2  NSError\t152\n23.3  通过NSString读取文件\t153\n23.4  将NSData对象所保存的数据写入文件\t154\n23.5  从文件读取数据并存入NSData对象\t155\n第24章  回调\t157\n24.1  目标-动作对\t157\n24.2  辅助对象\t160\n24.3  通告\t163\n24.4  如何选择\t164\n24.5  回调与对象所有权\t164\n第25章  协议\t167\n第26章  Property List格式\t171\n26.1  练习\t173\n第4部分  由事件驱动的应用\t175\n第27章  第一个iOS应用\t177\n27.1  创建iTahDoodle\t177\n27.2  BNRAppDelegate\t179\n27.3  添加C语言辅助函数\t180\n27.4  iTahDoodle中的对象\t181\n27.5  Model-View-Controller\t182\n27.6  应用委托对象\t183\n27.7  设置视图\t184\n27.8  为UITableView对象提供数据\t186\n27.9  添加新任务\t189\n27.10  深入学习：main()的作用\t190\n第28章  第一个Cocoa应用\t191\n28.1  编辑BNRDocument.h\t192\n28.2  Interface Builder初探\t193\n28.3  编辑BNRDocument.xib\t194\n28.4  创建关联\t198\n28.5  再探MVC\t202\n28.6  编辑BNRDocument.m\t202\n28.7  练习\t204\n第5部分  Objective-C高级主题\t205\n第29章  init\t207\n29.1  编写init方法\t207\n29.2  实现基本的init方法\t208\n29.3  在init中使用存取方法\t209\n29.4  带实参的init方法\t210\n29.5  禁用init方法\t215\n第30章  属性\t217\n30.1  属性的特性\t218\n30.2  KVC\t221\n第31章  范畴\t225\n第32章  Block对象\t227\n32.1  定义Block对象\t227\n32.2  使用Block对象\t228\n32.3  typedef\t233\n32.4  返回值\t233\n32.5  内存管理\t234\n32.6  基于Block的编程是大势所趋\t235\n32.7  练习\t235\n第6部分  C语言高级主题\t237\n第33章  位运算\t239\n33.1  按位或\t240\n33.2  按位与\t241\n33.3  其他位运算符\t242\n33.4  用enum定义位掩码\t245\n33.5  占用更多字节的整数类型\t245\n33.6  练习\t245\n第34章  C字符串\t247\n34.1  char\t247\n34.2  char *\t248\n34.3  string literal\t250\n34.4  C字符串和NSString对象的相互转换\t251\n34.5  练习\t252\n第35章  C数组\t253\n第36章  命令行参数\t257\n第37章  switch语句\t261\n结束语\t263\n索引\t265","pages":"284","images":{"small":"http:\/\/img3.douban.com\/spic\/s22704633.jpg","large":"http:\/\/img3.douban.com\/lpic\/s22704633.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s22704633.jpg"},"alt":"http:\/\/book.douban.com\/subject\/19962787\/","id":"19962787","publisher":"华中科技大学出版社","isbn10":"7560983235","isbn13":"9787560983233","title":"Objective-C编程","url":"http:\/\/api.douban.com\/v2\/book\/19962787","alt_title":"Objective-C Programming: The Big Nerd Ranch Guide","author_intro":"Aaron Hillegass曾就职于NeXT公司和Apple公司，他有近20年的Objective-C编程、Cocoa编程和iOS编程教学经验。\nAaron是《Cocoa编程》的作者，并与他人合著了《iOS编程》。这两本畅销书获得了来自全球各地读者的好评。\n2001年，Aaron创办了Big Nerd Ranch公司，提供强化式编程课程，为学员提供集中的、无干扰的学习环境。","summary":"《Objective-C编程》讲述Objective-C编程语言和基本的iOS\/Mac开发知识。作者首先从基本的编程概念讲起（变量、条件语句、循环结构等），接着用浅显易懂的语言讲解Objective-C和Foundation的知识，包括Objective-C的基本语法、 Foundation常用类 、内存管理、常用设计模式等，最后手把手教读者编写完整的、基于事件驱动的iOS\/Mac应用。作者还穿插介绍了Objetive-C的高级内容，包括属性、范畴和Block对象等知识。全书篇幅精炼，内容清晰，适合无编程经验的读者入门学习。\nBig Nerd Ranch培训系列中文图书网站：http:\/\/www.iosprogrammingbook.com\/","price":"58.00元"},{"rating":{"max":10,"numRaters":159,"average":"8.0","min":0},"subtitle":"","author":["Mark G. Sobell"],"pubdate":"2007年02","tags":[{"count":155,"name":"linux","title":"linux"},{"count":83,"name":"shell","title":"shell"},{"count":39,"name":"linux命令，编辑器与SHELL编程","title":"linux命令，编辑器与SHELL编程"},{"count":34,"name":"计算机","title":"计算机"},{"count":31,"name":"编程","title":"编程"},{"count":23,"name":"Linux","title":"Linux"},{"count":22,"name":"Linux\/Unix","title":"Linux\/Unix"},{"count":16,"name":"系统管理","title":"系统管理"}],"origin_title":"","image":"http:\/\/img5.douban.com\/mpic\/s2338599.jpg","binding":"简裝本","translator":["杨明军","王凤芹"],"catalog":"第Ⅰ部分 Linux操作系统第1章 欢迎进入Linux世界 第2章 入门 第3章 命令行工具 第4章 Linux文件系统 第5章 shell 第Ⅱ部分 编辑器第6章 vim编辑器第7章 emacs编辑器第Ⅲ部分 shell第8章 Bourne Again Shell第9章 TC Shell第Ⅳ部分 编程工具第10章 C的编程 第11章 BASH程序设计第12章 gawk模式处理语言第13章 sed编辑器第Ⅴ部分 命令参考第14章 命令参考第Ⅵ部分 附录附录A 正则表达式 附录B 获取帮助 附录C 保持系统最新获取帮助 附录D 术语表","pages":"792","images":{"small":"http:\/\/img5.douban.com\/spic\/s2338599.jpg","large":"http:\/\/img5.douban.com\/lpic\/s2338599.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s2338599.jpg"},"alt":"http:\/\/book.douban.com\/subject\/2029866\/","id":"2029866","publisher":"清华大学出版社","isbn10":"730213944X","isbn13":"9787302139447","title":"Linux命令、编辑器与Shell编程","url":"http:\/\/api.douban.com\/v2\/book\/2029866","alt_title":"","author_intro":"Mark G.Sobell是Sobell Associates 公司的主席，该公司是一个专于UNLX\/Linux 培训、技术支持和用户软件开发的咨询公司。Sobell是多本UNIX和Linux畅销书的作者，著有Prentice Hall PTR出版社出版的A Prac-tical Guide to Red Hat Linux，Second Edition一书，以及Addison-Wesley出版社出版的A Practical Guide to UNIX System，Hands-on UNIX和A Practical Guide to Solaris。Sobell具有超过25年使用UNIX和Linux的经验。","summary":"1. 它是Pearson、Amazon、Bames&Noble 计算机畅销书！\n2. 知名Linux专家Mark Sobell 编写的这本书，为系统管理员、开发人员和高级用户提供了最需要的全面的深入指导，同时还是一本卓越的日常参考手册。\n3. 一本值得每一位Linux管理人员、开发人员和高级用户拥有的指南！\n4. 本书并不针对特定的Linux版本或者某个发行版本，而是适用于所有近期发布的Linux版本;\n5. 最实用的Linux指南和参考手册，数百个高质量的实例覆盖了每种Linux发行版！\n6. 本书覆盖超过80个核心工具、shell编程、编辑器和编程工具，能使您成为真正的Linux高手，它是掌握强大的Linux命令行的捷径。","price":"98.00元"},{"rating":{"max":10,"numRaters":120,"average":"7.7","min":0},"subtitle":"Java Network Programming","author":["Elliotte Rusty Harold 著"],"pubdate":"2005-11-22","tags":[{"count":137,"name":"java","title":"java"},{"count":114,"name":"网络编程","title":"网络编程"},{"count":59,"name":"java网络编程","title":"java网络编程"},{"count":35,"name":"O'Reilly","title":"O'Reilly"},{"count":28,"name":"Java","title":"Java"},{"count":25,"name":"网络","title":"网络"},{"count":21,"name":"程序设计","title":"程序设计"},{"count":20,"name":"编程","title":"编程"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s1455603.jpg","binding":"","translator":["朱涛江,林剑"],"catalog":"","pages":"718","images":{"small":"http:\/\/img3.douban.com\/spic\/s1455603.jpg","large":"http:\/\/img3.douban.com\/lpic\/s1455603.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s1455603.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1438754\/","id":"1438754","publisher":"中国电力","isbn10":"7508338405","isbn13":"9787508338408","title":"Java网络编程(中文版 第三版)(O＇Reilly Java系列)","url":"http:\/\/api.douban.com\/v2\/book\/1438754","alt_title":"JAVA Network Programming,Third Edition","author_intro":"Elliotte Rusty Harold是牛奶咖啡网站的作者，这是一个重要的在线资源，提供了有关Java的新闻。他还是XOM API的开发者，也是《Java I\/O》、《XML in a Nutshell》及很多有关Java和XML主题图书的作者。","summary":"《Java网络编程》第三版会为你介绍Java网络API的最新特性。本书讨论了JDK 1.4和1.5（现在已命名为J2SE 5）中所做的所有修改和增补。本书内容全面，涵盖了从网络基础知识到远程方法调用（RMI）等各方面的内容，书中章节涉及到TCP和UDP socket、服务器socket、URL和URI、组播以及特殊用途的API（如JavaMail）等等。本书展示了如何使用JSSE编写安全的网络应用程序，解释了如何使用NIO API编写超高性能的服务器。它还涵盖了Java对网络代理、Web cookie和URL缓存的支持。\n《Java网络编程》不仅仅是对API的解释：它还展示了如何使用API。本书有很多示例，包含了几千行可以实际工作的代码（所有代码都可以在线获得），实现了功能完整的网络客户端和服务器。无论是希望编写特殊用途的Web服务器、安全的在线订单接收程序、简单的组播代理还是电子邮件客户端，都会找到可供学习和借用的代码。\n无论你是经验丰富的网络开发人员、Java程序员新手，还是只希望对Java网络编程稍有些了解的人，都会发现《Java编程（第三版）》将成为你的书库中一个重要的部分。一旦开始使用Java网络API，只要你能想到它就能够做得到。","price":"85.00元"},{"rating":{"max":10,"numRaters":39,"average":"8.4","min":0},"subtitle":"","author":["［日］ 前桥和弥"],"pubdate":"2013-11","tags":[{"count":102,"name":"编程语言","title":"编程语言"},{"count":79,"name":"编译原理","title":"编译原理"},{"count":68,"name":"编程","title":"编程"},{"count":39,"name":"计算机","title":"计算机"},{"count":37,"name":"计算机科学","title":"计算机科学"},{"count":24,"name":"程序设计","title":"程序设计"},{"count":23,"name":"Programming","title":"Programming"},{"count":22,"name":"编译器","title":"编译器"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s27093931.jpg","binding":"平装","translator":["刘卓","徐谦","吴雅明"],"catalog":"目　录\n第1章 　引子　　001\n1.1 为什么要制作编程语言　　002\n1.2 自制编程语言并不是很难　　003\n1.3 本书的构成与面向读者　　004\n1.4 用什么语言来制作　　006\n1.5 要制作怎样的语言　　007\n1.5.1 要设计怎样的语法　　007\n1.5.2 要设计怎样的运行方式　　009\n补充知识 　“用户”指的是谁？　　012\n补充知识 　解释器并不会进行翻译　　012\n1.6 环境搭建　　012\n1.6.1 搭建开发环境　　012\n补充知识 关于bison与flex的安装　　014\n1.6.2 本书涉及的源代码以及编译器　　015\n第2章 　试做一个计算器　　017\n2.1 yacc\/lex是什么　　018\n补充知识 　词法分析器与解析器是各自独立的　　019\n2.2 试做一个计算器　　020\n2.2.1 lex　　021\n2.2.2 简单正则表达式讲座　　024\n2.2.3 yacc　　026\n2.2.4 生成执行文件　　033\n2.2.5 理解冲突所代表的含义　　034\n2.2.6 错误处理　　040\n2.3 不借助工具编写计算器　　041\n2.3.1 自制词法分析器　　041\n补充知识 　保留字（关键字）　　046\n补充知识 避免重复包含　　047\n2.3.2 自制语法分析器　　048\n补充知识 预读记号的处理　　053\n2.4 少许理论知识——LL(1)与LALR(1)　　054\n补充知识 Pascal\/C 中的语法处理诀窍　　056\n2.5 习题：扩展计算器　　056\n2.5.1 让计算器支持括号　　056\n2.5.2 让计算器支持负数　　058\n第3章 　制作无类型语言crowbar　　061\n3.1　制作crowbar ver.0.1语言的基础部分　　062\n3.1.1 crowbar是什么　　062\n3.1.2 程序的结构　　063\n3.1.3 数据类型　　064\n3.1.4 变量　　064\n补充知识 初次赋值兼做变量声明的理由　　066\n补充说明 各种语言的全局变量处理　　067\n3.1.5 语句与结构控制　　067\n补充知识 elif、elsif、elseif的选择　　068\n3.1.6 语句与运算符　　069\n3.1.7 内置函数　　069\n3.1.8 让crowbar支持C 语言调用　　070\n3.1.9 从crowbar中调用C 语言（内置函数的编写）　　071\n3.2 预先准备　　071\n3.2.1 模块与命名规则　　072\n3.2.2 内存管理模块MEM　　073\n补充知识 valgrind　　075\n补充知识 富翁式编程　　075\n补充知识 符号表与扣留操作　　076\n3.2.3 调试模块DBG　　076\n3.3 crowbar ver.0.1的实现　　077\n3.3.1 crowbar的解释器——CRB_Interpreter　　077\n补充知识 不完全类型　　080\n3.3.2 词法分析——crowbar.l　　081\n补充知识 静态变量的许可范围　　084\n3.3.3 分析树的构建——crowbar.y 与create.c　　085\n3.3.4 常量折叠　　089\n3.3.5 错误信息　　089\n补充知识 关于crowbar中使用的枚举型定义　　091\n3.3.6 运行——execute.c　　092\n3.3.7 表达式评估——eval.c　　096\n3.3.8 值——CRB_Value　　104\n3.3.9 原生指针型　　105\n3.3.10 变量　　106\n3.3.11 字符串与垃圾回收机制——string_pool.c　　108\n3.3.12 编译与运行　　110\n第4章 　数组和mark-sweep垃圾回收器　　113\n4.1 crowbar ver.0.2　　114\n4.1.1 crowbar的数组　　114\n4.1.2 访问数组元素　　115\n4.1.3 数组是一种引用类型　　116\n补充知识 　“数组的数组”和多维数组　　116\n4.1.4 为数组添加元素　　118\n4.1.5 增加( 模拟) 函数调用功能　　118\n4.1.6 其他细节　　118\n4.2 制作mark-sweep GC　　119\n4.2.1 引用数据类型的结构　　119\n4.2.2　mark-sweep GC　　121\n补充知识 引用和immutable　　123\n4.2.3 crowbar栈　　124\n4.2.4 其他根　　127\n4.2.5 原生函数的形式参数　　128\n4.3 实现GC 本身　　129\n4.3.1 对象的管理方法　　129\n4.3.2 GC 何时启动　　129\n4.3.3 sweep阶段　　132\n补充知识 GC 现存的问题　　133\n补充知识 Coping GC　　134\n4.4 其他修改　　136\n4.4.1 修改语法　　136\n4.4.2 函数的模拟　　137\n4.4.3 左值的处理　　139\n4.4.4 创建数组和原生函数的书写方法　　142\n4.4.5 原生指针类型的修改　　144\n第5章 　中文支持和Unicode　　147\n5.1 中文支持策略和基础知识　　148\n5.1.1 现存问题　　148\n5.1.2 宽字符（双字节）串和多字节字符串　　149\n补充知识 wchar_t 肯定能表示1 个字符吗？　　150\n5.1.3 多字节字符\/ 宽字符之间的转换函数群　　150\n5.2 Unicode　　153\n5.2.1 Unicode的历史　　153\n5.2.2 Unicode的编码方式　　154\n补充知识 Unicode可以固定（字节）长度吗？　　156\n5.3 crowbar book_ver.0.3的实现　　156\n5.3.1 要实现到什么程度？　　156\n5.3.2 发起转换的时机　　157\n5.3.3 关于区域设置　　158\n5.3.4 解决0x5C问题　　158\n补充知识 失败的 #ifdef　　160\n5.3.5 应该是什么样子　　160\n补充知识 还可以是别的样子——Code Set Independent　　161\n第6章 　制作静态类型的语言Diksam　　163\n6.1 制作Diksam Ver 0.1语言的基本部分　　164\n6.1.1 Diksam的运行状态　　164\n6.1.2 什么是Diksam　　165\n6.1.3 程序结构　　165\n6.1.4 数据类型　　166\n6.1.5 变量　　166\n6.1.6 语句和流程控制　　167\n6.1.7 表达式　　167\n6.1.8 内建函数　　168\n6.1.9 其他　　168\n6.2 什么是静态的\/ 执行字节码的语言　　169\n6.2.1 静态类型的语言　　169\n6.2.2 什么是字节码　　169\n6.2.3 将表达式转换为字节码　　170\n6.2.4 将控制结构转换为字节码　　173\n6.2.5 函数的实现　　173\n6.3 Diksam ver.0.1的实现——编译篇　　175\n6.3.1 目录结构　　175\n6.3.2 编译的概要　　176\n6.3.3 构建分析树（create.c）　　176\n6.3.4 修正分析树（fix_tree.c）　　179\n6.3.5 Diksam的运行形式——DVM_Executable　　185\n6.3.6 常量池　　186\n补充知识 YARV 的情况　　187\n6.3.7 全局变量　　188\n6.3.8 函数　　189\n6.3.9 顶层结构的字节码　　189\n6.3.10 行号对应表　　190\n6.3.11 栈的需要量　　190\n6.3.12 生成字节码（generate.c）　　191\n6.3.13 生成实际的编码　　193\n6.4 Diksam虚拟机　　197\n6.4.1 加载\/ 链接DVM_Executable到DVM　　200\n6.4.2 执行——巨大的switch case　　202\n6.4.3 函数调用　　204\n第7章 　为Diksam引入数组　　207\n7.1 Diksam中数组的设计　　208\n7.1.1 声明数组类型的变量　　208\n7.1.2 数组常量　　209\n补充知识 D 语言的数组　　210\n7.2 修改编译器　　210\n7.2.1 数组的语法规则　　210\n7.2.2 TypeSpecifier结构体　　212\n7.3 修改DVM　　213\n7.3.1 增加指令　　213\n补充知识 创建Java 的数组常量　　215\n补充知识 C 语言中数组的初始化　　217\n7.3.2 对象　　217\n补充知识 ArrayStoreException　　218\n7.3.3 增加null　　219\n7.3.4 哎! 还缺点什么吧？　　219\n第8章 　将类引入Diksam　　221\n8.1 分割源文件　　222\n8.1.1 包和分割源代码　　222\n补充知识 #include、文件名、行号　　225\n8.1.2 DVM_ExecutableList　　225\n8.1.3 ExecutableEntry　　226\n8.1.4 分开编译源代码　　227\n8.1.5 加载和再链接　　230\n补充知识 动态加载时的编译器　　233\n8.2 设计Diksam中的类　　233\n8.2.1 超简单的面向对象入门　　233\n8.2.2 类的定义和实例创建　　237\n8.2.3 继承　　239\n8.2.4 关于接口　　241\n8.2.5 编译与接口　　242\n8.2.6 Diksam怎么会设计成这样？　　243\n8.2.7 数组和字符串的方法　　245\n8.2.8 检查类的类型　　246\n8.2.9 向下转型　　246\n8.3 关于类的实现——继承和多态　　247\n8.3.1 字段的内存布局　　247\n8.3.2 多态——以单继承为前提　　249\n8.3.3 多继承——C++　　250\n8.3.4 Diksam的多继承　　252\n补充知识 无类型语言中的继承　　254\n8.3.5 重写的条件　　254\n8.4 关于类的实现　　256\n8.4.1 语法规则　　256\n8.4.2 编译时的数据结构　　258\n8.4.3 DVM_Executable中的数据结构　　260\n8.4.4 与类有关的指令　　262\n补充知识 方法调用、括号和方法指针　　263\n8.4.5 方法调用　　264\n8.4.6 super　　266\n8.4.7 类的链接　　266\n8.4.8 实现数组和字符串的方法　　267\n8.4.9 类型检查和向下转型　　267\n补充知识 对象终结器（finalizer）和析构函数（destructor）　　268\n第9章 　应用篇　　271\n9.1 为crowbar引入对象和闭包　　272\n9.1.1 crowbar的对象　　272\n9.1.2 对象实现　　273\n9.1.3 闭包　　274\n9.1.4 方法　　276\n9.1.5 闭包的实现　　278\n9.1.6 试着跟踪程序实际执行时的轨迹　　281\n9.1.7 闭包的语法规则　　284\n9.1.8 普通函数　　284\n9.1.9 模拟方法（修改版）　　285\n9.1.10 基于原型的面向对象　　286\n9.2 异常处理机制　　286\n9.2.1 为crowbar引入异常　　286\n9.2.2 setjmp()\/longjmp()　　289\n补充知识 Java 和C# 异常处理的不同　　293\n9.2.3 为Diksam引入异常　　295\n补充知识 catch 的编写方法　　296\n9.2.4 异常的数据结构　　297\n9.2.5 异常处理时生成的字节码299\n9.2.6 受查异常　　301\n补充知识 受查异常的是与非 303\n补充知识 异常处理本身的是与非　　304\n9.3 构建脚本　　305\n9.3.1 基本思路　　306\n9.3.2 YY_INPUT　　307\n9.3.3 Diksam的构建脚本　　308\n9.3.4 三次加载\/ 链接　　308\n9.4 为crowbar引入鬼车　　309\n9.4.1 关于“鬼车”　　309\n9.4.2 正则表达式常量　　310\n9.4.3 正则表达式的相关函数　　311\n9.5 其他　　312\n9.5.1 foreach 和迭代器（crowbar）　　312\n9.5.2 switch case（Diksam)　　314\n9.5.3 enum（Diksam）　　315\n9.5.4 delegate（Diksam）　　316\n9.5.5 final、const（Diksam）　　319\n附录A 　crowbar语言的设计　　322\n附录B 　Diksam语言的设计　　336\n附录C 　Diksam Virtual Machine 指令集　　359\n编程语言实用化指南——写在最后　　369\n参考文献　　375","pages":"396","images":{"small":"http:\/\/img3.douban.com\/spic\/s27093931.jpg","large":"http:\/\/img3.douban.com\/lpic\/s27093931.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s27093931.jpg"},"alt":"http:\/\/book.douban.com\/subject\/25735333\/","id":"25735333","publisher":"人民邮电出版社","isbn10":"7115333203","isbn13":"9787115333209","title":"自制编程语言","url":"http:\/\/api.douban.com\/v2\/book\/25735333","alt_title":"","author_intro":"作者简介：\n前桥和弥（Maebasi Kazuya）\n1969年出生，著有《征服C指针》、《彻底掌握C语言》、《Java之谜和陷阱》等。其一针见血的“毒舌”文风和对编程语言深刻的见地受到广大读者的欢迎。\n作者主页：http:\/\/kmaebashi.com\/。\n译者简介：\n刘卓\n2004年开始从事对日软件开发工作，其间还从事技术及软件工程相关培训工作。自2011年开始从事电力行业产品研发。持续关注企业级应用架构和Web客户端技术。\n徐谦\n6年技术开发及项目经验，曾以技术工程师身份赴日本工作两年，后归国联合创办互联网公司，现居上海继续创业中。主要从事PHP方向的Web开发。热爱开源，曾向Zend Framework等知名PHP开源项目贡献代码，并于Github自主研发运维EvaThumber等开源项目获得国内社区认可。乐于分享技术心得，个人技术博客avnpc.com在国内PHP圈小有影响。\n吴雅明\n13年编程经验。其中7年专注于研发基于Java EE和.NET的开发框架以及基于UML 2.0模型的代码生成工具。目前正带领团队开发云计算PaaS平台及云计算自动化配置部署的系统。译著有《征服C指针》等。","summary":"★ 只需编程基础\n★ 从零开始自制编程语言\n★ 支持面向对象、异常处理等高级机制\n本书手把手地教读者用C语言制作两种编程语言：crowbar与Diksam。crowbar是运行分析树的无类型语言，Diksam是运行字节码的静态类型语言。这两种语言都具备四则运算、变量、条件分支、循环、函数定义、垃圾回收等功能，最终版则可以支持面向对象、异常处理等高级机制。所有源代码都提供下载，读者可以一边对照书中的说明一边调试源代码。这个过程对理解程序的运行机制十分有帮助。\n本书适合有一定基础的程序员和编程语言爱好者阅读。","price":"79.00"},{"rating":{"max":10,"numRaters":119,"average":"8.3","min":0},"subtitle":"","author":["Matthew H. Austern"],"pubdate":"2003-1","tags":[{"count":159,"name":"C++","title":"C++"},{"count":99,"name":"STL","title":"STL"},{"count":61,"name":"泛型编程","title":"泛型编程"},{"count":33,"name":"编程","title":"编程"},{"count":30,"name":"C\/C++","title":"C\/C++"},{"count":28,"name":"计算机","title":"计算机"},{"count":15,"name":"程序设计","title":"程序设计"},{"count":14,"name":"泛型","title":"泛型"}],"origin_title":"Generic Programming and the STL","image":"http:\/\/img3.douban.com\/mpic\/s1832300.jpg","binding":"平装","translator":["侯捷"],"catalog":"\n      ","pages":"548","images":{"small":"http:\/\/img3.douban.com\/spic\/s1832300.jpg","large":"http:\/\/img3.douban.com\/lpic\/s1832300.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s1832300.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1241423\/","id":"1241423","publisher":"中国电力出版社","isbn10":"7508314875","isbn13":"9787508314877","title":"泛型编程与STL","url":"http:\/\/api.douban.com\/v2\/book\/1241423","alt_title":"Generic Programming and the STL","author_intro":"","summary":"《泛型编程与STL》阐述了泛型编程的中心思想：concepts、modeling、refinement,并为你展示这些思想如何导出STL的基础概念：iterators、containers、functionobjects.循此路线，你可以把STL想像为一个由concepts组成的程序库。你将学习真正式结构并因此获得其潜在威力所带来的完整优势。","price":"72.00元"},{"rating":{"max":10,"numRaters":99,"average":"8.8","min":0},"subtitle":"","author":["[美] 拉莫泽"],"pubdate":"2005-6","tags":[{"count":125,"name":"游戏开发","title":"游戏开发"},{"count":77,"name":"3d","title":"3d"},{"count":64,"name":"游戏编程","title":"游戏编程"},{"count":41,"name":"图形学","title":"图形学"},{"count":34,"name":"游戏","title":"游戏"},{"count":28,"name":"3D游戏编程大师技巧","title":"3D游戏编程大师技巧"},{"count":25,"name":"编程","title":"编程"},{"count":24,"name":"计算机","title":"计算机"}],"origin_title":"Tricks of the 3D Game Programming Gurus-Advanced 3D Graphics and Rasterization","image":"http:\/\/img5.douban.com\/mpic\/s25793439.jpg","binding":"平装","translator":["李祥瑞","陈武"],"catalog":"第一部分　3D游戏编程简介\n第1章　3D游戏编程入门　2\n1.1　简介　2\n1.2　2D\/3D游戏的元素　3\n1.2.1　初始化　3\n1.2.2　进入游戏循环　3\n1.2.3　读取玩家输入　4\n1.2.4　执行AI和游戏逻辑　4\n1.2.5　渲染下一帧　4\n1.2.6　同步显示　4\n1.2.7　循环　4\n1.2.8　关闭　5\n1.3　通用游戏编程指南　7\n1.4　使用工具　9\n1.4.1　3D关卡编辑器　12\n1.4.2　使用编译器　13\n1.5　一个3D游戏范例：Raiders 3D　15\n1.5.1　事件循环　33\n1.5.2　核心3D游戏逻辑　34\n1.5.3　3D投影　35\n1.5.4　星空　36\n1.5.5　激光炮和碰撞检测　37\n1.5.6　爆炸　37\n1.5.7　玩Raiders3D　37\n1.6　总结　37\n第2章　Windows和DirectX简明教程　38\n2.1　Win32编程模型　38\n2.2　Windows程序的最小需求　39\n2.3　一个基本的Windows应用程序　43\n2.3.1　Windows类　43\n2.3.2　注册Windows类　47\n2.3.3　创建窗口　47\n2.3.4　事件处理程序　48\n2.3.5　主事件循环　52\n2.3.6　构建实时事件循环　55\n2.4　DirectX和COM简明教程　56\n2.4.1　HEL和HAL　57\n2.4.2　DirectX基本类　58\n2.5　COM简介　59\n2.5.1　什么是COM对象　60\n2.5.2　创建和使用DirectX COM接口　61\n2.5.3　查询接口　62\n2.6　总结　64\n第3章　使用虚拟计算机进行3D游戏编程　65\n3.1　虚拟计算机接口简介　65\n3.2　建立虚拟计算机接口　66\n3.2.1　帧缓存和视频系统　66\n3.2.2　使用颜色　70\n3.2.3　缓存交换　71\n3.2.4　完整的虚拟图形系统　73\n3.2.5　I\/O、声音和音乐　73\n3.3　T3DLIB游戏控制台　74\n3.3.1　T3DLIB系统概述　74\n3.3.2　基本游戏控制台　74\n3.4　T3DLIB1库　79\n3.4.1　DirectX图形引擎体系结构　79\n3.4.2　基本常量　79\n3.4.3　工作宏　81\n3.4.4　数据类型和结构　81\n3.4.5　函数原型　84\n3.4.6　全局变量　88\n3.4.7　DirectDraw接口　89\n3.4.8　2D多边形函数　92\n3.4.9　数学函数和错误函数　97\n3.4.10　位图函数　99\n3.4.11　8位调色板函数　102\n3.4.12　实用函数　104\n3.4.13　BOB(Blitter对象)引擎　106\n3.5　T3DLIB2 DirectX输入系统　112\n3.6　T3DLIB3声音和音乐库　116\n3.6.1　头文件　117\n3.6.2　类型　117\n3.6.3　全局变量　117\n3.6.4　DirectSound API封装函数　118\n3.6.5　DirectMusic API封装函数　121\n3.7　建立最终的T3D游戏控制台　124\n3.7.1　映射真实图形到虚拟接口的非真实图形　124\n3.7.2　最终的T3DLIB游戏控制台　126\n3.8　范例T3LIB应用程序　134\n3.8.1　窗口应用程序　134\n3.8.2　全屏应用程序　135\n3.8.3　声音和音乐　136\n3.8.4　处理输入　136\n3.9　总结　139\n第二部分　3D数学和变换\n第4章　三角学、向量、矩阵和四元数　142\n4.1　数学表示法　142\n4.2　2D坐标系　143\n4.2.1　2D笛卡尔坐标　143\n4.2.2　2D极坐标　144\n4.3　3D坐标系　147\n4.3.1　3D笛卡尔坐标　147\n4.3.2　3D柱面坐标　149\n4.3.3　3D球面坐标　150\n4.4　三角学　151\n4.4.1　直角三角形　151\n4.4.2　反三角函数　153\n4.4.3　三角恒等式　153\n4.5　向量　154\n4.5.1　向量长度　155\n4.5.2　归一化　155\n4.5.3　向量和标量的乘法　155\n4.5.4　向量加法　156\n4.5.5　向量减法　157\n4.5.6　点积　157\n4.5.7　叉积　159\n4.5.8　零向量　160\n4.5.9　位置和位移向量　160\n4.5.10　用线性组合表示的向量　161\n4.6　矩阵和线性代数　161\n4.6.1　单位矩阵　162\n4.6.2　矩阵加法　163\n4.6.3　矩阵的转置　163\n4.6.4　矩阵乘法　164\n4.6.5　矩阵运算满足的定律　165\n4.7　逆矩阵和方程组求解　165\n4.7.1　克来姆法则　167\n4.7.2　使用矩阵进行变换　168\n4.7.3　齐次坐标　169\n4.7.4　应用矩阵变换　170\n4.8　基本几何实体　176\n4.8.1　点　176\n4.8.2　直线　176\n4.8.3　平面　179\n4.9　使用参数化方程　182\n4.9.1　2D参数化直线　182\n4.9.2　3D参数化直线　184\n4.10　四元数简介　189\n4.10.1　复数理论　189\n4.10.2　超复数　193\n4.10.3　四元数的应用　197\n4.11　总结　200\n第5章　建立数学引擎　201\n5.1　数学引擎概述　201\n5.1.1　数学引擎的文件结构　201\n5.1.2　命名规则　202\n5.1.3　错误处理　203\n5.1.4　关于C++的最后说明　203\n5.2　数据结构和类型　203\n5.2.1　向量和点　203\n5.2.2　参数化直线　204\n5.2.3　3D平面　206\n5.2.4　矩阵　206\n5.2.5　四元数　209\n5.2.6　角坐标系支持　210\n5.2.7　2D极坐标　210\n5.2.8　3D柱面坐标　211\n5.2.9　3D球面坐标　211\n5.2.10　定点数　212\n5.3　数学常量　213\n5.4　宏和内联函数　214\n5.4.1　通用宏　218\n5.4.2　点和向量宏　218\n5.4.3　矩阵宏　219\n5.4.4　四元数　220\n5.4.5　定点数宏　221\n5.5　函数原型　221\n5.6　全局变量　224\n5.7　数学引擎API清单　225\n5.7.1　三角函数　225\n5.7.2　坐标系支持函数　226\n5.7.3　向量支持函数　228\n5.7.4　矩阵支持函数　235\n5.7.5　2D和3D参数化直线支持函数　245\n5.7.6　3D平面支持函数　248\n5.7.7　四元数支持函数　252\n5.7.8　定点数支持函数　259\n5.7.9　方程求解支持函数　263\n5.8　浮点单元运算初步　265\n5.8.1　FPU体系结构　266\n5.8.2　FPU堆栈　266\n5.8.3　FPU指令集　268\n5.8.4　经典指令格式　270\n5.8.5　内存指令格式　271\n5.8.6　寄存器指令格式　271\n5.8.7　寄存器弹出指令格式　271\n5.8.8　FPU范例　271\n5.8.9　FLD范例　272\n5.8.10　FST范例　272\n5.8.11　FADD范例　273\n5.8.12　FSUB范例　275\n5.8.13　FMUL范例　276\n5.8.14　FDIV范例　278\n5.9　数学引擎使用说明　279\n5.10　关于数学优化的说明　280\n5.11　总结　280\n第6章　3D图形学简介　282\n6.1　3D引擎原理　282\n6.2　3D游戏引擎的结构　282\n6.2.1　3D引擎　283\n6.2.2　游戏引擎　283\n6.2.3　输入系统和网络　284\n6.2.4　动画系统　284\n6.2.5　碰撞检测和导航系统　287\n6.2.6　物理引擎　288\n6.2.7　人工智能系统　289\n6.2.8　3D模型和图像数据库　289\n6.3　3D坐标系　291\n6.3.1　模型(局部)坐标　291\n6.3.2　世界坐标　293\n6.3.3　相机坐标　296\n6.3.4　有关相机坐标的说明　302\n6.3.5　隐藏物体(面)消除和裁剪　303\n6.3.6　透视坐标　308\n6.3.7　流水线终点：屏幕坐标　315\n6.4　基本的3D数据结构　321\n6.4.1　表示3D多边形数据时需要考虑的问题　322\n6.4.2　定义多边形　323\n6.4.3　定义物体　327\n6.4.4　表示世界　330\n6.5　3D工具　331\n6.6　从外部加载数据　332\n6.6.1　PLG文件　333\n6.6.2　NFF文件　335\n6.6.3　3D Studio文件　338\n6.6.4　Caligari COB文件　343\n6.6.5　Microsoft DirectX .X文件　345\n6.6.6　3D文件格式小结　345\n6.7　基本刚性变换和动画　345\n6.7.1　3D平移　345\n6.7.2　3D旋转　346\n6.7.3　3D变形　347\n6.8　再看观察流水线　348\n6.9　3D引擎类型　349\n6.9.1　太空引擎　349\n6.9.2　地形引擎　350\n6.9.3　FPS室内引擎　351\n6.9.4　光线投射和体素引擎　352\n6.9.5　混合引擎　353\n6.10　将各种功能集成到引擎中　353\n6.11　总结　353\n第7章　渲染3D线框世界　354\n7.1　线框引擎的总体体系结构　354\n7.1.1　数据结构和3D流水线　355\n7.1.2　主多边形列表　357\n7.1.3　新的软件模块　359\n7.2　编写3D文件加载器　359\n7.3　构建3D流水线　367\n7.3.1　通用变换函数　367\n7.3.2　局部坐标到世界坐标变换　372\n7.3.3　欧拉相机模型　375\n7.3.4　UVN相机模型　377\n7.3.5　世界坐标到相机坐标变换　387\n7.3.6　物体剔除　390\n7.3.7　背面消除　393\n7.3.8　相机坐标到透视坐标变换　395\n7.3.9　透视坐标到屏幕(视口)坐标变换　399\n7.3.10　合并透视变换和屏幕变换　403\n7.4　渲染3D世界　405\n7.5　3D演示程序　408\n7.5.1　单个3D三角形　408\n7.5.2　3D线框立方体　411\n7.5.3　消除了背面的3D线框立方体　413\n7.5.4　3D坦克演示程序　414\n7.5.5　相机移动的3D坦克演示程序　416\n7.5.6　战区漫步演示程序　418\n7.6　总结　421\n第三部分　基本3D渲染\n第8章　基本光照和实体造型　424\n8.1　计算机图形学的基本光照模型　424\n8.1.1　颜色模型和材质　426\n8.1.2　光源类型　432\n8.2　三角形的光照计算和光栅化　437\n8.2.1　为光照做准备　441\n8.2.2　定义材质　442\n8.2.3　定义光源　445\n8.3　真实世界中的着色　449\n8.3.1　16位着色　449\n8.3.2　8位着色　450\n8.3.3　一个健壮的用于8位模式的RGB模型　450\n8.3.4　一个简化的用于8位模式的强度模型　453\n8.3.5　固定着色　457\n8.3.6　恒定着色　459\n8.3.7　Gouraud着色概述　472\n8.3.8　Phong着色概述　474\n8.4　深度排序和画家算法　475\n8.5　使用新的模型格式　479\n8.5.1　分析器类　479\n8.5.2　辅助函数　482\n8.5.3　3D Studio MAX ASCII格式.ASC　484\n8.5.4　TrueSpace ASCII.COB格式　486\n8.5.5　Quake II二进制.MD2格式概述　494\n8.6　3D建模工具简介　495\n8.7　总结　497\n第9章　插值着色技术和仿射纹理映射　498\n9.1　新T3D引擎的特性　498\n9.2　更新T3D数据结构和设计　499\n9.2.1　新的#defines　499\n9.2.2　新增的数学结构　501\n9.2.3　实用宏　502\n9.2.4　添加表示3D网格数据的特性　503\n9.2.5　更新物体结构和渲染列表结构　508\n9.2.6　函数清单和原型　511\n9.3　重新编写物体加载函数　517\n9.3.1　更新.PLG\/PLX加载函数　517\n9.3.2　更新3D Studio .ASC加载函数　527\n9.3.3　更新Caligari .COB加载函数　528\n9.4　回顾多边形的光栅化　532\n9.4.1　三角形的光栅化　532\n9.4.2　填充规则　535\n9.4.3　裁剪　537\n9.4.4　新的三角形渲染函数　538\n9.4.5　优化　542\n9.5　实现Gouraud着色处理　543\n9.5.1　没有光照时的Gouraud着色　544\n9.5.2　对使用Gouraud Shader的多边形执行光照计算　553\n9.6　基本采样理论　560\n9.6.1　一维空间中的采样　560\n9.6.2　双线性插值　561\n9.6.3　u和v的插值　563\n9.6.4　实现仿射纹理映射　564\n9.7　更新光照\/光栅化引擎以支持纹理　566\n9.8　对8位和16位模式下优化策略的最后思考　571\n9.8.1　查找表　571\n9.8.2　网格的顶点结合性　572\n9.8.3　存储计算结果　572\n9.8.4　SIMD　573\n9.9　最后的演示程序　573\n9.10　总结　576\n第10章　3D裁剪　577\n10.1　裁剪简介　577\n10.1.1　物体空间裁剪　577\n10.1.2　图像空间裁剪　580\n10.2　裁剪算法　581\n10.2.1　有关裁剪的基本知识　581\n10.2.2　Cohen-Sutherland裁剪算法　585\n10.2.3　Cyrus-Beck\/梁友栋-Barsky裁剪算法　586\n10.2.4　Weiler-Atherton裁剪算法　588\n10.2.5　深入学习裁剪算法　590\n10.3　实现视景体裁剪　591\n10.3.1　几何流水线和数据结构　592\n10.3.2　在引擎中加入裁剪功能　593\n10.4　地形小议　611\n10.4.1　地形生成函数　612\n10.4.2　生成地形数据　619\n10.4.3　沙地汽车演示程序　619\n10.5　总结　623\n第11章　深度缓存和可见性　624\n11.1　深度缓存和可见性简介　624\n11.2　z缓存基础　626\n11.2.1　z缓存存在的问题　627\n11.2.2　z缓存范例　627\n11.2.3　平面方程法　630\n11.2.4　z坐标插值　631\n11.2.5　z缓存中的问题和1\/z缓存　632\n11.2.6　一个通过插值计算z和1\/z的例子　633\n11.3　创建z缓存系统　635\n11.4　可能的z缓存优化　649\n11.4.1　使用更少的内存　649\n11.4.2　降低清空z缓存的频率　650\n11.4.3　混合z缓存　651\n11.5　z缓存存在的问题　651\n11.6　软件和z缓存演示程序　652\n11.6.1　演示程序I：z缓存可视化　652\n11.6.2　演示程序II：Wave Raider　653\n11.7　总结　658\n第四部分　高级3D渲染\n第12章　高级纹理映射技术　660\n12.1　纹理映射——第二波　660\n12.2　新的光栅化函数　667\n12.2.1　最终决定使用定点数　667\n12.2.2　不使用z缓存的新光栅化函数　668\n12.2.3　支持z缓存的新光栅化函数　670\n12.3　使用Gouruad着色的纹理映射　671\n12.4　透明度和alpha混合　677\n12.4.1　使用查找表来进行alpha混合　678\n12.4.2　在物体级支持alpha混合功能　688\n12.4.3　在地形生成函数中加入\nalpha支持　694\n12.5　透视修正纹理映射和1\/z缓存　696\n12.5.1　透视纹理映射的数学基础　696\n12.5.2　在光栅化函数中加入1\/z缓存功能　702\n12.5.3　实现完美透视修正纹理映射　707\n12.5.4　实现线性分段透视修正纹理映射　710\n12.5.5　透视修正纹理映射的二次近似　714\n12.5.6　使用混合方法优化纹理映射　718\n12.6　双线性纹理滤波　719\n12.7　Mipmapping和三线性纹理滤波　724\n12.7.1　傅立叶分析和走样简介　725\n12.7.2　创建Mip纹理链　727\n12.7.3　选择mip纹理　734\n12.7.4　三线性滤波　739\n12.8　多次渲染和纹理映射　740\n12.9　使用单个函数来完成渲染工作　741\n12.9.1　新的渲染场境　741\n12.9.2　设置渲染场境　743\n12.9.3　调用对渲染场境进行渲染的函数　745\n12.10　总结　753\n第13章　空间划分和可见性算法　754\n13.1　新的游戏引擎模块　754\n13.2　空间划分和可见面判定简介　754\n13.3　二元空间划分　757\n13.3.1　平行于坐标轴的二元空间划分　758\n13.3.2　任意平面空间划分　759\n13.3.3　使用多边形所在的平面来划分空间　760\n13.3.4　显示\/访问BSP树中的每个节点　762\n13.3.5　BSP树数据结构和支持函数　763\n13.3.6　创建BSP树　765\n13.3.7　分割策略　767\n13.3.8　遍历和显示BSP树　775\n13.3.9　将BSP树集成到图形流水线中　784\n13.3.10　BSP关卡编辑器　785\n13.3.11　BSP的局限性　793\n13.3.12　使用BSP树的零重绘策略　794\n13.3.13　将BSP树用于剔除　795\n13.3.14　将BSP树用于碰撞检测　802\n13.3.15　集成BSP树和标准渲染　802\n13.4　潜在可见集　807\n13.4.1　使用潜在可见集　808\n13.4.2　潜在可见集的其他编码方法　809\n13.4.3　流行的PVS计算方法　810\n13.5　入口　811\n13.6　包围体层次结构和八叉树　813\n13.6.1　使用BHV树　815\n13.6.2　运行性能　816\n13.6.3　选择策略　817\n13.6.4　实现BHV　818\n13.6.5　八叉树　825\n13.7　遮掩剔除　825\n13.7.1　遮掩体　826\n13.7.2　选择遮掩物　826\n13.7.3　混合型遮掩物选择方法　827\n13.8　总结　827\n第14章　阴影和光照映射　828\n14.1　新的游戏引擎模块　828\n14.2　概述　828\n14.3　简化的阴影物理学　829\n14.4　使用透视图像和广告牌来模拟阴影　832\n14.4.1　编写支持透明功能的光栅化函数　833\n14.4.2　新的库模块　835\n14.4.3　简单阴影　837\n14.4.4　缩放阴影　839\n14.4.5　跟踪光源　841\n14.4.6　有关模拟阴影的最后思考　844\n14.5　平面网格阴影映射　845\n14.5.1　计算投影变换　845\n14.5.2　优化平面阴影　848\n14.6　光照映射和面缓存技术简介　848\n14.6.1　面缓存技术　850\n14.6.2　生成光照图　850\n14.6.3　实现光照映射函数　851\n14.6.4　暗映射(dark mapping)　853\n14.6.5　光照图特效　854\n14.6.6　优化光照映射代码　854\n14.7　整理思路　854\n14.8　总结　854\n第五部分　高级动画、物理建模和优化\n第15章　3D角色动画、运动和碰撞检测　858\n15.1　新的游戏引擎模块　858\n15.2　3D动画简介　858\n15.3　Quake II .MD2文件格式　859\n15.3.1　.MD2文件头　861\n15.3.2　加载Quake II .MD2文件　868\n15.3.3　使用.MD2文件实现动画　874\n15.3.4　.MD2演示程序　882\n15.4　不基于角色的简单动画　883\n15.4.1　旋转运动和平移运动　883\n15.4.2　复杂的参数化曲线移动　885\n15.4.3　使用脚本来实现运动　885\n15.5　3D碰撞检测　887\n15.5.1　包围球和包围圆柱　887\n15.5.2　使用数据结构来提高碰撞检测的速度　888\n15.5.3　地形跟踪技术　889\n15.6　总结　890\n第16章　优化技术　891\n16.1　优化技术简介　891\n16.2　使用Microsoft Visual C++和Intel VTune剖析代码　892\n16.2.1　使用Visual C++进行剖析　892\n16.2.2　分析剖析数据　893\n16.2.3　使用VTune进行优化　894\n16.3　使用Intel C++编译器　899\n16.3.1　下载Intel的优化编译器　900\n16.3.2　使用Intel编译器　900\n16.3.3　使用编译器选项　901\n16.3.4　手工为源文件选择编译器　901\n16.3.5　优化策略　902\n16.4　SIMD编程初步　902\n16.4.1　SIMD基本体系结构　903\n16.4.2　使用SIMD　903\n16.4.3　一个SIMD 3D向量类　912\n16.5　通用优化技巧　918\n16.5.1　技巧1：消除_ftol()　918\n16.5.2　技巧2：设置FPU控制字　918\n16.5.3　技巧3：快速将浮点变量设置为零　919\n16.5.4　技巧4：快速计算平方根　919\n16.5.5　技巧5：分段线性反正切　920\n16.5.6　技巧6：指针递增运算　920\n16.5.7　技巧7：尽可能将if语句放在循环外面　921\n16.5.8　技巧8：支化(branching)流水线　921\n16.5.9　技巧9：数据对齐　921\n16.5.10　技巧10：将所有简短函数都声明为内联的　922\n16.5.11　参考文献　922\n16.6　总结　922\n第六部分　附录\n附录A　光盘内容简介　CD: 924\n附录B　安装DirectX和使用Visual C\/C++　CD: 925\nB.1　安装DirectX　CD: 925\nB.2　使用Visual C\/C++编译器　CD: 925\nB.3　编译提示　CD: 926\n附录C　三角学和向量参考　CD: 927\nC.1　三角学　CD: 927\nC.2　向量　CD: 929\nC.2.1　向量长度　CD: 930\nC.2.2　归一化　CD: 930\nC.2.3　标量乘法　CD: 930\nC.2.4　向量加法　CD: 931\nC.2.5　向量减法　CD: 931\nC.2.6　点积　CD: 932\nC.2.7　叉积　CD: 933\nC.2.8　零向量　CD: 934\nC.2.9　位置向量　CD: 934\nC.2.10　向量的线性组合　CD: 934\n附录D　C++入门　CD: 935\nD.1　C++是什么　CD: 935\nD.2　必须掌握的C++知识　CD: 937\nD.3　新的类型、关键字和约定　CD: 937\nD.3.1　注释符　CD: 937\nD.3.2　常量　CD: 937\nD.3.3　引用型变量　CD: 938\nD.3.4　即时创建变量　CD: 938\nD.4　内存管理　CD: 939\nD.5　流式输入\/输出　CD: 939\nD.6　类　CD: 941\nD.6.1　新结构　CD: 941\nD.6.2　一个简单的类　CD: 942\nD.6.3　公有和私有　CD: 942\nD.6.4　类的成员函数(方法)　CD: 943\nD.6.5　构造函数和析构函数　CD: 944\nD.6.6　编写构造函数　CD: 945\nD.6.7　编写析构函数　CD: 946\nD.7　域运算符　CD: 947\nD.8　函数和运算符重载　CD: 948\nD.9　基本模板　CD: 950\nD.10　异常处理简介　CD: 951\nD.11　总结　CD: 954\n附录E　游戏编程资源　CD: 955\nE.1　游戏编程和新闻网站　CD: 955\nE.2　下载站点　CD: 955\nE.3　2D\/3D引擎　CD: 956\nE.4　游戏编程书籍　CD: 956\nE.5　微软公司的Direct X 多媒体展示　CD: 956\nE.6　新闻组　CD: 957\nE.7　跟上行业的步伐　CD: 957\nE.8　游戏开发杂志　CD: 957\nE.9　Quake资料　CD: 957\nE.10　免费模型和纹理　CD: 957\nE.11　游戏网站开发者　CD: 957\n附录F　ASCII码表　CD: 959","pages":"922","images":{"small":"http:\/\/img5.douban.com\/spic\/s25793439.jpg","large":"http:\/\/img5.douban.com\/lpic\/s25793439.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s25793439.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1321769\/","id":"1321769","publisher":"人民邮电出版社","isbn10":"7115133719","isbn13":"9787115133717","title":"3D游戏编程大师技巧","url":"http:\/\/api.douban.com\/v2\/book\/1321769","alt_title":"Tricks of the 3D Game Programming Gurus-Advanced 3D Graphics and Rasterization","author_intro":"","summary":"《3D 游戏编程大师技巧》是游戏编程畅销书作者André LaMothe的扛鼎之作，从游戏编程和软件引擎的角度深入探讨了3D图形学的各个重要主题。全书共分5部分，包括16章的内容。第1～3章简要地介绍了Windows和DirectX编程，创建了一个Windows应用程序模板，让读者能够将精力放在游戏逻辑和图形实现中，而不用考虑Windows和DirectX方面的琐事；第4～5章简要地介绍了一些数学知识并实现了一个数学库，供以后编写演示程序时使用；第6章概述了3D图形学，让读者对《3D 游戏编程大师技巧(附光盘)》将介绍的内容有大致的了解；第7～11章分别介绍了光照、明暗处理、仿射纹理映射、3D裁剪和深度缓存等内容；第12～14章讨论了高级3D渲染技术，包括透视修正纹理映射、Alpha混合、1\/z缓存、纹理滤波、空间划分和可见性算法、阴影、光照映射等；第15～16章讨论了动画、运动碰撞检测和优化技术。\n《3D 游戏编程大师技巧》适合于有一定编程经验并想从事游戏编程工作或对3D图形学感兴趣的人员阅读。","price":"118.00元"},{"rating":{"max":10,"numRaters":171,"average":"8.6","min":0},"subtitle":"","author":["Frank D.luna"],"pubdate":"2007-4","tags":[{"count":131,"name":"游戏开发","title":"游戏开发"},{"count":93,"name":"directx","title":"directx"},{"count":70,"name":"3D","title":"3D"},{"count":43,"name":"游戏编程","title":"游戏编程"},{"count":39,"name":"图形学","title":"图形学"},{"count":30,"name":"游戏","title":"游戏"},{"count":26,"name":"编程","title":"编程"},{"count":25,"name":"C++","title":"C++"}],"origin_title":"Introduction to 3D Game Programming with DirectX 9.0","image":"http:\/\/img5.douban.com\/mpic\/s5819437.jpg","binding":"","translator":["段菲"],"catalog":"","pages":"373","images":{"small":"http:\/\/img5.douban.com\/spic\/s5819437.jpg","large":"http:\/\/img5.douban.com\/lpic\/s5819437.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s5819437.jpg"},"alt":"http:\/\/book.douban.com\/subject\/2111771\/","id":"2111771","publisher":"清华大学","isbn10":"7302130256","isbn13":"9787302130253","title":"DirectX 9.0 3D游戏开发编程基础","url":"http:\/\/api.douban.com\/v2\/book\/2111771","alt_title":"Introduction to 3D Game Programming with DirectX 9.0","author_intro":"","summary":"《DirectX 9.0 3D游戏开发编程基础》主要介绍如何使用DirectX 9.0开发交互式3D图形程序，重点是游戏开发。全书首先介绍了必要的数学工具，然后讲解了相关的3D概念。其他主题几乎涵盖了Direct3D中的所有基本运算，例如图元的绘制、光照、纹理、Alpha融合、模板，以及如何使用Direct3D实现游戏中所需的技术。介绍顶定点着色器和像素着色器的章节(包含了效果框架和新的高级着色语言的内容)对这些关键运算进行了较为集中的讨论。","price":"46.00元"},{"rating":{"max":10,"numRaters":107,"average":"8.1","min":0},"subtitle":"第二卷：运用底层语言思想编写高级语言代码","author":["海德"],"pubdate":"2007-4","tags":[{"count":78,"name":"编程","title":"编程"},{"count":40,"name":"Programming","title":"Programming"},{"count":38,"name":"程序设计","title":"程序设计"},{"count":33,"name":"底层","title":"底层"},{"count":32,"name":"计算机","title":"计算机"},{"count":23,"name":"编程卓越之道","title":"编程卓越之道"},{"count":23,"name":"汇编","title":"汇编"},{"count":21,"name":"计算机科学","title":"计算机科学"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s24637474.jpg","binding":"","translator":["张菲"],"catalog":"","pages":"617","images":{"small":"http:\/\/img3.douban.com\/spic\/s24637474.jpg","large":"http:\/\/img3.douban.com\/lpic\/s24637474.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s24637474.jpg"},"alt":"http:\/\/book.douban.com\/subject\/2082177\/","id":"2082177","publisher":"电子工业","isbn10":"7121041251","isbn13":"9787121041259","title":"编程卓越之道","url":"http:\/\/api.douban.com\/v2\/book\/2082177","alt_title":"","author_intro":"Randall Hyde是汇编语言的相关书籍中最受推崇的《The Arf of Assembly Language》(No Starch出版社出版)的作者。他同时还是《The Waite Group's MASM 6．0 Bible》的联合作者，《Dr.Dobb's Journal》和《Byte》专业周刊的撰稿人。","summary":"《编程卓越之道第二卷:运用底层语言思想编写高级语言代码》是《编程卓越之道》系列书的第二卷，将探讨怎样用高级语言（而非汇编语言）编程得到高效率机器代码。在书中，您可以学到如何分析编译器的输出，以便检验代码的所作所为，从而得到高质量的机器码；了解编译器为常见控制结构生成的典型机器指令，以便在编写高级语言程序时选用恰当的语句；掌握编译器将各种常量和变量类型转换成机器数据的方法，以便于使用这些数据写出又快又短的程序。","price":"69.00元"},{"rating":{"max":10,"numRaters":140,"average":"8.5","min":0},"subtitle":"","author":["Andre Lamothe"],"pubdate":"2004-2-1","tags":[{"count":118,"name":"游戏开发","title":"游戏开发"},{"count":48,"name":"游戏","title":"游戏"},{"count":41,"name":"编程","title":"编程"},{"count":40,"name":"游戏编程","title":"游戏编程"},{"count":34,"name":"windows","title":"windows"},{"count":29,"name":"Windows编程","title":"Windows编程"},{"count":25,"name":"计算机","title":"计算机"},{"count":18,"name":"3D","title":"3D"}],"origin_title":"Tricks of the Windows Game Programming Gurus, 2nd Edition","image":"http:\/\/img3.douban.com\/mpic\/s1270644.jpg","binding":"平装（带盘）","translator":["沙鹰"],"catalog":"","pages":"807","images":{"small":"http:\/\/img3.douban.com\/spic\/s1270644.jpg","large":"http:\/\/img3.douban.com\/lpic\/s1270644.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s1270644.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1230286\/","id":"1230286","publisher":"中国电力出版社","isbn10":"7508318277","isbn13":"9787508318271","title":"WINDOWS游戏编程大师技巧<第2版>(附光盘)","url":"http:\/\/api.douban.com\/v2\/book\/1230286","alt_title":"Tricks of the Windows Game Programming Gurus, 2nd Edition","author_intro":"","summary":"《WINDOWS游戏编程大师技巧》(第2版）介绍了在Windows环境下进行游戏编程所需用到的各方面知识，作者是著名的游戏开发大师Andrè LaMothe，他的每一本作品基本上都被视为游戏编程书籍的镇山之作。本书第一版的中文版自面市以来获得了广泛好评，持续热销，多次重印。此次修订在多方面更新了第一版中的内容，并且清除了拼写和技术错误，使用DirectX的最新版本来配合编译本书所带的程序代码，加入了大量新内容，例如关于16 位RGB 高彩模式的更多细节及众多新增的解释，还有一个新章节专门讨论文本解析（text parsing）。总之，这是《Windows游戏编程大师技巧》的一个更加清楚、更加完全的版本。","price":"89.00元"},{"rating":{"max":10,"numRaters":131,"average":"8.4","min":0},"subtitle":"","author":["[美] Dave Shreiner"],"pubdate":"2010-3","tags":[{"count":141,"name":"opengl","title":"opengl"},{"count":101,"name":"计算机图形学","title":"计算机图形学"},{"count":47,"name":"编程","title":"编程"},{"count":42,"name":"计算机","title":"计算机"},{"count":38,"name":"红宝书","title":"红宝书"},{"count":32,"name":"图形学","title":"图形学"},{"count":30,"name":"Programming","title":"Programming"},{"count":26,"name":"图像处理","title":"图像处理"}],"origin_title":"OpenGL programming guide","image":"http:\/\/img3.douban.com\/mpic\/s6143451.jpg","binding":"平装","translator":["李军","徐波 [等]"],"catalog":"译者序前言第1章  OpenGL简介  1.1  什么是OpenGL  1.2  一段简单的OpenGL代码  1.3  OpenGL函数的语法  1.4  OpenGL是一个状态机  1.5  OpenGL渲染管线    1.5.1  显示列表    1.5.2  求值器    1.5.3  基于顶点的操作    1.5.4  图元装配    1.5.5  像素操作    1.5.6  纹理装配    1.5.7  光栅化    1.5.8  片断操作  1.6  与OpenGL相关的函数库    1.6.1  包含文件    1.6.2  OpenGL实用工具库(GLuT)  1.7  动画    1.7.1  暂停刷新    1.7.2  动画＝重绘＋交换  1.8  OpenGL及其废弃机制    1.8.1  OpenGL渲染环境    1.8.2  访问OpenGL函数第2章  状态管理和绘制几何物体  2.1  绘图工具箱    2.1.1  清除窗口    2.1.2  指定颜色    2.1.3  强制完成绘图操作    2.1.4  坐标系统工具箱  2.2  描述点、直线和多边形    2.2.1  什么是点、直线和多边形    2.2.2  指定顶点    2.2.3  OpenGL几何图元  2.3  基本状态管理  2.4  显示点、直线和多边形    2.4.1  点的细节    2.4.2  直线的细节    2.4.3  多边形的细节  2.5  法线向量  2.6  顶点数组    2.6.1  步骤1：启用数组    2.6.2  步骤2：指定数组的数据    2.6.3  步骤3：解引用和渲染    2.6.4  重启图元    2.6.5  实例化绘制    2.6.6  混合数组    ……第3章　视图第4章　颜色第5章　光照第6章　混合、抗锯齿、雾和多边形偏移第7章　显示列表第8章　绘制像素、位图、字体和图像第9章　纹理贴图第10章　帧缓冲区第11章　分格化和二次方程表面第12章　求值器和NURBS第13章　选择和反馈第14章　OpenGL高级技巧第15章　OpenGL着色语言附录A　GLUT(OpenGL实用工具库)基础知识附录B　状态变量附录C　齐次坐标和变换矩阵附录D　OpenGL和窗口系统术语表","pages":"519","images":{"small":"http:\/\/img3.douban.com\/spic\/s6143451.jpg","large":"http:\/\/img3.douban.com\/lpic\/s6143451.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s6143451.jpg"},"alt":"http:\/\/book.douban.com\/subject\/4311129\/","id":"4311129","publisher":"机械工业出版社","isbn10":"7111294505","isbn13":"9787111294504","title":"OpenGL编程指南（原书第7版）","url":"http:\/\/api.douban.com\/v2\/book\/4311129","alt_title":"OpenGL programming guide","author_intro":"Dave Shreiner是ARM公司的图形技术总监，长期担任SGI核心OpenGL组的成员。他首次开设了OpenGL的商业培训课程，拥有二十多年的计算机图形应用开发经验。Dava定期参加SIGGRAPH和其他全球性的图形工作会议。他是《OpenGL ES 2.0 Programming Guide》和《OpenGL Reference Manual》的作者，也是Addison-Wesley的OpenGL系列的编辑。","summary":"《Open GL编程指南(原书第7版)》对OpenGL以及OpenGL实用函数库进行了全面而又权威的介绍，素有“OpenGL红宝书”之誉。《Open GL编程指南(原书第7版)》的上一个版本覆盖了到OpenGL 2.1版的内容。本版涵盖了OpenGL 3.0和3.1的最新特性。《Open GL编程指南(原书第7版)》以清晰的语言描述了OpenGL的功能以及许多基本的计算机图形技巧，例如创建和渲染3D模型、从不同的透视角度观察物体、使用着色、光照和纹理贴图使场景更加逼真等。另外，《Open GL编程指南(原书第7版)》还深入探讨了许多高级技巧，包括纹理贴图、抗锯齿、雾和大气效果、NURBS、图像处理子集等。此外，《Open GL编程指南(原书第7版)》还对一些重要的主题进行了讨论，例如提高性能、OpenGL扩展以及跨平台技术等。《Open GL编程指南(原书第7版)》内容详实，讲解生动，图文并茂，是OpenGL程序员的绝佳编程指南。","price":"89.00元"},{"rating":{"max":10,"numRaters":89,"average":"8.7","min":0},"subtitle":"","author":["[美] Richard Blum","[美] Christine Bresnahan"],"pubdate":"2012-9","tags":[{"count":170,"name":"Linux","title":"Linux"},{"count":156,"name":"shell","title":"shell"},{"count":60,"name":"编程","title":"编程"},{"count":46,"name":"计算机","title":"计算机"},{"count":28,"name":"linux","title":"linux"},{"count":22,"name":"Shell","title":"Shell"},{"count":20,"name":"Linux\/Unix","title":"Linux\/Unix"},{"count":18,"name":"programming","title":"programming"}],"origin_title":"Linux Command Line and Shell Scripting Bible, Second Edition","image":"http:\/\/img5.douban.com\/mpic\/s11171426.jpg","binding":"平装","translator":["武海峰"],"catalog":"目　　录\n第一部分　Linux 命令行\n第1章　初识Linux shell\t2\n1.1　什么是Linux\t2\n1.1.1　深入探究Linux内核\t3\n1.1.2　GNU工具链\t10\n1.1.3　Linux桌面环境\t11\n1.2　Linux发行版\t16\n1.2.1　核心Linux发行版\t16\n1.2.2　专业Linux发行版\t17\n1.2.3　Linux LiveCD\t17\n1.3　小结\t19\n第2章　走进shell\t20\n2.1　终端模拟\t20\n2.1.1　图形功能\t21\n2.1.2　键盘\t24\n2.2　terminfo数据库\t25\n2.3　Linux控制台\t28\n2.4　xterm终端\t29\n2.4.1　命令行参数\t30\n2.4.2　xterm主菜单\t31\n2.4.3　VT选项菜单\t32\n2.4.4　VT字体菜单\t34\n2.5　Konsole终端\t36\n2.5.1　命令行参数\t36\n2.5.2　标签式窗口会话\t37\n2.5.3　配置文件\t38\n2.5.4　菜单栏\t39\n2.6　GNOME Terminal\t43\n2.6.1　命令行参数\t43\n2.6.2　标签\t43\n2.6.3　菜单栏\t44\n2.7　小结\t47\n第3章　基本的bash shell命令\t48\n3.1　启动shell\t48\n3.2　shell提示符\t49\n3.3　bash手册\t51\n3.4　浏览文件系统\t52\n3.4.1　Linux文件系统\t52\n3.4.2　遍历目录\t54\n3.5　文件和目录列表\t56\n3.5.1　基本列表功能\t56\n3.5.2　修改输出信息\t57\n3.5.3　完整的参数列表\t58\n3.5.4　过滤输出列表\t60\n3.6　处理文件\t61\n3.6.1　创建文件\t61\n3.6.2　复制文件\t61\n3.6.3　链接文件\t63\n3.6.4　重命名文件\t65\n3.6.5　删除文件\t65\n3.7　处理目录\t67\n3.7.1　创建目录\t67\n3.7.2　删除目录\t67\n3.8　查看文件内容\t68\n3.8.1　查看文件统计信息\t68\n3.8.2　查看文件类型\t69\n3.8.3　查看整个文件\t69\n3.8.4　查看部分文件\t72\n3.9　小结\t73\n第4章　更多的bash shell命令\t75\n4.1　监测程序\t75\n4.1.1　探查进程\t75\n4.1.2　实时监测进程\t82\n4.1.3　结束进程\t84\n4.2　监测磁盘空间\t85\n4.2.1　挂载存储媒体\t86\n4.2.2　使用df命令\t89\n4.2.3　使用du命令\t89\n4.3　处理数据文件\t90\n4.3.1　排序数据\t91\n4.3.2　搜索数据\t94\n4.3.3　压缩数据\t96\n4.3.4　归档数据\t99\n4.4　小结\t100\n第5章　使用Linux环境变量\t101\n5.1　什么是环境变量\t101\n5.1.1　全局环境变量\t102\n5.1.2　局部环境变量\t103\n5.2　设置环境变量\t106\n5.2.1　设置局部环境变量\t106\n5.2.2　设置全局环境变量\t107\n5.3　删除环境变量\t107\n5.4　默认shell环境变量\t108\n5.5　设置PATH环境变量\t111\n5.6　定位系统环境变量\t112\n5.6.1　登录shell\t112\n5.6.2　交互式shell\t116\n5.6.3　非交互式shell\t118\n5.7　可变数组\t118\n5.8　使用命令别名\t119\n5.9　小结\t120\n第6章　理解Linux文件权限\t122\n6.1　Linux的安全性\t122\n6.1.1　\/etc\/passwd文件\t122\n6.1.2　\/etc\/shadow文件\t124\n6.1.3　添加新用户\t125\n6.1.4　删除用户\t127\n6.1.5　修改用户\t128\n6.2　使用Linux组\t130\n6.2.1　\/etc\/group文件\t131\n6.2.2　创建新组\t131\n6.2.3　修改组\t132\n6.3　理解文件权限\t133\n6.3.1　使用文件权限符\t133\n6.3.2　默认文件权限\t134\n6.4　改变安全性设置\t136\n6.4.1　改变权限\t136\n6.4.2　改变所属关系\t137\n6.5　共享文件\t138\n6.6　小结\t139\n第7章　管理文件系统\t141\n7.1　探索Linux文件系统\t141\n7.1.1　基本的Linux文件系统\t141\n7.1.2　日志文件系统\t142\n7.1.3　扩展的Linux日志文件系统\t143\n7.2　操作文件系统\t145\n7.2.1　创建分区\t145\n7.2.2　创建文件系统\t147\n7.2.3　如果出错了\t149\n7.3　逻辑卷管理器\t150\n7.3.1　逻辑卷管理布局\t150\n7.3.2　Linux中的LVM\t151\n7.3.3　使用Linux LVM\t153\n7.4　小结\t157\n第8章　安装软件程序\t158\n8.1　包管理基础\t158\n8.2　基于Debian的系统\t159\n8.2.1　用aptitude管理软件包\t159\n8.2.2　用aptitude安装软件包\t161\n8.2.3　用aptitude更新软件\t163\n8.2.4　用aptitude卸载软件\t164\n8.2.5　aptitude库\t164\n8.3　基于Red Hat的系统\t166\n8.3.1　列出已安装包\t166\n8.3.2　用yum安装软件\t167\n8.3.3　用yum更新软件\t168\n8.3.4　用yum卸载软件\t169\n8.3.5　处理损坏的包依赖关系\t169\n8.3.6　yum软件库\t171\n8.4　从源码安装\t172\n8.5　小结\t174\n第9章　使用编辑器\t176\n9.1　Vim编辑器\t176\n9.1.1　Vim基础\t176\n9.1.2　编辑数据\t178\n9.1.3　复制和粘贴\t179\n9.1.4　查找和替换\t180\n9.2　Emacs编辑器\t180\n9.2.1　在控制台上使用Emacs\t180\n9.2.2　在X Window中使用Emacs\t185\n9.3　KDE系编辑器\t186\n9.3.1　KWrite编辑器\t186\n9.3.2　Kate编辑器\t190\n9.4　GNOME编辑器\t192\n9.4.1　启动gedit\t192\n9.4.2　基本的gedit功能\t193\n9.4.3　设定偏好设置\t194\n9.5　小结\t196\n第二部分　shell脚本编程基础\n第10章　构建基本脚本\t200\n10.1　使用多个命令\t200\n10.2　创建shell脚本文件\t201\n10.3　显示消息\t202\n10.4　使用变量\t203\n10.4.1　环境变量\t204\n10.4.2　用户变量\t205\n10.4.3　反引号\t206\n10.5　重定向输入和输出\t207\n10.5.1　输出重定向\t208\n10.5.2　输入重定向\t208\n10.6　管道\t209\n10.7　执行数学运算\t212\n10.7.1　expr命令\t212\n10.7.2　使用方括号\t214\n10.7.3　浮点解决方案\t215\n10.8　退出脚本\t218\n10.8.1　查看退出状态码\t218\n10.8.2　exit命令\t219\n10.9　小结\t221\n第11章　使用结构化命令\t222\n11.1　使用if-then语句\t222\n11.2　if-then-else语句\t224\n11.3　嵌套if\t225\n11.4　test命令\t226\n11.4.1　数值比较\t227\n11.4.2　字符串比较\t228\n11.4.3　文件比较\t232\n11.5　复合条件测试\t239\n11.6　if-then的高级特性\t240\n11.6.1　使用双尖括号\t240\n11.6.2　使用双方括号\t241\n11.7　case命令\t242\n11.8　小结\t243\n第12章　更多的结构化命令\t245\n12.1　for命令\t245\n12.1.1　读取列表中的值\t246\n12.1.2　读取列表中的复杂值\t247\n12.1.3　从变量读取列表\t248\n12.1.4　从命令读取值\t249\n12.1.5　更改字段分隔符\t250\n12.1.6　用通配符读取目录\t251\n12.2　C语言风格的for命令\t253\n12.2.1　C语言的for命令\t253\n12.2.2　使用多个变量\t255\n12.3　while命令\t255\n12.3.1　while的基本格式\t255\n12.3.2　使用多个测试命令\t256\n12.4　until命令\t258\n12.5　嵌套循环\t259\n12.6　循环处理文件数据\t261\n12.7　控制循环\t262\n12.7.1　break命令\t262\n12.7.2　continue命令\t265\n12.8　处理循环的输出\t267\n12.9　小结\t269\n第13章　处理用户输入\t270\n13.1　命令行参数\t270\n13.1.1　读取参数\t270\n13.1.2　读取程序名\t272\n13.1.3　测试参数\t274\n13.2　特殊参数变量\t274\n13.2.1　参数计数\t274\n13.2.2　抓取所有的数据\t276\n13.3　移动变量\t277\n13.4　处理选项\t278\n13.4.1　查找选项\t279\n13.4.2　使用getopt命令\t282\n13.4.3　使用更高级的getopts\t284\n13.5　将选项标准化\t286\n13.6　获得用户输入\t287\n13.6.1　基本的读取\t287\n13.6.2　超时\t289\n13.6.3　隐藏方式读取\t290\n13.6.4　从文件中读取\t290\n13.7　小结\t291\n第14章　呈现数据\t293\n14.1　理解输入和输出\t293\n14.1.1　标准文件描述符\t293\n14.1.2　重定向错误\t295\n14.2　在脚本中重定向输出\t297\n14.2.1　临时重定向\t297\n14.2.2　永久重定向\t298\n14.3　在脚本中重定向输入\t299\n14.4　创建自己的重定向\t299\n14.4.1　创建输出文件描述符\t300\n14.4.2　重定向文件描述符\t300\n14.4.3　创建输入文件描述符\t301\n14.4.4　创建读写文件描述符\t302\n14.4.5　关闭文件描述符\t303\n14.5　列出打开的文件描述符\t304\n14.6　阻止命令输出\t305\n14.7　创建临时文件\t306\n14.7.1　创建本地临时文件\t306\n14.7.2　在\/tmp目录创建临时文件\t308\n14.7.3　创建临时目录\t308\n14.8　记录消息\t309\n14.9　小结\t310\n第15章　控制脚本\t312\n15.1　处理信号\t312\n15.1.1　重温Linux信号\t312\n15.1.2　产生信号\t313\n15.1.3　捕捉信号\t314\n15.1.4　捕捉脚本的退出\t315\n15.1.5　移除捕捉\t316\n15.2　以后台模式运行脚本\t317\n15.2.1　后台运行脚本\t317\n15.2.2　运行多个后台作业\t318\n15.2.3　退出终端\t319\n15.3　在非控制台下运行脚本\t319\n15.4　作业控制\t320\n15.4.1　查看作业\t320\n15.4.2　重启停止的作业\t322\n15.5　调整谦让度\t323\n15.5.1　nice命令\t323\n15.5.2　renice命令\t324\n15.6　定时运行作业\t324\n15.6.1　用at命令来计划执行作业\t325\n15.6.2　计划定期执行脚本\t328\n15.7　启动时运行\t330\n15.7.1　开机时运行脚本\t330\n15.7.2　在新shell中启动\t332\n15.8　小结\t333\n第三部分　高级shell脚本编程\n第16章　创建函数\t336\n16.1　基本的脚本函数\t336\n16.1.1　创建函数\t337\n16.1.2　使用函数\t337\n16.2　返回值\t339\n16.2.1　默认退出状态码\t339\n16.2.2　使用return命令\t340\n16.2.3　使用函数输出\t341\n16.3　在函数中使用变量\t342\n16.3.1　向函数传递参数\t342\n16.3.2　在函数中处理变量\t344\n16.4　数组变量和函数\t346\n16.4.1　向函数传数组参数\t346\n16.4.2　从函数返回数组\t348\n16.5　函数递归\t349\n16.6　创建库\t350\n16.7　在命令行上使用函数\t351\n16.7.1　在命令行上创建函数\t352\n16.7.2　在.bashrc文件中定义函数\t352\n16.8　小结\t354\n第17章　图形化桌面上的脚本编程\t355\n17.1　创建文本菜单\t355\n17.1.1　创建菜单布局\t356\n17.1.2　创建菜单函数\t356\n17.1.3　添加菜单逻辑\t357\n17.1.4　整合shell脚本菜单\t358\n17.1.5　使用select命令\t359\n17.2　使用窗口\t360\n17.2.1　dialog包\t361\n17.2.2　dialog选项\t366\n17.2.3　在脚本中使用dialog命令\t368\n17.3　使用图形\t369\n17.3.1　KDE环境\t369\n17.3.2　GNOME环境\t372\n17.4　小结\t376\n第18章　初识sed和gawk\t377\n18.1　文本处理\t377\n18.1.1　sed编辑器\t377\n18.1.2　gawk程序\t380\n18.2　sed编辑器基础\t385\n18.2.1　更多的替换选项\t385\n18.2.2　使用地址\t387\n18.2.3　删除行\t389\n18.2.4　插入和附加文本\t391\n18.2.5　修改行\t392\n18.2.6　转换命令\t393\n18.2.7　回顾打印\t394\n18.2.8　用sed和文件一起工作\t396\n18.3　小结\t398\n第19章　正则表达式\t399\n19.1　什么是正则表达式\t399\n19.1.1　定义\t399\n19.1.2　正则表达式的类型\t400\n19.2　定义BRE模式\t401\n19.2.1　纯文本\t401\n19.2.2　特殊字符\t402\n19.2.3　锚字符\t403\n19.2.4　点字符\t405\n19.2.5　字符组\t405\n19.2.6　排除字符组\t407\n19.2.7　使用区间\t408\n19.2.8　特殊字符组\t409\n19.2.9　星号\t409\n19.3　扩展正则表达式\t411\n19.3.1　问号\t411\n19.3.2　加号\t412\n19.3.3　使用花括号\t412\n19.3.4　管道符号\t413\n19.3.5　聚合表达式\t414\n19.4　实用中的正则表达式\t414\n19.4.1　目录文件计数\t415\n19.4.2　验证电话号码\t416\n19.4.3　解析邮件地址\t417\n19.5　小结\t419\n第20章　sed进阶\t420\n20.1　多行命令\t420\n20.1.1　next命令\t421\n20.1.2　多行删除命令\t424\n20.1.3　多行打印命令\t424\n20.2　保持空间\t425\n20.3　排除命令\t426\n20.4　改变流\t428\n20.4.1　跳转\t429\n20.4.2　测试\t430\n20.5　模式替代\t431\n20.5.1　and符号\t431\n20.5.2　替换单独的单词\t432\n20.6　在脚本中使用sed\t433\n20.6.1　使用包装脚本\t433\n20.6.2　重定向sed的输出\t434\n20.7　创建sed实用工具\t434\n20.7.1　加倍行间距\t434\n20.7.2　对可能含有空白行的文件加倍行间距\t435\n20.7.3　给文件中的行编号\t436\n20.7.4　打印末尾行\t437\n20.7.5　删除行\t437\n20.7.6　删除HTML标签\t439\n20.8　小结\t441\n第21章　gawk进阶\t442\n21.1　使用变量\t442\n21.1.1　内建变量\t442\n21.1.2　自定义变量\t447\n21.2　处理数组\t449\n21.2.1　定义数组变量\t449\n21.2.2　遍历数组变量\t450\n21.2.3　删除数组变量\t451\n21.3　使用模式\t451\n21.3.1　正则表达式\t451\n21.3.2　匹配操作符\t452\n21.3.3　数学表达式\t452\n21.4　结构化命令\t453\n21.4.1　if语句\t453\n21.4.2　while语句\t455\n21.4.3　do-while语句\t456\n21.4.4　for语句\t457\n21.5　格式化打印\t457\n21.6　内建函数\t460\n21.6.1　数学函数\t460\n21.6.2　字符串函数\t461\n21.6.3　时间函数\t463\n21.7　自定义函数\t463\n21.7.1　定义函数\t463\n21.7.2　使用自定义函数\t464\n21.7.3　创建函数库\t464\n21.8　小结\t465\n第22章　使用其他shell\t467\n22.1　什么是dash shell\t467\n22.2　dash shell的特性\t468\n22.2.1　dash命令行参数\t468\n22.2.2　dash环境变量\t469\n22.2.3　dash内建命令\t471\n22.3　dash脚本编程\t472\n22.3.1　创建dash脚本\t473\n22.3.2　不能使用的功能\t473\n22.4　zsh shell\t477\n22.5　zsh shell的组成\t478\n22.5.1　shell选项\t478\n22.5.2　内建命令\t480\n22.6　zsh脚本编程\t485\n22.6.1　数学运算\t485\n22.6.2　结构化命令\t487\n22.6.3　函数\t487\n22.7　小结\t489\n第四部分　高级shell脚本编程主题\n第23章　使用数据库\t492\n23.1　MySQL数据库\t492\n23.1.1　安装MySQL\t492\n23.1.2　MySQL客户端界面\t494\n23.1.3　创建MySQL数据库对象\t498\n23.2　PostgreSQL数据库\t500\n23.2.1　安装PostgreSQL\t501\n23.2.2　PostgreSQL命令行界面\t501\n23.2.3　创建PostgreSQL数据库对象\t503\n23.3　使用数据表\t505\n23.3.1　创建数据表\t505\n23.3.2　插入和删除数据\t507\n23.3.3　查询数据\t508\n23.4　在脚本中使用数据库\t509\n23.4.1　连接到数据库\t509\n23.4.2　向服务器发送命令\t511\n23.4.3　格式化数据\t514\n23.5　小结\t516\n第24章　使用Web\t517\n24.1　Lynx程序\t517\n24.1.1　安装Lynx\t518\n24.1.2　lynx命令行\t518\n24.1.3　Lynx配置文件\t523\n24.1.4　Lynx环境变量\t524\n24.1.5　从Lynx中抓取数据\t524\n24.2　cURL程序\t527\n24.2.1　安装cURL\t527\n24.2.2　探索cURL\t527\n24.3　使用zsh处理网络\t528\n24.3.1　TCP模块\t528\n24.3.2　客户端\/服务器模式\t529\n24.3.3　使用zsh进行C\/S编程\t530\n24.4　小结\t533\n第25章　使用E-mail\t534\n25.1　Linux E-mail基础\t534\n25.1.1　Linux中的E-mail\t534\n25.1.2　邮件传送代理\t535\n25.1.3　邮件投递代理\t536\n25.1.4　邮件用户代理\t537\n25.2　建立服务器\t540\n25.2.1　sendmail\t541\n25.2.2　Postfix\t543\n25.3　使用Mailx发送消息\t545\n25.4　Mutt程序\t548\n25.4.1　安装Mutt\t548\n25.4.2　Mutt命令行\t548\n25.4.3　使用Mutt\t549\n25.5　小结\t551\n第26章　编写脚本实用工具\t552\n26.1　监测磁盘空间\t552\n26.1.1　需要的功能\t552\n26.1.2　创建脚本\t555\n26.1.3　运行脚本\t556\n26.2　进行备份\t557\n26.3　管理用户账户\t563\n26.3.1　需要的功能\t563\n26.3.2　创建脚本\t569\n26.4　小结\t575\n第27章　shell脚本编程进阶\t576\n27.1　监测系统统计数据\t576\n27.1.1　系统快照报告\t576\n27.1.2　系统统计数据报告\t582\n27.2　问题跟踪数据库\t589\n27.2.1　创建数据库\t589\n27.2.2　记录问题\t591\n27.2.3　更新问题\t594\n27.2.4　查找问题\t599\n27.3　小结\t602\n附录A　bash命令快速指南\t604\n附录B　sed和gawk快速指南\t611\n","pages":"619","images":{"small":"http:\/\/img5.douban.com\/spic\/s11171426.jpg","large":"http:\/\/img5.douban.com\/lpic\/s11171426.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s11171426.jpg"},"alt":"http:\/\/book.douban.com\/subject\/11589828\/","id":"11589828","publisher":"人民邮电出版社","isbn10":"7115288895","isbn13":"9787115288899","title":"Linux命令行与shell脚本编程大全","url":"http:\/\/api.douban.com\/v2\/book\/11589828","alt_title":"Linux Command Line and Shell Scripting Bible, Second Edition","author_intro":"Richard Blum 系统和网络管理员，已经在IT行业工作了22年多。他管理过UNIX、Linux、Novell和微软服务器，用Linux shell脚本进行过自动化网络监测，并在大多数常见的Linux shell环境中写过脚本。他还是一名网络课程讲师，美国各地的多所大学和学院都采用他的Linux基础课程。除本书外，Richard还著有Professional Linux Programming等书。\nChristine Bresnahan 系统管理员，已经在IT行业工作了近30年。目前在印第安纳波利斯市的常春藤技术社区学院担任兼职教授，讲授Linux系统管理、Linux安全和Windows安全等课程。\n武海峰 Linux系统工程师，兴趣集中在GNU\/Linux和移动互联应用，热衷于开源软件。曾在商业Linux厂商任职，从事移动设备操作系统集成和商业Linux发行版集成工作。","summary":"《Linux命令行与shell脚本编程大全(第2版)》是一本关于Linux命令行与shell脚本编程的全面教程。本书主要内容包括：在命令行上工作并学习基本的shell命令；编写shell脚本来实现日常工作和报告的自动化；控制如何以及何时在系统上运行she¨脚本：学习shell脚本中操作数据的高级方法；修改脚本适应图形化桌面和其他Linux shell；从网站提取数据并在系统间发送数据：创建有专业水准的shell脚本，适应现实环境的挑战。\n《Linux命令行与shell脚本编程大全(第2版)》不仅涵盖了详尽的动手教程和现实世界中的实用信息，还提供了与所学内容相关的参考信息和背景资料。","price":"99.00元"},{"rating":{"max":10,"numRaters":195,"average":"6.8","min":0},"subtitle":"","author":["梁肇新"],"pubdate":"2003-11-1","tags":[{"count":87,"name":"编程","title":"编程"},{"count":49,"name":"计算机","title":"计算机"},{"count":31,"name":"梁肇新","title":"梁肇新"},{"count":26,"name":"程序设计","title":"程序设计"},{"count":23,"name":"编程高手箴言","title":"编程高手箴言"},{"count":18,"name":"程序人生","title":"程序人生"},{"count":14,"name":"软件开发","title":"软件开发"},{"count":13,"name":"programming","title":"programming"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s1409650.jpg","binding":"平装（带盘）","translator":[],"catalog":"第一章 程序点滴\n第二章 认识CPU\n第三章 Windos 运行机理\n第四章 编程语言的运行机理\n第五章 代码的规范和风格\n第六章 分析方法\n第七章 调试方法 \n第八章 内核优化","pages":"432","images":{"small":"http:\/\/img3.douban.com\/spic\/s1409650.jpg","large":"http:\/\/img3.douban.com\/lpic\/s1409650.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s1409650.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1139244\/","id":"1139244","publisher":"电子工业出版社","isbn10":"7505391410","isbn13":"9787505391413","title":"编程高手箴言","url":"http:\/\/api.douban.com\/v2\/book\/1139244","alt_title":"","author_intro":"","summary":"\n      ","price":"50.00元"},{"rating":{"max":10,"numRaters":96,"average":"8.9","min":0},"subtitle":"","author":["WRichardStevens"],"pubdate":"2000-3","tags":[{"count":124,"name":"UNIX","title":"UNIX"},{"count":57,"name":"网络编程","title":"网络编程"},{"count":35,"name":"网络","title":"网络"},{"count":31,"name":"编程","title":"编程"},{"count":28,"name":"计算机","title":"计算机"},{"count":26,"name":"Linux","title":"Linux"},{"count":23,"name":"programming","title":"programming"},{"count":18,"name":"network","title":"network"}],"origin_title":"","image":"http:\/\/img5.douban.com\/mpic\/s9809609.jpg","binding":"简裝本","translator":[],"catalog":"","pages":"479","images":{"small":"http:\/\/img5.douban.com\/spic\/s9809609.jpg","large":"http:\/\/img5.douban.com\/lpic\/s9809609.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s9809609.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1119351\/","id":"1119351","publisher":"清华大学","isbn10":"7302038155","isbn13":"9787302038153","title":"UNIX网络编程第2卷","url":"http:\/\/api.douban.com\/v2\/book\/1119351","alt_title":"","author_intro":"","summary":"UNIX网络编程：第2版（第2卷 进程间通信），ISBN：9787302038153，作者：（美）[W.R.史蒂文斯]W.Richard Stevens著；杨继张译","price":"58.00元"},{"rating":{"max":10,"numRaters":148,"average":"8.6","min":0},"subtitle":"","author":["埃克尔"],"pubdate":"2002-1-1","tags":[{"count":136,"name":"C++","title":"C++"},{"count":53,"name":"编程","title":"编程"},{"count":45,"name":"计算机","title":"计算机"},{"count":26,"name":"程序设计","title":"程序设计"},{"count":21,"name":"programming","title":"programming"},{"count":20,"name":"OOP","title":"OOP"},{"count":17,"name":"C\/C++","title":"C\/C++"},{"count":10,"name":"经典","title":"经典"}],"origin_title":"Thinking in C++","image":"http:\/\/img3.douban.com\/mpic\/s5678745.jpg","binding":"平装（带盘）","translator":[],"catalog":"Preface\n1: Introduction to Objects\n2: Making & Using Objects\n3: The C in C++\n4: Date Abstraction\n5: Hiding the Implementation\n6: Initialization & Cleanup\n7: Function Overloading & Default\n8: Constants\n9: Inline Functions\n10: Name Control\n11: References & the Copy-Constructor\n12: Operator\n13: Dynamic Object Creation\n14: Inheritance & Composition\n15: Polymorphism & Virtual Functions\n16: Introduction to Templates\nA: Coding Style\nB: Programming Guidelines\nC: Recommended Reading\nIndex","pages":"801","images":{"small":"http:\/\/img3.douban.com\/spic\/s5678745.jpg","large":"http:\/\/img3.douban.com\/lpic\/s5678745.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s5678745.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1094797\/","id":"1094797","publisher":"机械工业出版社","isbn10":"7111091620","isbn13":"9787111091622","title":"C++编程思想","url":"http:\/\/api.douban.com\/v2\/book\/1094797","alt_title":"Thinking in C++","author_intro":"","summary":"C++编程思想（英文本），ISBN：9787111091622，作者：（美）Bruce Eckel著","price":"58.00元"},{"rating":{"max":10,"numRaters":88,"average":"7.6","min":0},"subtitle":"","author":["斯基纳"],"pubdate":"2009-7","tags":[{"count":88,"name":"算法","title":"算法"},{"count":50,"name":"编程","title":"编程"},{"count":46,"name":"ACM","title":"ACM"},{"count":23,"name":"计算机","title":"计算机"},{"count":17,"name":"计算机科学","title":"计算机科学"},{"count":17,"name":"挑战编程程序设计竞赛训练手册","title":"挑战编程程序设计竞赛训练手册"},{"count":14,"name":"程序设计","title":"程序设计"},{"count":13,"name":"Algorithm","title":"Algorithm"}],"origin_title":"Programming Challenges: The Programming Contest Training Manual","image":"http:\/\/img3.douban.com\/mpic\/s6050343.jpg","binding":"","translator":["刘汝佳"],"catalog":"","pages":"302","images":{"small":"http:\/\/img3.douban.com\/spic\/s6050343.jpg","large":"http:\/\/img3.douban.com\/lpic\/s6050343.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s6050343.jpg"},"alt":"http:\/\/book.douban.com\/subject\/3879470\/","id":"3879470","publisher":"","isbn10":"7302197970","isbn13":"9787302197973","title":"挑战编程","url":"http:\/\/api.douban.com\/v2\/book\/3879470","alt_title":"Programming Challenges: The Programming Contest Training Manual","author_intro":"","summary":"《挑战编程:程序设计竞赛训练手册》分为14章，分别介绍在线评测系统的基本使用方法、数据结构、字符串、排序、算术与代数、组合数学、数论、回溯法、图遍历、图算法、动态规划、网格、几何，以及计算几何，并在附录中介绍了一些著名的程序设计竞赛以及相应的备赛建议与比赛技巧。每章的正文用十余页的篇幅覆盖了该领域最核心的概念和算法，然后给出八道可在线提交的完整编程挑战题目供读者练习。\n全书内容紧凑、信息量大，是各类程序设计竞赛的选手与教练不可多得的参考书。","price":"39.00元"},{"rating":{"max":10,"numRaters":70,"average":"9.1","min":0},"subtitle":"","author":["巴克兰德 (Mat Buckland)"],"pubdate":"2008-6","tags":[{"count":110,"name":"游戏开发","title":"游戏开发"},{"count":74,"name":"人工智能","title":"人工智能"},{"count":74,"name":"AI","title":"AI"},{"count":41,"name":"游戏","title":"游戏"},{"count":22,"name":"编程","title":"编程"},{"count":20,"name":"游戏编程","title":"游戏编程"},{"count":16,"name":"game","title":"game"},{"count":10,"name":"计算机","title":"计算机"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s3123010.jpg","binding":"平装","translator":["罗岱"],"catalog":"第1章　数学和物理学初探\n1.1　数学\n1.2　物理学\n1.3　总结\n第2章　状态驱动智能体设计\n2.1　什么是有限状态机\n2.2　有限状态机的实现\n2.3　West World项目\n2.4　使State基类可重用\n2.5　全局状态和状态翻转（State Blip）\n2.6　创建一个StateMachine类\n2.7　引入Elsa\n2.8　为你的FSM增加消息功能\n第3章　如何创建自治的可移动游戏智能体\n3.1　什么是自治智能体\n3.2　交通工具模型\n3.3　更新交通工具物理属性\n3.4　操控行为\n3.5　组行为（Group Behaviors）\n3.6　组合操控行为（Combining Steering Behaviors）\n3.7　确保无重叠\n3.8　应对大量交通工具：空间划分\n3.9　平滑\n第4章　体育模拟（简单足球）\n4.1　简单足球的环境和规则\n4.2　设计AI\n4.3　使用估算和假设\n4.4　总结\n第5章　图的秘密生命\n5.1　图\n5.2　实现一个图类\n5.3　图搜索算法\n5.4　总结\n第6章　用脚本，还是不用？这是一个问题\n6.1　什么是脚本语言\n6.2　脚本语言能为你做些什么\n6.3　在Lua中编写脚本\n6.4　创建一个脚本化的有限状态自动机\n6.5　有用的链接\n6.6　并不是一切都这么美妙\n6.7　总结\n第7章　概览《掠夺者》游戏\n7.1　关于这个游戏\n7.2　游戏体系结构概述\n7.3　触发器\n7.4　AI设计的考虑\n7.5　实现AI\n7.6　总结\n第8章　实用路径规划\n8.1　构建导航图\n8.2　《掠夺者》游戏导航图\n8.3　创建路径规划类\n8.4　节点式路径或边式路径\n8.5　走出困境状态\n8.6　总结\n第9章　目标驱动智能体行为\n9.1　勇士埃里克的归来\n9.2　实现\n9.3　《掠夺者》角色所使用的目标例子\n9.4　目标仲裁\n9.5　扩展\n9.6　总结\n第10章　模糊逻辑\n10.1　普通集合\n10.2　模糊集合\n10.3　模糊语言变量\n10.4　模糊规则\n10.5　从理论到应用：给一个模糊逻辑模块编码\n10.6　《掠夺者》中是如何使用模糊逻辑类的\n10.7　库博方法\n10.8　总结\n拔\n附录A　C++模板\n函数模板\n类模板\n连接器的困惑\n附录B　UML类图\n类名、属性和操作\n属性和操作的可见性\n关系\n批注\n总结\n附录C　设置你的开发环境\n下载演示的可执行程序\n下载并安装源代码\n参考文献","pages":"368","images":{"small":"http:\/\/img3.douban.com\/spic\/s3123010.jpg","large":"http:\/\/img3.douban.com\/lpic\/s3123010.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s3123010.jpg"},"alt":"http:\/\/book.douban.com\/subject\/3081930\/","id":"3081930","publisher":"人民邮电出版社","isbn10":"7115178062","isbn13":"9787115178060","title":"游戏人工智能编程案例精粹","url":"http:\/\/api.douban.com\/v2\/book\/3081930","alt_title":"","author_intro":"","summary":"《游戏人工智能编程案例精粹》适合对游戏AI开发感兴趣的爱好者和游戏AI开发人员阅读和参考。","price":"55.00元"},{"rating":{"max":10,"numRaters":65,"average":"8.0","min":0},"subtitle":"","author":["Marijn Haverbeke"],"pubdate":"2012-10-1","tags":[{"count":165,"name":"JavaScript","title":"JavaScript"},{"count":45,"name":"编程","title":"编程"},{"count":27,"name":"计算机","title":"计算机"},{"count":21,"name":"javascript","title":"javascript"},{"count":20,"name":"前端开发","title":"前端开发"},{"count":16,"name":"前端","title":"前端"},{"count":15,"name":"web","title":"web"},{"count":12,"name":"programming","title":"programming"}],"origin_title":"Eloquent JavaScript: A Modern Introduction to Programming","image":"http:\/\/img3.douban.com\/mpic\/s11431224.jpg","binding":"","translator":["徐涛"],"catalog":"对本书的赞誉\n译者序\n前言\n第1章　JavaScript基础：值、变量、控制流程\t1\n1.1   值1\n1.1.1   数字1\n1.1.2　算术2\n1.1.3　字符串3\n1.1.4　一元操作符3\n1.1.5　布尔值、比较和布尔逻辑4\n1.1.6　表达式与语句5\n1.2   变量5\n1.3   环境7\n1.3.1   函数7\n1.3.2　prompt和confirm7\n1.3.3　print函数8\n1.3.4　修改环境8\n1.4　程序结构8\n1.4.1　条件执行9\n1.4.2　while循环与do循环9\n1.4.3　缩进代码11\n1.4.4　for循环11\n1.4.5　跳出循环12\n1.4.6　更新变量简便法12\n1.4.7　使用switch进行调度12\n1.4.8　大小写13\n1.4.9　注释13\n1.5　进一步认识类型14\n1.5.1　Undefined值14\n1.5.2　自动类型转换14\n1.5.3　自动类型转换的风险15\n1.5.4　进一步了解&&和||16\n第2章　函数17\n2.1　剖析函数定义17\n2.1.1　定义顺序18\n2.1.2　局部变量18\n2.1.3　嵌套作用域19\n2.1.4　栈20\n2.1.5　函数值20\n2.1.6　闭包21\n2.1.7　可选参数21\n2.2　技巧22\n2.2.1　避免重复22\n2.2.2　纯函数23\n2.2.3　递归24\n第3章　数据结构：对象与数组27\n3.1　问题：Emily姨妈家的猫27\n3.2　基本数据结构28\n3.2.1　属性28\n3.2.2　对象值29\n3.2.3　对象即集合30\n3.2.4　易变性30\n3.2.5　对象即集合：数组31\n3.2.6　方法32\n3.3　解决关于Emily姨妈家猫的问题33\n3.3.1　分离段落33\n3.3.2　找出相关段落34\n3.3.3　提取猫的名字35\n3.3.4　完整算法35\n3.3.5　清理代码36\n3.3.6　日期表示38\n3.3.7　日期提取39\n3.3.8　收集更多信息40\n3.3.9　数据表示41\n3.4　更多理论42\n3.4.1　arguments对象42\n3.4.2　完成扫尾工作44\n3.4.3　Math对象44\n3.4.4　可枚举属性44\n第4章　错误处理47\n4.1　问题类型47\n4.1.1　程序员错误47\n4.1.2　运行时错误48\n4.2　处理错误48\n4.2.1　返回特殊值48\n4.2.2　异常49\n4.2.3　异常之后的错误清除50\n4.2.4　Error对象51\n4.2.5　未处理的异常51\n4.2.6　选择性Catch51\n4.3　自动化测试52\n第5章　函数式编程55\n5.1　抽象55\n5.2　高阶函数56\n5.2.1　修改函数57\n5.2.2　归约函数58\n5.2.3　映射数组59\n5.3　隐士的悲惨故事59\n5.3.1　HTML60\n5.3.2　隐士的文本文件61\n5.3.3　找出段落64\n5.3.4　强调与脚注64\n5.3.5　移动脚注67\n5.3.6　生成HTML67\n5.3.7　转化隐士的书70\n5.4　其他函数技巧71\n5.4.1　操作符函数71\n5.4.2　分布应用72\n5.4.3　组合73\n第6章　面向对象编程75\n6.1　对象75\n6.1.1　定义方法75\n6.1.2　构造函数76\n6.1.3　从原型中构建77\n6.1.4　构造函数与原型77\n6.1.5　原型污染79\n6.1.6　对象即词典80\n6.1.7　指定接口81\n6.2　构建生态系统模拟82\n6.2.1　定义生态圈82\n6.2.2　空间里的点83\n6.2.3　呈现网格83\n6.2.4　昆虫的编程接口85\n6.2.5　生态圈对象86\n6.2.6　this及其作用域87\n6.2.7　有活力的生命88\n6.2.8　昆虫移动90\n6.2.9　更多生命形式90\n6.2.10　多态性93\n6.3　更逼真的模拟生态系统93\n6.3.1　继承93\n6.3.2　记录能量94\n6.3.3　添加植物96\n6.3.4　食草动物97\n6.3.5　为它带来生命97\n6.3.6　人工愚蠢99\n6.4　原型继承100\n6.4.1　类型定义工具100\n6.4.2　类型原型101\n6.4.3　对象的世界102\n6.4.4　instanceof操作符103\n6.4.5　混合类型104\n第7章　模块化107\n7.1　模块107\n7.1.1　生态圈例子107\n7.1.2 　模块文件化108\n7.2　模块的形态108\n7.2.1　函数作为局部命名空间109\n7.2.2　模块对象110\n7.3　接口设计111\n7.3.1　可预见性111\n7.3.2　可组合性111\n7.3.3　分层接口112\n7.3.4　参数对象112\n7.4　JS库113\n第8章　正则表达式115\n8.1　语法115\n8.1.1　匹配字符集115\n8.1.2　匹配单词和字符边界116\n8.1.3　重复模式117\n8.1.4　子表达式分组117\n8.1.5　多选一117\n8.2　匹配与替换118\n8.2.1　匹配方法118\n8.2.2　正则表达式和替换方法118\n8.2.3　动态创建RegExp 对象120\n8.3　解析.ini文件121\n8.4　结论123\n第9章　Web编程：速成课125\n9.1　互联网125\n9.1.1　URL网址125\n9.1.2　服务器端编程126\n9.1.3　客户端编程126\n9.2 　Web脚本基础知识126\n9.2.1　windows对象126\n9.2.2　document对象127\n9.2.3　计时器128\n9.2.4　表单128\n9.2.5　表单脚本化130\n9.2.6　自动焦点132\n9.3　浏览器非兼容性132\n9.4　延伸阅读133\n第10章　文档对象模型135\n10.1　DOM元素135\n10.1.1　节点链接136\n10.1.2　节点类型136\n10.1.3　innerHTML属性137\n10.1.4　查找节点137\n10.1.5　创建节点138\n10.1.6　节点创建辅助函数138\n10.1.7　移动节点139\n10.1.8　print实现140\n10.2　样式表140\n10.2.1　样式属性141\n10.2.2　隐藏节点141\n10.2.3　定位141\n10.2.4　控制节点大小142\n10.3　警示语142\n第11章　浏览器事件143\n11.1　事件句柄143\n11.1.1　注册事件句柄143\n11.1.2　事件对象145\n11.1.3　鼠标相关事件类型145\n11.1.4　键盘事件146\n11.1.5　停止事件147\n11.1.6　事件对象正规化147\n11.1.7　跟踪焦点148\n11.1.8　表单事件148\n11.1.9　window事件149\n11.2　示例：实现推箱子149\n11.2.1　等级输入格式149\n11.2.2　程序设计150\n11.2.3　游戏板展示150\n11.2.4 　控制器对象153\n第12章　HTTP请求157\n12.1　HTTP协议157\n12.2　XMLHttpRequest API158\n12.2.1　创建请求对象158\n12.2.2　简单的请求158\n12.2.3　发送异步请求159\n12.2.4　获取XML数据160\n12.2.5　读取JSON数据161\n12.2.6 　基本的请求包装161\n12.3　学习HTTP162","pages":"176","images":{"small":"http:\/\/img3.douban.com\/spic\/s11431224.jpg","large":"http:\/\/img3.douban.com\/lpic\/s11431224.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s11431224.jpg"},"alt":"http:\/\/book.douban.com\/subject\/19933548\/","id":"19933548","publisher":"机械工业出版社华章公司","isbn10":"7111396650","isbn13":"9787111396659","title":"JavaScript编程精解","url":"http:\/\/api.douban.com\/v2\/book\/19933548","alt_title":"Eloquent JavaScript: A Modern Introduction to Programming","author_intro":"作者简介：\nMarijn Haverbeke　世界级JavaScript程序员，通晓多种编程语言，在Web开发方面积累了丰富的经验，在JavaScript领域颇有影响力。如今，他专注于动态语言下的数据库系统的研究和Web API的设计。此外，他创建并维护着多个流行的开源项目。\n译者简介：\n徐涛（网名：汤姆大叔），微软最有价值专家（MVP）、项目经理、软件架构师，擅长大型互联网产品的架构与设计，崇尚敏捷开发模式，熟悉设计模式、前端技术以及各种开源产品，曾获MCP、MCSE、MCDBA、MCTS、MCITP、MCPD、PMP认证。\n博客地址：http:\/\/www.cnblogs.com\/TomXu","summary":"如果你只想阅读一本关于JavaScript的图书，那么本书应该是你的首选。本书由世界级JavaScript程序员撰写，JavaScript之父和多位JavaScript专家鼎力推荐。本书适合作为系统学习JavaScript的参考书，它在写作思路上几乎与现有的所有同类书都不同，打破常规，将编程原理与运用规则完美地结合在一起，而且将所有知识点与一个又一个经典的编程故事融合在一起，读者可以在轻松的游戏式开发中学会JavaScript程序设计，趣味性十足，可操作性极强。\n全书一共12章：第1~3章介绍了JavaScript的基本语法，旨在帮助读者编写出正确的JavaScript程序，包含数字、算术、字符串、变量、程序结构、控制流程、类型、函数、对象和数组等最基础和最核心的内容；第4~7章讲解了JavaScript编程中的高级技术，目的是帮助读者编写更复杂的JavaScript程序，主要涉及错误处理、函数式编程、面向对象编程、模块化等重要内容；第8~12章则将重心转移到JavaScript环境中可用的工具上，分别详细讲解了正则表达式、与Web编程相关的知识、文档对象模型、浏览器事件和HTTP请求等。","price":"49.00元"},{"rating":{"max":10,"numRaters":104,"average":"8.9","min":0},"subtitle":"","author":["西格兰"],"pubdate":"2008-3-1","tags":[{"count":87,"name":"机器学习","title":"机器学习"},{"count":76,"name":"数据挖掘","title":"数据挖掘"},{"count":37,"name":"算法","title":"算法"},{"count":35,"name":"人工智能","title":"人工智能"},{"count":31,"name":"web2.0","title":"web2.0"},{"count":21,"name":"计算机","title":"计算机"},{"count":17,"name":"Programming","title":"Programming"},{"count":15,"name":"python","title":"python"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s5891850.jpg","binding":"平装","translator":[],"catalog":"","pages":"334","images":{"small":"http:\/\/img3.douban.com\/spic\/s5891850.jpg","large":"http:\/\/img3.douban.com\/lpic\/s5891850.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s5891850.jpg"},"alt":"http:\/\/book.douban.com\/subject\/3056375\/","id":"3056375","publisher":"东南大学出版社","isbn10":"7564111399","isbn13":"9787564111397","title":"集体智慧编程","url":"http:\/\/api.douban.com\/v2\/book\/3056375","alt_title":"Programming Collective Intelligence","author_intro":"Toby Segaran is a software developer and manager at Genstruct, a computational systems biology company. He has written free web applications for his own use and put them online for others to try, including: tasktoy, a task management system; Lazybase, an online application that lets users design, create and share databases of anything they like; and Rosetta Blog, an online tool for practicing Spanish and French by reading blogs along with their translations and lists of common words. Each of these has several hundred regular users. His blog is located at kiwitobes.com.","summary":"想要探寻搜索排名、产品推荐、社会化书签和在线匹配背后的力量吗？这本颇具魅力的书籍向你展现如何创建Web 2.0应用程序，从参与性？Internet应用程序产生的大量数据中挖掘金矿。运用本书中介绍的先进算法，你可以编写聪明的程序，以访问其他网站那些有趣的数据集，从自有应用程序的用户中收集数据，或者分析和理解你所发现的数据。\n《集体智慧编程》将你带入机器学习和统计的世界，并且阐释了如何从你和他人每天收集的信息中获得关于用户体验、市场营销、个性品味及人类行为的结论。每个算法的描述都十分简明清晰，相关代码均可以立即用于你的网站、博客、Wiki或特定应用程序。本书讲解了下列主题：\n可以让在线零售商推荐产品或媒体的协作过滤技术\n用于在大数据集中发现同类项组的聚类方法\n从数以百万计可能方案中选择问题最佳解决方案的最优化算法\n贝叶斯过滤，用在基于单词类型和其他特征的垃圾信息过滤中\n支持向量（support-vector）机器，用于在线交友网站中的速配\n用于问题解决的演化智能——计算机如何通过多次玩同样的游戏，改进自身代码并获得技能提升\n每一章都包含了相关练习，可通过扩展使算法变得更强大。超越简单的数据库支持应用程序模式，让 Internet数据财富为你所用。","price":"58.00元"},{"rating":{"max":10,"numRaters":104,"average":"8.2","min":0},"subtitle":"","author":["[美] Jon Bentley"],"pubdate":"2011-5","tags":[{"count":95,"name":"算法","title":"算法"},{"count":57,"name":"编程珠玑","title":"编程珠玑"},{"count":52,"name":"编程","title":"编程"},{"count":35,"name":"计算机","title":"计算机"},{"count":23,"name":"经典","title":"经典"},{"count":21,"name":"计算机科学","title":"计算机科学"},{"count":17,"name":"Programming","title":"Programming"},{"count":16,"name":"程序设计","title":"程序设计"}],"origin_title":"More Programming Pearls: Confessions of a Coder","image":"http:\/\/img5.douban.com\/mpic\/s4721666.jpg","binding":"平装","translator":["钱丽艳","刘田 等"],"catalog":"第一部分  编 程 技 术\n第1 章  性能监视工具　　3\n1.1 计算素数　　3\n1.2 使用性能监视工具　　7\n1.3 专用的性能监视工具　　 8\n1.4 开发性能监视工具　　10\n1.5 原理　　11\n1.6 习题　　11\n1.7 深入阅读　　12\n第2 章  关联数组　　13\n2.1 Awk 中的关联数组　　 13\n2.2 有穷状态机模拟器　　 16\n2.3 拓扑排序　　17\n2.4 原理　　20\n2.5 习题　　21\n2.6 深入阅读　　22\n第3 章  程序员的忏悔　　 23\n3.1 二分搜索　　24\n3.2 选择算法　　26\n3.3 子程序库　　28\n3.4 原理　　30\n3.5 习题　　31\n第4 章  自描述数据　　33\n4.1 名字—值对　　33\n4.2 记录来历　　36\n4.3 排序实验　　37\n4.4 原理　　39\n4.5 习题　　39\n第二部分  实 用 技 巧\n第5 章  劈开戈尔迪之结 43\n5.1 小测验　　43\n5.2 解答　　44\n5.3 提示　　44\n5.4 原理　　47\n5.5 习题　　48\n5.6 深入阅读　　49\n5.7 调试（边栏） 　　49\n第6 章  计算机科学箴言集 51\n6.1 编码　　52\n6.2 用户界面　　53\n6.3 调试　　53\n6.4 性能　　54\n6.5 文档　　56\n6.6 软件管理　　56\n6.7 其他　　58\n6.8 原理　　58\n6.9 习题　　58\n6.10 深入阅读　　60\n第7 章  粗略估算　　61\n7.1 头脑热身　　61\n7.2 性能的经验法则　　62\n7.3 Little 定律　　64\n7.4  原理　　65\n7.5 习题　　66\n7.6 深入阅读　　67\n7.7 日常速算（边栏）　　 67\n第8 章  人员备忘录　　69\n8.1 备忘录　　69\n8.2 原理　　71\n8.3 深入阅读　　71\n第三部分  人性化I\/O\n第9 章  小语言　　75\n9.1 Pic 语言　　76\n9.2 视角　　79\n9.3 Pic 预处理器　　81\n9.4 用来实现Pic 的小语言83\n9.5 原理　　87\n9.6 习题　　88\n9.7 深入阅读　　89\n第10 章  文档设计　　91\n10.1 表格　　92\n10.2 三条设计原则　　94\n10.3 插图　　94\n10.4 文本　　96\n10.5 合适的媒介　　98\n10.6 原理　　100\n10.7 习题　　101\n10.8 深入阅读　　101\n10.9 次要问题目录（边栏） 101\n第11 章  图形化输出　　103\n11.1 实例研究　　103\n11.2 显示结果取样　　105\n11.3 原理　　107\n11.4 习题　　108\n11.5 深入阅读　　110\n11.6 拿破仑远征莫斯科（边栏） 110\n第12 章  对调查的研究113\n12.1 有关民意调查的问题113\n12.2 语言　　114\n12.3 图片　　117\n12.4 原理　　119\n12.5 习题　　120\n第四部分  算 法\n第13 章  绝妙的取样　　123\n13.1 取样算法一瞥　　123\n13.2 Floyd 算法　　124\n13.3 随机排列　　125\n13.4 原理　　127\n13.5 习题　　127\n13.6 深入阅读　　128\n第14 章  编写数值计算程序129\n14.1 问题　　129\n14.2 牛顿迭代　　130\n14.3 良好的起点　　132\n14.4 代码　　133\n14.5 原理　　135\n14.6 习题　　135\n14.7 深入阅读　　137\n14.8 数值算法的力量（边栏） 137\n第15 章  选择　　141\n15.1 问题　　141\n15.2 程序　　142\n15.3 运行时间分析　　145\n15.4 原理　　148\n15.5 习题　　149\n15.6 深入阅读　　151\n附录A C 和Awk 语言　　153\n附录B 子程序库　　157\n部分习题答案　　165\n索引　　　　181","pages":"196","images":{"small":"http:\/\/img5.douban.com\/spic\/s4721666.jpg","large":"http:\/\/img5.douban.com\/lpic\/s4721666.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s4721666.jpg"},"alt":"http:\/\/book.douban.com\/subject\/6124333\/","id":"6124333","publisher":"人民邮电出版社","isbn10":"7115251517","isbn13":"9787115251510","title":"编程珠玑（续）","url":"http:\/\/api.douban.com\/v2\/book\/6124333","alt_title":"More Programming Pearls: Confessions of a Coder","author_intro":"Jon Bentley 世界著名计算机科学家，被誉为影响算法发展的十位大师之一。他先后任职于卡内基-梅隆大学（1976~1982）、贝尔实验室（1982~2001）和Avaya实验室（2001年至今）。在卡内基-梅隆大学担任教授期间，他培养了包括Tcl语言设计者John Ousterhout、Java语言设计者James Gosling、《算法导论》作者之一Charles Leiserson在内的许多计算机科学大家。2004年荣获Dr. Dobb’s程序设计卓越奖。","summary":"Jon Bentley编著的《编程珠玑(续)》是计算机科学方面的经典名著《编程珠玑》的姊妹篇，讲述了对于程序员有共性的知识。书中涵盖了程序员操纵程序的技术、程序员取舍的技巧、输入和输出设计以及算法示例，这些内容组成一个有机的整体，如一串串珠玑展示给程序员。《编程珠玑(续)》适合各级程序员阅读参考。","price":"35.00 元"},{"rating":{"max":10,"numRaters":124,"average":"8.9","min":0},"subtitle":"套接口API和X\/Open传输接口API","author":["[美] W. Richard Stevens"],"pubdate":"2001-2","tags":[{"count":85,"name":"UNIX","title":"UNIX"},{"count":65,"name":"网络","title":"网络"},{"count":35,"name":"编程","title":"编程"},{"count":28,"name":"计算机","title":"计算机"},{"count":22,"name":"网络编程","title":"网络编程"},{"count":17,"name":"Linux","title":"Linux"},{"count":16,"name":"network","title":"network"},{"count":13,"name":"Programming","title":"Programming"}],"origin_title":"","image":"http:\/\/img5.douban.com\/mpic\/s1318658.jpg","binding":"平装16开","translator":["施振川 周利民 孙宏晖 等","杨继张 审校"],"catalog":"","pages":"857","images":{"small":"http:\/\/img5.douban.com\/spic\/s1318658.jpg","large":"http:\/\/img5.douban.com\/lpic\/s1318658.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s1318658.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1231567\/","id":"1231567","publisher":"清华大学出版社","isbn10":"7302035482","isbn13":"9787302035480","title":"UNIX网络编程（第1卷）","url":"http:\/\/api.douban.com\/v2\/book\/1231567","alt_title":"","author_intro":"","summary":"","price":"94.00元"},{"rating":{"max":10,"numRaters":104,"average":"8.2","min":0},"subtitle":"","author":["Aaron Hillegas"],"pubdate":"2009年7月","tags":[{"count":109,"name":"Cocoa","title":"Cocoa"},{"count":74,"name":"Mac","title":"Mac"},{"count":48,"name":"Apple","title":"Apple"},{"count":45,"name":"Objective-C","title":"Objective-C"},{"count":34,"name":"编程","title":"编程"},{"count":29,"name":"programming","title":"programming"},{"count":24,"name":"OSX","title":"OSX"},{"count":20,"name":"iPhone","title":"iPhone"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s3890550.jpg","binding":"","translator":["钱友才 陈勇 王健"],"catalog":"","pages":"460页","images":{"small":"http:\/\/img3.douban.com\/spic\/s3890550.jpg","large":"http:\/\/img3.douban.com\/lpic\/s3890550.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s3890550.jpg"},"alt":"http:\/\/book.douban.com\/subject\/3870385\/","id":"3870385","publisher":"电子工业出版社","isbn10":"7121092395","isbn13":"9787121092398","title":"苹果开发之Cocoa编程","url":"http:\/\/api.douban.com\/v2\/book\/3870385","alt_title":"","author_intro":"Aaron Hillegas，曾就职于Next和Apple，现在在Big Nerd Ranch主讲Cocoa编程。第一套OpenStep（Cocoa的前身）教程即出自其手。本书基于Aaron在Big Nerd Ranch的教学内容，并融入了他在OpenStep和Cocoa方面15年的工作经验。","summary":"从零开始学习Cocoa的首选图书.\n涵盖了最新的Mac编程技术\n高级Mac OS X开发者们联手强烈推荐..\nMac OS X编程图书的标杆\nAaron Hillegass多年Cocoa教学实践经验的总结\n本书内容涵盖了Objective-C语言、Cocoa的主要设计模式，以及三个最常使用的开发工具：Xcode、Interface Builder和Instruments。 本书的第三版更新了在Mac OS X 10.4和10.5中引入的一些技术，包括Xcode 3,、Objective-C 2、Core Data、垃圾收集器和CoreAnimation。\n本书适合已经有一点C基础并且知道一点面向对象知识的程序员。你不须要有任何Mac编程经验。","price":"65.00元"},{"rating":{"max":10,"numRaters":103,"average":"7.7","min":0},"subtitle":"基于ACE和框架的系统化复用","author":["Douglas C. Schmidt"],"pubdate":"2004年01月","tags":[{"count":100,"name":"C++","title":"C++"},{"count":82,"name":"网络编程","title":"网络编程"},{"count":74,"name":"ACE","title":"ACE"},{"count":22,"name":"计算机","title":"计算机"},{"count":16,"name":"网络","title":"网络"},{"count":16,"name":"编程","title":"编程"},{"count":14,"name":"C\/C++","title":"C\/C++"},{"count":14,"name":"network","title":"network"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s1108372.jpg","binding":"精装","translator":["马维达"],"catalog":"","pages":"350 页","images":{"small":"http:\/\/img3.douban.com\/spic\/s1108372.jpg","large":"http:\/\/img3.douban.com\/lpic\/s1108372.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s1108372.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1141548\/","id":"1141548","publisher":"电子工业出版社","isbn10":"7505392328","isbn13":"9787505392328","title":"C++网络编程（卷2）","url":"http:\/\/api.douban.com\/v2\/book\/1141548","alt_title":"","author_intro":"","summary":"《C++网络编程》系列正是帮助我们进入一个更好的网络化应用开发世界的台阶。在卷1中，两位作者，Douglas C. Schmidt与Stephen D.Huston，从对编写并发网络化应用所涉及的问题和工具进行综述开始，向我们介绍了开发灵活而高效的并发网络化应用所需的各种设计维度、模式和原则。通过对卷1的学习，你将能够了解怎样在将C++和模式有效地应用于开发面向对象网络化应用的同时，增强自己的设计技能。而在卷2中，两位作者将向我们描述ACE框架的设计原理，以及它们可以怎样帮助开发者在较低级的本地操作系统API和较高级的分布式对象计算中间件的局限之间“航行”；前者既不灵活也不可移植，而后者对有着苛刻的QoS和可移植性需求的网络化应用来说，常常缺乏效率和灵活性。传统上，生成和使用网络化应用框架所需的技能被锁在专家开发者的头脑中，或是深深地埋藏在散布于企业或是行业各处的众多项目的源代码中。这两种情况当然都不理想，因为要为每个新的应用或项目重新获取这些知识，既费时又易出错。为解决这一问题，卷2阐释了在ACE框架的结构和功能之下的各种关键模式；这同时也将会帮助我们理解ACE自身的设计、实现，以及有效使用。","price":"38.00元"},{"rating":{"max":10,"numRaters":79,"average":"8.5","min":0},"subtitle":"For Xcode 4.3","author":["Joe Conway","Aaron Hillegass"],"pubdate":"2013-3-1","tags":[{"count":108,"name":"iOS编程","title":"iOS编程"},{"count":76,"name":"iOS","title":"iOS"},{"count":43,"name":"iPhone开发","title":"iPhone开发"},{"count":21,"name":"编程","title":"编程"},{"count":17,"name":"计算机","title":"计算机"},{"count":14,"name":"Big_Nerd_Ranch_Guide","title":"Big_Nerd_Ranch_Guide"},{"count":12,"name":"移动","title":"移动"},{"count":10,"name":"编程语言","title":"编程语言"}],"origin_title":"iOS Programming: The Big Nerd Ranch Guide (3rd Edition)","image":"http:\/\/img5.douban.com\/mpic\/s25011757.jpg","binding":"平装","translator":["夏伟频","李骏"],"catalog":"前言\n第1章  第一个简单的iOS应用 1\n1.1  创建Xcode项目 2\n1.2  创建界面 5\n1.3  模型-视图-控制器 9\n1.4  声明 11\n1.5  创建关联 13\n1.6  实现方法 17\n1.7  针对模拟器构建并运行应用 20\n1.8  安装应用 22\n1.9  应用图标 23\n1.10  启动图片 25\n第2章  Objective-C 29\n2.1  对象 29\n2.2  使用实例 30\n2.3  编写命令行工具RandomPossessions 33\n2.4  创建Objective-C类的子类 39\n2.5  异常与未知选择器 56\n2.6  快速枚举 58\n第3章  通过ARC管理内存 61\n3.1  堆 61\n3.2  栈 62\n3.2  指针变量与对象所有权 63\n3.4  内存管理 64\n3.5  Strong引用与Weak引用 67\n3.6  属性 72\n3.7  copy特性 77\n3.8  用点号调用存取方法 78\n第4章  委托与Core Location 81\n4.1  项目、目标与框架 82\n4.2  Core Location 83\n4.3  委托 87\n4.4  使用调试器 91\n第5章  MapKit与文本输入 103\n5.1  对象图 103\n5.2  MapKit框架 104\n5.3  界面属性 105\n5.4  设置MapView对象的委托对象 108\n第6章  UIView子类与UIScrollView 121\n6.1  视图与视图层次结构 122\n6.2  创建自定义视图 124\n6.3  UIView的drawRect:方法 128\n6.4  Core Graphics 131\n6.5  UIKit中的绘图扩展 132\n6.6  重画视图 134\n6.7  运动事件 136\n6.8  使用UIScrollView 138\n6.9  隐藏状态条 142\n第7章  视图控制对象 145\n7.1  UIViewController 145\n7.2  UITabBarController 155\n7.3  视图控制对象的生命周期 159\n7.4  UIViewController子类与模板 168\n第8章  通告机制与自动转屏 173\n8.1  通告中心 173\n8.2  UIDevice通告 175\n8.3  自动转屏 176\n8.4  强制使用横排模式 184\n第9章  UITableView与UITableViewController 187\n9.1  编写Homepwner应用 187\n9.2  UITableViewController 189\n9.3  UITableView数据源 192\n9.4  UITableViewCell对象 198\n9.5  代码片段库 203\n第10章  编辑UITableView 207\n10.1  编辑模式 207\n10.2  增加行 213\n10.3  删除行 215\n10.4  移动行 216\n第11章  UINavigationController 219\n11.1  UINavigationController 219\n11.2  额外的视图控制对象 223\n11.3  UINavigationController的导航功能 228\n11.4  UINavigationBar 233\n第12章  相机 239\n12.1  通过UIImageView对象显示图片 239\n第13章  UIPopoverController与模态视图控制对象 261\n13.1  将Homepwner改为通用应用 261\n13.2  UIPopoverController 263\n13.3  更多的模态视图控制对象 266\n第14章  保存、读取与应用状态 279\n14.1  固化 279\n14.2  应用沙盒 281\n14.3  NSKeyedArchiver与NSKeyedUnarchiver 283\n14.4  应用状态与状态切换 286\n14.5  通过NSData将数据写入文件 289\n14.7  再谈内存过低警告 291\n14.8  模型-视图-控制器-存储设计模式 292\n第15章  创建UITableViewCell子类 299\n15.1  创建HomepwnerItemCell 299\n15.2  处理图片 305\n15.3  由UITableViewCell对象转发动作消息 308\n第16章  Core Data 317\n16.1  对象-关系映射 317\n16.2  用Core Data重写BNRItemStore的数据保存功能 318\n16.3  再谈SQL 336\n16.4  Faults 337\n16.5  各种存取机制的优缺点 339\n第17章  本地化 341\n17.1  通过NSLocale实施国际化 342\n17.2  资源的本地化 343\n17.3  NSLocalizedString与字符串对照表 347\n第18章  NSUserDefaults 351\n18.1  更新Whereami 351\n18.2  使用NSUserDefaults 353\n第19章  触摸事件与UIResponder 357\n19.1  触摸事件 357\n19.2  创建TouchTracker应用 359\n19.3  实现TouchDrawView，完成绘图功能 360\n19.4  处理触摸事件并创建线条对象 361\n19.5  响应对象链 364\n第20章  UIGestureRecognizer与UIMenuController 367\n20.1  UIGestureRecognizer子类 367\n20.2  用UITapGestureRecognizer对象识别“按下”手势 368\n20.3  UIMenuController 371\n20.4  UILongPressGestureRecognizer 372\n20.5  UIPanGestureRecognizer以及同时识别多个手势 374\n第21章  Instruments 380\n21.1  静态分析器 380\n21.2  Instruments 382\n21.3  Xcode方案 392\n21.9  创建新方案 394\n21.4  构建设置 396\n第22章  Core Animation Layer 399\n22.1  层与视图的关系 399\n22.2  创建CALayer对象 400\n22.3  层的显示内容 403\n22.4  隐式可动画属性 405\n第23章  通过CAAnimation控制动画 411\n23.1  动画对象 411\n23.2  通过CABasicAnimation实现旋转动画 414\n23.3  通过CAKeyframeAnimation实现弹跳动画 419\n第24章  UIStoryboard 423\n24.1  创建Storyboard文件 423\n24.2  Storyboard文件中的UITableViewController 427\n24.3  Segue 430\n24.4  Storyboards的优缺点 434\n第25章  Web服务与UIWebView 437\n25.1  Web服务 438\n25.2  UIWebView 456\n第26章  UISplitViewController与NSRegularExpression 463\n26.1  在Nerdfeed中使用UISplitViewController 464\n26.2  主、从视图控制对象间的通信 468\n26.3  在竖排模式下显示主视图控制对象 475\n26.4  将Nerdfeed改为通用应用 477\n26.5  NSRegularExpression 478\n第27章  Block对象 485\n27.1  Block对象及其语法 485\n27.2  浅谈如何使用Block对象 490\n27.3  捕获变量 493\n27.4  Block对象的常见用途 496\n第28章  模型-视图-控制器-存储 503\n28.1  为什么需要存储对象 503\n28.2  创建BNRFeedStore 506\n28.3  使用BNRFeedStore对象 508\n28.5  通过JSON格式传输数据 521\n28.6  再谈存储对象 526\n第29章  再谈MVCS 529\n29.1  缓存RSS数据 529\n29.2  高级缓存 535\n29.3  已读RSSItem对象与未读RSSItem对象 545\n29.4  使用存储对象的其他益处 550\n第30章  iCloud 555\n30.1  使用iCloud前的准备工作 556\n30.2  Ubiquity Container 556\n30.3  支持iCloud的provisioning profile 558\n30.4  Core Data与iCloud 561\n第31章  后记 569\n31.1  接下来做什么 569\n31.2  结束语 570\n索引 571","pages":"608","images":{"small":"http:\/\/img5.douban.com\/spic\/s25011757.jpg","large":"http:\/\/img5.douban.com\/lpic\/s25011757.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s25011757.jpg"},"alt":"http:\/\/book.douban.com\/subject\/21356354\/","id":"21356354","publisher":"华中科技大学出版社","isbn10":"7560986056","isbn13":"9787560986050","title":"iOS编程","url":"http:\/\/api.douban.com\/v2\/book\/21356354","alt_title":"iOS Programming: The Big Nerd Ranch Guide (3rd Edition)","author_intro":"Joe Conway是Big Nerd Ranch的资深教师，自iOS平台发布以来一直从事相关的咨询服务。Joe毕业于美国威斯康辛大学，在Mac OS X早期即开始编写Objective-C和Cocoa代码。他编写了Big Nerd Ranch的“iOS新手培训课程”教材。该教材 广受好评，是本书的原型。\nAaron Hillegass曾就职于NeXT公司和Apple公司，目前在Big Nerd Ranch教授iOS编程课程。Aaron在NeXT时编写了第一本OpenStep教材（OpenStep是Cocoa的前身）。本书以Big Nerd Ranch的教学课程为基础，涵盖了近20年OpenStep和Cocoa的开发成果。","summary":"《iOS编程（第3版）》获21届Jolt生产力大奖。第3版更新了iOS5和Xcode4.3的内容。全书涵盖了开发iOS应用的方方面面。从Objective-C基础知识到新增加的语言特性；从AppKit库到常见的Cocoa设计模式；从Xcode技巧到Instrumen tst等。如果读者刚接触iOS编程，阅 读本书前两章可以快速入门。如果读者已经有iOS编程经验，阅读本书可以拾遗补缺。本书的另一个特色是教读者以正确的方法解决问题。Objective-C的习惯约定有哪些（例如命名约定，内存管理约定），创建子类时如何处理初始化方法，Cocoa的常见设计模式有哪些，如何选择数据保存方法等。这些问题，如果读者自己摸索，难免费时费力。本书已经将这些知识整理、归纳并清楚地呈现在读者面前。\nBig Nerd Ranch培训系列中文图书网站：http:\/\/www.iosprogrammingbook.com\/","price":"99.00元"},{"rating":{"max":10,"numRaters":103,"average":"9.2","min":0},"subtitle":"","author":["[美] Jon Bentley"],"pubdate":"2010-8","tags":[{"count":102,"name":"算法","title":"算法"},{"count":64,"name":"编程","title":"编程"},{"count":57,"name":"计算机","title":"计算机"},{"count":36,"name":"programming","title":"programming"},{"count":26,"name":"程序设计","title":"程序设计"},{"count":20,"name":"Algorithm","title":"Algorithm"},{"count":16,"name":"数据结构","title":"数据结构"},{"count":10,"name":"理论基础","title":"理论基础"}],"origin_title":"Programming Pearls","image":"http:\/\/img5.douban.com\/mpic\/s4937258.jpg","binding":"塑封","translator":[],"catalog":"CONTENTS\nPart I: PRELIMINARIES       1\nColumn 1: Cracking the Oyster      3\nA Friendly Conversation ~ Precise Problem Statement ~ Program Design ~\nImplementation Sketch. Principles ~ Problems. Further Reading\nColumn 2: Aha! Algorithms       11\nThree Problems ~ Ubiquitous Binary Search ~ The Power of Primitives ~\nGetting It Together: Sorting. Principles. Problems. Further Reading.\nImplementing an Anagram Program\nColumn 3: Data Structures Programs      21\nA Survey Program ~ Form-Letter Programming ~ An Array of Examples ~\nStructuring Data. Powerful Tools for Specialized Data ~ Principles ~ Prob-\nlems ~ Further Reading\nColumn 4: Writing Correct Programs      33\nThe Challenge of Binary Search ~ Writing the Program ~ Understanding the\nProgram. Principles ~ The Roles of Program Verification ~ Problems.\nFurther Reading\nColumn 5: A Small Matter of Programming       45\nFrom Pseudocode to C ~ A Test Harness ~ The Art of Assertion ~ Auto-\nmated Testing ~ Timing ~ The Complete Program. Principles ~ Problems\n~ Further Reading ~ Debugging\nPart II: PERFORMANCE      59\nColumn 6: Perspective on Performance      61\nA Case Study. Design Levels. Principles. Problems ~ Further Reading\nColumn 7: The Back of the Envelope      67\nBasic Skills ~ Performance Estimates ~ Safety Factors ~ Little's Law ~\nPrinciples ~ Problems ~ Further Reading ~ Quick Calculations in Everyday\nLife\nColumn 8: Algorithm Design Techniques       77\nThe Problem and a Simple Algorithm ~ Two Quadratic Algorithms ~ A\nDivide-and-Conquer Algorithm ~ A Scanning Algorithm ~ What Does It\nMatter? ~ Principles. Problems. Further Reading\nColumn 9: Code Tuning         87\nA Typical Story ~ A First Aid Sampler ~ Major Surgery   Binary Search ~\nPrinciples. Problems. Further Reading\nColumn 10: Squeezing Space         99\nThe Key    Simplicity ~ An Illustrative Problem. Techniques for Data\nSpace. Techniques for Code Space ~ Principles ~ Problems ~ Further\nReading ~ A Big Squeeze\nPart III: THE PRODUCT       113\nColumn 11: Sorting           115\nInsertion Sort ~ A Simple Quicksort ~ Better Quicksorts ~ Principles ~\nProblems ~ Further Reading\nColumn 12: A Sample Problem      125\nThe Problem ~ One Solution. The Design Space. Principles ~ Problems\n~ Further Reading\nColumn 13: Searching         133\nThe Interface ~ Linear Structures ~ Binary Search Trees ~ Structures for\nIntegers. Principles. Problems. Further Reading. A Real Searching\nProblem\nColumn 14: Heaps      147\nThe Data Structure ~ Two Critical Functions ~ Priority Queues ~ A Sorting\nAlgorithm. Principles. Problems. Further Reading\nColumn 15: Strings of Pearls        161\nWords ~ Phrases ~ Generating Text ~ Principles ~ Problems ~ Further\nReading\nEpilog to the First Edition       175\nEpilog to the Second Edition          177\nAppendix 1: A Catalog of Algorithms         179\nAppendix 2: An Estimation Quiz      183\nAppendix 3: Cost Models for Time and Space         185\nAppendix 4: Rules for Code Tuning      191\nAppendix 5: C++ Classes for Searching        197\nHints for Selected Problems      201\nSolutions to Selected Problems        205\nIndex      233","pages":"239","images":{"small":"http:\/\/img5.douban.com\/spic\/s4937258.jpg","large":"http:\/\/img5.douban.com\/lpic\/s4937258.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s4937258.jpg"},"alt":"http:\/\/book.douban.com\/subject\/4924297\/","id":"4924297","publisher":"人民邮电出版社","isbn10":"7115232601","isbn13":"9787115232601","title":"编程珠玑（英文版・第2版）","url":"http:\/\/api.douban.com\/v2\/book\/4924297","alt_title":"Programming Pearls","author_intro":"1953年2月20日出生于美国加州长滩。1974年毕业于斯坦福大学数学系，1976年获北卡罗来纳大学博士学位。他先后任职于卡内基一梅隆大学(1976—1982)、贝尔实验窒(1982—2001)和Avaya实验室(2001年至今)。在卡内基一梅隆大学任教期间。他培养了许多后来知名的计算机大家，包括Scribe的开发者Brian Reid，Tcl语言设计者John Ousterhout。Java专家Joshua Btoch，Java语言设计者James Gosling，《算法导论》作者之—Charles Leiserson。2004年荣获Dr.Dobb's程序设计卓越奖。","summary":"多年以来，当程序员们推选出最心爱的计算机图书时，《编程珠玑》总是位列前列。正如自然界里珍珠出自细沙对牡蛎的磨砺，计算机科学大师Jon Bentley以其独有的洞察力和创造力，从磨砺程序员的实际问题中凝结出一篇篇不朽的编程“珠玑”。这些文章是《ACM通讯》最受欢迎的专栏文章，最终结集为两部书出版。本书为第一卷，主要讨论计算机科学中最本质的问题：如何正确选择和高效地实现算法。\n在书中，作者选取许多具有典型意义的复杂编程和算法问题，生动描绘了历史上众多大师们在探索解决方案中发生的轶事、走过的弯路和不断精益求精的历程，引导读者开展创新性的思考。书中透彻阐述和总结了许多独特而精妙的设计原则、思考和解决问题的方法以及实用程序设计技巧。解决方案的代码均以C\/C++语言编写，不仅有趣，而且有很大的实战示范意义。每章后所附习题极具挑战性和启发性，书末给出了简洁的解答。","price":"39.00元"},{"rating":{"max":10,"numRaters":44,"average":"8.8","min":0},"subtitle":"Java世界的Lisp实践","author":["Chas Emerick","Brian Carper","Christophe Grand"],"pubdate":"2013-3-26","tags":[{"count":152,"name":"Clojure","title":"Clojure"},{"count":84,"name":"函数式","title":"函数式"},{"count":56,"name":"lisp","title":"lisp"},{"count":42,"name":"编程","title":"编程"},{"count":25,"name":"Java","title":"Java"},{"count":16,"name":"programming","title":"programming"},{"count":10,"name":"软件开发","title":"软件开发"},{"count":10,"name":"程度设计","title":"程度设计"}],"origin_title":"Clojure Programming","image":"http:\/\/img3.douban.com\/mpic\/s25803832.jpg","binding":"平装","translator":["徐明明","杨寿勋"],"catalog":"第1章  进入Clojure仙境\t1\n为什么要选择Clojure?\t1\n获取Clojure\t3\nClojure REPL\t3\n不！括号真的不会让你瞎了眼\t6\n表达式、操作符、语法以及优先级\t7\n同像性\t10\nClojure Reader\t12\n命名空间\t21\n符号解析\t23\n特殊形式\t24\n小结\t46\n这只是开始\t48\n第1部分 \t49\n第2章   函数式编程\t51\n所谓函数式编程，到底意味着什么？\t52\n谈谈值的重要性\t52\n作为头等公民的函数以及高阶函数\t59\n函数（功能）的组合\t68\n纯函数\t76\n现实生活中的函数式编程\t80\n第3章  集合类与数据结构\t83\n抽象优于实现\t84\n访问集合元素的简洁方式\t111\n数据结构的类型\t115\n不可变性和持久性\t123\n元数据\t136\n用Clojure的集合来小试牛刀\t137\n总结\t159\n第4章  多线程和并发\t161\n计算在时间和空间内的转换\t162\n简单的并行化\t168\n状态和标识\t170\nClojure的引用类型\t172\n并发操作的分类\t174\n原子类型（Atom）\t176\n通知和约束\t179\nref\t182\nvar\t200\nAgent\t211\n使用Java的并发原语\t227\n总结\t228\n第2部分 \t229\n第5 章  宏\t231\n宏到底是什么？\t231\n编写你的第一个宏\t237\n调试宏\t239\n语法\t242\n什么时候使用宏\t245\n宏卫生\t247\n宏的常见用法和模式\t253\n隐藏参数：&env 和 &form\t255\n深入 -> 和 ->>\t263\n总结\t266\n第6章  数据类型和协议\t267\n协议（Protocol）\t268\n扩展已有的类型\t270\n定义你自己的类型\t274\n实现协议\t284\n协议自省\t293\n协议函数分派的边界场景\t295\n自己实现一个set\t296\n总结\t304\n第7章  多重方法\t305\n多重方法基础\t305\n通往层级之路\t308\n层级\t310\n真正实现多重！\t315\n还有几件事\t317\n最后的思考\t321\n第3 部分 \t323\n第8章  Clojure项目的组织与构建\t325\n项目布局\t325\n构建\t339\n最后的思考\t355\n第9章  Java及JVM互操作\t357\nJVM是Clojure的基础\t358\nJava类、方法和字段的使用\t358\n便利的互操作工具\t361\n异常与错误处理\t363\n为了效率进行类型提示\t367\n定义类、实现接口\t372\n在Java里使用Clojure\t386\n乐于合作的伙伴\t393\n第10章  面向REPL的编程\t395\n交互式开发\t395\n工具集\t400\n在REPL里调试、监测和打补丁\t412\n重定义结构的限制\t416\n小结\t418\n第4部分 \t419\n第11章  数字与数学\t421\nClojure的数字\t421\nClojure数学\t427\n相等与等值\t432\n优化数值效率\t436\n用Clojure可视化芒德布罗集\t448\n第12章  设计模式\t457\n依赖注入\t459\n策略模式\t462\n责任链\t463\n面向方面的编程\t466\n最后的思考\t470\n第13章  测试\t471\n不可变值与纯函数\t471\nclojure.test\t473\nHTML DSL的成长\t482\n依赖断言\t486\n第14章  使用关系数据库\t491\nclojure.java.jdbc\t491\nKorma\t498\nHibernate\t503\n最后的思考\t510\n第15章  使用非关系型数据库\t511\n安装CouchDB和Clutch\t512\n基本的CRUD操作\t512\n视图\t513\n_changes: 把CouchDB滥用做消息队列\t519\n可随意点选的消息队列\t521\n最后的思考\t524\n第16章  Clojure与Web\t525\nClojure栈\t525\n基石：Ring\t526\n用Compojure路由请求\t533\n使用模板\t543\n最后的思考\t552\n第17章  布署Clojure Web应用程序\t553\nJava与Clojure Web架构\t553\n在本地运行Web应用\t561\nWeb应用程序布署\t562\n超越简单Web应用程序布署\t565\n第5部分 \t567\n第18章  明智地选择Clojure类型定义形式\t569\n第19章  在工作场所引进Clojure\t573\n只是事实…\t573\n强调生产效率\t574\n强调社群\t576\n审慎\t577\n第20章  下一步？\t579\n(dissoc Clojure ‘JVM)\t579\n4Clojure\t580\nOvertone\t581\ncore.logic\t581\nPallet\t582\nAvout\t582\nHeroku上的Clojure\t583\n关于作者\t585","pages":"618","images":{"small":"http:\/\/img3.douban.com\/spic\/s25803832.jpg","large":"http:\/\/img3.douban.com\/lpic\/s25803832.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s25803832.jpg"},"alt":"http:\/\/book.douban.com\/subject\/21661495\/","id":"21661495","publisher":"电子工业出版社","isbn10":"7121197189","isbn13":"9787121197185","title":"Clojure编程","url":"http:\/\/api.douban.com\/v2\/book\/21661495","alt_title":"Clojure Programming","author_intro":"作者介绍：\nChas Emerick是软件公司Snowtide informatics的创始人。自2008年以来，致力于Clojure语言本身以及一些开源项目的开发；长期在cemerick.com撰写Clojure、软件开发实践、创业精神，及其他主题的文章。\nBrian Carpe r是一位心理学研究领域的专业程序员，用Clojure从事数据分析与web开发。他开发过一个把Clojure代码转化为CSS代码的编译器以及一个操作关系型数据库的类库，经常在briancarper.net上发表Clojure文章。\nChristophe Grand是一个独立顾问，现居法国里昂。他主要从事Clojure培训与编码，参与了Clojure语言的开发，撰写过Enlive和 Moustache类库，也是Counterclockwise——Clojure IDE for Eclipse的贡献者，经常在clj-me.cgrand.net上发表有关Clojure的文章。\n译者介绍：\n徐明明，阿里巴巴资深软件开发工程师，热衷于研究开源技术及语言；目前网络浏览量最大的Clojure入门教程（ http:\/\/xumingming.sinaapp.com\/302\/clojure-functional-programming-for-the-jvm-clojure-tutorial\/）即译自其手；参与Twitter开源实时计算框架Storm的开发，是该项目的核心贡献者(该项目的主要语言就是Clojure), 同时也翻译了该项目的很多文档，推进了该项目在中国的应用。","summary":"Clojure是一种实用的通用语言，它是传奇语言LISP的方言，可与Ruby、Python等动态语言相媲美，更以无缝Java库、服务，以及拥有JVM系统得天独厚的资源优势而胜出。本书既可以用来熟悉Clojure基础知识与常见例子，也可了解其相关的实践领域与话题，更可以看到这一JVM平台上的LISP如何帮助消除不必要的复杂性，为大家在编程实践中解决最具挑战性的问题开辟新的选择——更具灵活性，更适于Web编程和操作数据库，可以应付更为苛刻的应用程序安全要求，更有效的并发性和并行处理、数据分析能力，以及在未来云环境下的更大的发展潜力。","price":"99.00元"},{"rating":{"max":10,"numRaters":71,"average":"8.5","min":0},"subtitle":"","author":["（美）Norman Matloff"],"pubdate":"2013-5","tags":[{"count":109,"name":"R","title":"R"},{"count":79,"name":"数据分析","title":"数据分析"},{"count":47,"name":"编程","title":"编程"},{"count":46,"name":"R语言","title":"R语言"},{"count":35,"name":"数据挖掘","title":"数据挖掘"},{"count":17,"name":"程序设计","title":"程序设计"},{"count":16,"name":"计算机","title":"计算机"},{"count":9,"name":"计算机科学","title":"计算机科学"}],"origin_title":"The Art of R Programming: A Tour of Statistical Software Design","image":"http:\/\/img5.douban.com\/mpic\/s26540607.jpg","binding":"平装","translator":["陈堰平","邱怡轩","潘岚锋 等"],"catalog":"译者序\n前　言\n致　谢\n第1章　快速入门\n1.1　怎样运行R\n1.1.1　交互模式\n1.1.2　批处理模式\n1.2　第一个R会话\n1.3　函数入门\n1.3.1　变量的作用域\n1.3.2　默认参数\n1.4　R语言中一些重要的数据结构\n1.4.1　向量，R语言中的战斗机\n1.4.2　字符串\n1.4.3　矩阵\n1.4.4　列表\n1.4.5　数据框\n1.4.6　类\n1.5　扩展案例：考试成绩的回归分析\n1.6　启动和关闭R\n1.7　获取帮助\n1.7.1　help()函数\n1.7.2　example()函数\n1.7.3　如果你不太清楚要查找什么\n1.7.4　其他主题的帮助\n1.7.5　批处理模式的帮助\n1.7.6　互联网资源\n第2章　向量\n2.1　标量、向量、数组与矩阵\n2.1.1　添加或删除向量元素\n2.1.2　获取向量长度\n2.1.3　作为向量的矩阵和数组\n2.2　声明\n2.3　循环补齐\n2.4　常用的向量运算\n2.4.1　向量运算和逻辑运算\n2.4.2　向量索引\n2.4.3　用：运算符创建向量\n2.4.4　使用seq()创建向量\n2.4.5　使用rep()重复向量常数\n2.5　使用all()和any()\n2.5.1　扩展案例：寻找连续出现1的游程\n2.5.2　扩展案例：预测离散值时间序列\n2.6　向量化运算符\n2.6.1　向量输入，向量输出\n2.6.2　向量输入，矩阵输出\n2.7　NA与NULL值\n2.7.1　NA的使用\n2.7.2　NULL的使用\n2.8　筛选\n2.8.1　生成筛选索引\n2.8.2　使用subset()函数筛选\n2.8.3　选择函数which()\n2.9　向量化的ifelse()函数\n2.9.1　扩展案例：度量相关性\n2.9.2　扩展案例：对鲍鱼数据集重新编码\n2.10　测试向量相等\n2.11　向量元素的名称\n2.12　关于c()的更多内容\n第3章　矩阵和数组\n3.1　创建矩阵\n3.2　一般矩阵运算\n3.2.1　线性代数运算\n3.2.2　矩阵索引\n3.2.3　扩展案例：图像操作\n3.2.4　矩阵元素筛选\n3.2.5　扩展案例：生成协方差矩阵\n3.3　对矩阵的行和列调用函数\n3.3.1　使用apply()函数\n3.3.2　扩展案例：寻找异常值\n3.4　增加或删除矩阵的行或列\n3.4.1　改变矩阵的大小\n3.4.2　扩展案例：找到图中距离最近的一对端点\n3.5　向量与矩阵的差异\n3.6　避免意外降维\n3.7　矩阵的行和列的命名问题\n3.8　高维数组\n第4章　列表\n4.1　创建列表\n4.2　列表的常规操作\n4.2.1　列表索引\n4.2.2　增加或删除列表元素\n4.2.3　获取列表长度\n4.2.4　扩展案例：文本词汇索引\n4.3　访问列表元素和值\n4.4　在列表上使用apply系列函数\n4.4.1　lapply()和sapply()的使用\n4.4.2　扩展案例：文本词汇索引（续）\n4.4.3　扩展案例：鲍鱼数据\n4.5　递归型列表\n第5章　数据框\n5.1　创建数据框\n5.1.1　访问数据框\n5.1.2　扩展案例：考试成绩的回归分析（续）\n5.2　其他矩阵式操作\n5.2.1　提取子数据框\n5.2.2　缺失值的处理\n5.2.3　使用rbind()和cbind()等函数\n5.2.4　使用apply()\n5.2.5　扩展案例：工资研究\n5.3　合并数据框\n5.4　应用于数据框的函数\n5.4.1　在数据框上应用lapply()和sapply()函数\n5.4.2　扩展案例：应用Logistic模型\n5.4.3　扩展案例：学习中文方言的辅助工具\n第6章　因子和表\n6.1　因子与水平\n6.2　因子的常用函数\n6.2.1　tapply函数\n6.2.2　split()函数\n6.2.3　by()函数\n6.3　表的操作\n6.3.1　表中有关矩阵和类似数组的操作\n6.3.2　扩展案例： 提取子表\n6.3.3　扩展案例：在表中寻找频数最大的单元格\n6.4　其他与因子和表有关的函数\n6.4.1　aggregate()函数\n6.4.2　cut()函数\n第7章　R语言编程结构\n7.1　控制语句\n7.1.1　循环\n7.1.2　对非向量集合的循环\n7.1.3　if-else结构\n7.2　算术和逻辑运算符及数值\n7.3　参数的默认值\n7.4　返回值\n7.4.1　决定是否显式调用return ()\n7.4.2　返回复杂对象\n7.5　函数都是对象\n7.6　环境和变量作用域的问题\n7.6.1　顶层环境\n7.6.2　变量作用域的层次\n7.6.3　关于ls()的进一步讨论\n7.6.4　函数（几乎）没有副作用\n7.6.5　扩展案例：显示调用框的函数\n7.7　R语言中没有指针\n7.8　向上级层次进行写操作\n7.8.1　利用超赋值运算符对非局部变量进行写操作\n7.8.2　用assign()函数对非局部变量进行写操作\n7.8.3　扩展案例：用R语言实现离散事件仿真\n7.8.4　什么时候使用全局变量\n7.8.5　闭包\n7.9　递归\n7.9.1　Quicksort的具体实现\n7.9.2　拓展举例：二叉查找树\n7.10　置换函数\n7.10.1　什么是置换函数\n7.10.2　扩展案例：可记录元素修改次数的向量类\n7.11　写函数代码的工具\n7.11.1　文本编辑器和集成开发环境\n7.11.2　edit()函数\n7.12　创建自己的二元运算符\n7.13　匿名函数\n第8章　数学运算与模拟\n8.1　数学函数\n8.1.1　扩展例子：计算概率\n8.1.2　累积和与累积乘积\n8.1.3　最小值和最大值\n8.1.4　微积分\n8.2　统计分布函数\n8.3　排序\n8.4　向量和矩阵的线性代数运算\n8.4.1　扩展示例：向量叉积\n8.4.2　扩展示例：确定马尔科夫链的平稳分布\n8.5　集合运算\n8.6　用R做模拟\n8.6.1　内置的随机变量发生器\n8.6.2　重复运行时获得相同的随机数流\n8.6.3　扩展案例：组合的模拟\n第9章　面向对象的编程\n9.1　S3类\n9.1.1　S3泛型函数\n9.1.2　实例：线性模型函数lm()中的OOP\n9.1.3　寻找泛型函数的实现方法\n9.1.4　编写S3类\n9.1.5　使用继承\n9.1.6　扩展示例：用于存储上三角矩阵的类\n9.1.7　扩展示例：多项式回归程序\n9.2　S4类\n9.2.1　编写S4类\n9.2.2　在S4类上实现泛型函数\n9.3　S3类和S4类的对比\n9.4　对象的管理\n9.4.1　用ls()函数列出所有对象\n9.4.2　用rm()函数删除特定对象\n9.4.3　用save()函数保存对象集合\n9.4.4　查看对象内部结构\n9.4.5　exists()函数\n第10章　输入与输出\n10.1　连接键盘与显示器\n10.1.1　使用scan()函数\n10.1.2　使用readline()函数\n10.1.3　输出到显示器\n10.2　读写文件\n10.2.1　从文件中读取数据框或矩阵\n10.2.2　读取文本文件\n10.2.3　连接的介绍\n10.2.4　扩展案例：读取PUMS普查数据\n10.2.5　通过URL在远程计算机上访问文件\n10.2.6　写文件\n10.2.7　获取文件和目录信息\n10.2.8　扩展案例：多个文件内容的和\n10.3　访问互联网\n10.3.1　TCP\/IP概述\n10.3.2　R中的socket\n10.3.3　扩展案例：实现R的并行计算\n第11章　字符串操作\n11.1　字符串操作函数概述\n11.1.1　grep()\n11.1.2　nchar()\n11.1.3　paste()\n11.1.4　sprintf()\n11.1.5　substr()\n11.1.6　strsplit()\n11.1.7　regexpr()\n11.1.8　gregexpr()\n11.2　正则表达式\n11.2.1　扩展案例：检测文件名的后缀\n11.2.2　扩展案例：生成文件名\n11.3　在调试工具edtdbg中使用字符串工具\n第12章　绘图\n12.1　创建图形\n12.1.1　基础图形系统的核心：plot()函数\n12.1.2　添加线条：abline()函数\n12.1.3　在保持现有图形的基础上新增一个绘图窗口\n12.1.4　扩展案例：在一张图中绘制两条密度曲线\n12.1.5　扩展案例：进一步考察多项式回归\n12.1.6　添加点：points()函数\n12.1.7　添加图例：legend()函数\n12.1.8　添加文字：text()函数\n12.1.9　精确定位：locator()函数\n12.1.10　保存图形\n12.2　定制图形\n12.2.1　改变字符大小：cex选项\n12.2.2　改变坐标轴的范围：xlim和ylim选项\n12.2.3　添加多边形：polygon()函数\n12.2.4　平滑散点：lowess()和loess()函数\n12.2.5　绘制具有显式表达式的函数\n12.2.6　扩展案例：放大曲线的一部分\n12.3　将图形保存到文件\n12.3.1　R图形设备\n12.3.2　保存已显示的图形\n12.3.3　关闭R图形设备\n12.4　创建三维图形\n第13章　调试\n13.1　调试的基本原则\n13.1.1　调试的本质：确认原则\n13.1.2　从小处着手\n13.1.3　模块化的、自顶向下的调试风格\n13.1.4　反漏洞\n13.2　为什么要使用调试工具\n13.3　使用R的调试工具\n13.3.1　利用debug()和browser()函数进行逐步调试\n13.3.2　使用浏览器命令\n13.3.3　设置断点\n13.3.4　使用trace()函数进行追踪\n13.3.5　使用traceback()和debugger()函数对崩溃的程序进行检查\n13.3.6　扩展案例：两个完整的调试会话\n13.4　更方便的调试工具\n13.5　在调试模拟数据的代码时请确保一致性\n13.6　语法和运行时错误\n13.7　在R上运行GDB\n第14章　性能提升：速度和内存\n14.1　编写快速的R代码\n14.2　可怕的for循环\n14.2.1　用向量化提升速度\n14.2.2　扩展案例：在蒙特卡罗模拟中获得更快的速度\n14.2.3　扩展案例：生成幂次矩阵\n14.3　函数式编程和内存问题\n14.3.1　向量赋值问题\n14.3.2　改变时拷贝\n14.3.3　扩展案例：避免内存拷贝\n14.4　利用Rprof()来寻找代码的瓶颈\n14.4.1　利用Rprof()来进行监视\n14.4.2　Rprof()的工作原理\n14.5　字节码编译\n14.6　内存无法装下数据怎么办\n14.6.1　分块\n14.6.2　利用R软件包来进行内存管理\n第15章　R与其他语言的接口\n15.1　编写能被R调用的C\/C++函数\n15.1.1　R与C\/C++交互的预备知识\n15.1.2　例子：提取方阵的次对角线元素\n15.1.3　编译和运行程序\n15.1.4　调试R\/C程序\n15.1.5　扩展案例：预测离散取值的时间序列\n15.2　从Python调用R\n15.2.1　安装RPy\n15.2.2　RPy语法\n第16章　R语言并行计算\n16.1　共同外链问题\n16.2　snow包简介\n16.2.1　运行snow代码\n16.2.2　分析snow代码\n16.2.3　可以获得多少倍的加速\n16.2.4　扩展案例：K均值聚类\n16.3　借助于C\n16.3.1　利用多核机器\n16.3.2　扩展案例：利用OpenMP解决共同外链问题\n16.3.3　运行OpenMP代码\n16.3.4　OpenMP代码分析\n16.3.5　其他OpenMP指令\n16.3.6　GPU编程\n16.4　普遍的性能考虑\n16.4.1　开销的来源\n16.4.2　简单并行程序，以及那些不简单的\n16.4.3　静态和动态任务分配\n16.4.4　软件炼金术：将一般的问题转化为简单并行问题\n16.5　调试R语言并行计算的代码\n附录A　安装R\n附录B　安装和使用包","pages":"303","images":{"small":"http:\/\/img5.douban.com\/spic\/s26540607.jpg","large":"http:\/\/img5.douban.com\/lpic\/s26540607.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s26540607.jpg"},"alt":"http:\/\/book.douban.com\/subject\/24699632\/","id":"24699632","publisher":"机械工业出版社","isbn10":"7111423143","isbn13":"9787111423140","title":"R语言编程艺术","url":"http:\/\/api.douban.com\/v2\/book\/24699632","alt_title":"The Art of R Programming: A Tour of Statistical Software Design","author_intro":"Norman Matloff 著名计算机科学家兼统计学家，美国加州大学戴维斯分校计算机科学系教授，曾是该校统计专业的创建者之一，并担任过统计学教授。对并行编程、网络流量、数据挖掘、磁盘系统性能等方面的技术都有深入的研究。乐于分享，撰写了多部广受欢迎的关于软件开发的在线教程，多次为《纽约时报》、《华盛顿邮报》、《福布斯杂志》以及《洛杉矶时报》撰写文章，同时他还是《The Art of Debugging》的作者之一。","summary":"【编辑推荐】\n这本书涵盖了R语言编程的诸多方面，尤其在面向对象编程、程序调试、提升程序运行速度以及并行计算等方面，填补了同类图书的空白。关于程序调试的章节更是作者多年经验的总结。不管是初学者还是有一定编程经验的读者，阅读这本书都会有所收获。\n——统计之都\n【内容简介】\nR语言是世界上最流行的用于数据处理和统计分析的脚本语言。考古学家用它来跟踪古代文明的传播，医药公司用它来探索哪种药物更安全、更有效，精算师用它评估金融风险以保证市场的平稳运行。总之，在大数据时代，统计数据、分析数据都离不开计算机软件的支持，在这方面R语言尤其出色。\n本书将带领你踏上R语言软件开发之旅，从最基本的数据类型和数据结构开始，到闭包、递归和匿名函数等高级主题，由浅入深，讲解细腻，读者完全不需要统计学的知识，甚至不需要编程基础。而书中提到的很多高级编程技巧，都是作者多年编程经验的总结，对有经验的开发者也大有裨益。本书精选了44个扩展案例，这些案例都源自于作者亲身参与过的咨询项目，都是与数据分析相关的，生动展示了R语言在统计学中的高效应用。\n本书核心内容：\n R语言的完整语法以及R语言的编程技巧\n 创建精美图形来展示复杂数据和函数\n 使用并行计算和向量化的方法编写更高效的代码\n 使用R对C\/C++和Python的接口来提高计算速度或增加功能\n 文本分析、图像处理等领域新的R包\n 使用高级调试技巧清除代码里恼人的错误\n 包含许多“扩展案例”，展示完整的、特定用途的函数，并针对同一个问题讨论了不同的设计方案，以便分析高效准确的做法。\n 在恰当的时候介绍R语言与其他语言的差异，给那些了解其他语言的开发人员提供参考。\n【相关图书推荐】\n978-7-111-40700-3 数据挖掘与R语言\n978-7-111-42021-7 R语言经典实例\n978-7-111-41731-6 机器学习：实用案例解析\n978-7-111-32572-7 时间序列分析及应用：R语言（原书第2版）","price":"69.00"},{"rating":{"max":10,"numRaters":59,"average":"7.6","min":0},"subtitle":"改善网络程序的44个技巧","author":["Jon C.Snader"],"pubdate":"2011-4-10","tags":[{"count":110,"name":"TCP\/IP","title":"TCP\/IP"},{"count":100,"name":"网络编程","title":"网络编程"},{"count":32,"name":"网络","title":"网络"},{"count":23,"name":"Networking","title":"Networking"},{"count":20,"name":"编程","title":"编程"},{"count":14,"name":"Programming","title":"Programming"},{"count":13,"name":"计算机","title":"计算机"},{"count":11,"name":"计算机科学","title":"计算机科学"}],"origin_title":"Effective TCP\/IP Programming: 44 Tips to Improve Your Network Programs","image":"http:\/\/img5.douban.com\/mpic\/s4685889.jpg","binding":"","translator":["陈涓","赵振平"],"catalog":"第1章 概述        1\n1.1 几个约定        1\n1.2 本书其余部分的内容介绍        2\n1.3 客户端—服务器结构        4\n1.4 对基本套接字API的回顾        5\n1.5 小结        12\n第2章 基本概念        13\n2.1        技巧1：理解面向连接和无连接协议之间的区别        13\n2.2 技巧2：理解子网和CIDR的概念        18\n2.2.1 分类编址        18\n2.2.2 子网划分        21\n2.2.3 CIDR        26\n2.2.4 子网划分和CIDR的状态        27\n2.2.5 小结        27\n2.3 技巧3：理解私有地址和NAT        28\n2.4 技巧4：开发并使用应用程序“框架”        30\n2.4.1 TCP服务器框架        31\n2.4.2 TCP客户端框架        36\n2.4.3 UDP服务器框架        38\n2.4.4 UDP客户端框架        39\n2.4.5 小结        41\n2.5 技巧5：套接字接口比XTI\/TLI更好用        41\n2.6 技巧6：记住，TCP是一种流协议        43\n2.7 技巧7：不要低估TCP的性能        50\n2.7.1 UDP源程序与接收程序        52\n2.7.2 TCP源程序及接收程序        53\n2.7.3 小结        59\n2.8 技巧8：避免重新编写TCP        59\n2.9 技巧9：要认识到TCP是一个可靠的，但并不绝对可靠的协议        61\n2.9.1 可靠性——是什么，不是什么        61\n2.9.2 故障模式        63\n2.9.3 网络中断        63\n2.9.4 对等实体崩溃        64\n2.9.5 对等实体的主机崩溃        68\n2.9.6 小结        69\n2.10 技巧10：记住，TCP\/IP不是轮询的        69\n2.10.1 保持活跃        70\n2.10.2 心跳信号        71\n2.10.3 另一个例子        76\n2.10.4 小结        81\n2.11 技巧11：提防对等实体的不友好动作        81\n2.11.1 检测客户端的终止        82\n2.11.2 检测无效输入        84\n2.11.3 小结        88\n2.12 技巧12：成功的LAN策略不一定能推广到WAN中去        88\n2.12.1 性能问题举例        88\n2.12.2 隐含错误举例        89\n2.12.3 小结        93\n2.13 技巧13：了解协议是怎样工作的        93\n2.14 技巧14：不要把OSI七层参考模型太当回事        94\n2.14.1 OSI模型        95\n2.14.2 TCP\/IP模型        96\n2.14.3 小结        98\n第3章 构建高效且健壮的网络程序        99\n3.1 技巧15：理解TCP的写操作        99\n3.1.1 从应用程序的角度看写操作        99\n3.1.2 从TCP角度看写操作        100\n3.1.3 小结        103\n3.2 技巧16：理解TCP的有序释放操作        103\n3.2.1 shutdown调用        104\n3.2.2 有序释放        106\n3.2.3 小结        110\n3.3 技巧17：考虑用inetd来装载应用程序        111\n3.3.1 TCP服务器        111\n3.3.2 UDP服务器        114\n3.3.3 小结        118\n3.4 技巧18：考虑用tcpmux为服务器“分配”知名端口        118\n3.5 技巧19：考虑使用两条TCP连接        126\n3.5.1 单连接结构        127\n3.5.2 双连接架构        128\n3.5.3 小结        133\n3.6 技巧20：使应用程序成为事件驱动的（1）        133\n3.7 技巧21：使应用程序成为事件驱动的（2）        140\n3.8 技巧22：不要用TIME-WAIT暗杀来关闭一条连接        147\n3.8.1 它是什么        147\n3.8.2 为什么要使用它        149\n3.8.3 TIME-WAIT暗杀        150\n3.8.4 小结        151\n3.9 技巧23：服务器应该设置SO_REUSEADDR选项        151\n3.10 技巧24：可能的话，使用一个大规模的写操作，而不是多个小规模的写操作        155\n3.10.1 禁用Nagle算法        158\n3.10.2 将写操作合并起来        159\n3.10.3 小结        161\n3.11 技巧25：理解如何使connect调用超时        162\n3.11.1 使用告警        162\n3.11.2 使用select        164\n3.11.3 小结        167\n3.12 技巧26：避免数据复制        167\n3.12.1 共享内存缓冲区        168\n3.12.2 一个共享内存缓冲区系统        169\n3.12.3 一个UNIX实现        171\n3.12.4 一个Windows实现        175\n3.12.5 小结        179\n3.13 技巧27：使用前将结构sockadddr_in清零        179\n3.14 技巧28：不要忘记字节的性别        180\n3.15 技巧29：不要将IP地址或端口号硬编入应用程序中        182\n3.16 技巧30：理解已连接的UDP套接字        187\n3.17 技巧31：记住，并不是所有程序都是用C编写的        190\n3.18 技巧32：理解缓冲区长度带来的影响        195\n第4章 工具和资源        199\n4.1 技巧33：熟悉ping实用工具        199\n4.2 技巧34：学习使用tcpdump或类似的工具        201\n4.2.1 tcpdump是如何工作的        202\n4.2.2 使用tcpdump        205\n4.2.3 tcpdump的输出        206\n4.2.4 小结        210\n4.3 技巧35：学习使用traceroute        210\n4.3.1 traceroute是如何工作的        212\n4.3.2 Windows TRACERT        214\n4.3.3 小结        215\n4.4 技巧36：学习使用ttcp        215\n4.5 技巧37：学习使用lsof        219\n4.6 技巧38：学习使用netstat        221\n4.6.1 活动套接字        221\n4.6.2 接口        223\n4.6.3 路由表        223\n4.6.4 协议统计        225\n4.6.5 Windows版的netstat        227\n4.6.6 小结        227\n4.7 技巧39：学习使用系统中的调用追踪工具        227\n4.7.1 过早终止        227\n4.7.2 ttcp性能问题        231\n4.7.3 小结        232\n4.8 技巧40：构建并使用捕获ICMP报文的工具        233\n4.8.1 读取ICMP报文        233\n4.8.2 打印ICMP报文        234\n4.8.3 小结        239\n4.9 技巧41：读Stevens的书        240\n4.9.1 《TCP\/IP详解》丛书        240\n4.9.2 《UNIX网络编程》丛书        241\n4.10 技巧42：阅读代码        242\n4.11 技巧43：访问RFC编辑者的页面        243\n4.12 技巧44：经常访问新闻组        244\n附录A 各种UNIX代码        247\n附录B 各种Windows代码        250\n参考书目        253\n索引        257","pages":"280","images":{"small":"http:\/\/img5.douban.com\/spic\/s4685889.jpg","large":"http:\/\/img5.douban.com\/lpic\/s4685889.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s4685889.jpg"},"alt":"http:\/\/book.douban.com\/subject\/6058986\/","id":"6058986","publisher":"人民邮电出版社","isbn10":"7115249377","isbn13":"9787115249371","title":"TCP\/IP高效编程","url":"http:\/\/api.douban.com\/v2\/book\/6058986","alt_title":"Effective TCP\/IP Programming: 44 Tips to Improve Your Network Programs","author_intro":"Jon Snader　TCP\/IP专家，Paradigm4的资深软件工程师。他的工作领域包括通信、网络、编译器开发、操作系统以及无线网络控制器等。最近主要从事公共安全市场的报文交换系统方面的工作。","summary":"作为网络程序员，你是否发现自己的应用程序远远不够健壮？那么，你需要了解编写高效TCP\/IP程序所需的各种知识。本书正是这么一本经典著作，它专注于协议族中那些细微的特性，提炼出的44个技巧可立竿见影地提升编程能力。\n本书在介绍这些技巧的同时，对TCP\/IP编程的基本思想和概念进行了说明，结合大量实例透彻解析了TCP\/IP中的实践经验以及法则，还说明了如何避免网络编程中一些最常见的问题。书中提供的框架代码和常用函数库让你能够方便快捷地编写出应用程序，而无需操心一些细枝末节。\n书中对下列问题提出了宝贵建议：\n        IP编址、子网以及CIDR的研究\n        使用套接字接口代替XTI\/TLI\n        使用两条TCP连接\n        使应用程序成为事件驱动的\n        使用一次大规模写操作代替多次小规模写操作\n        避免数据复制\n        理解TCP可靠性的涵义\n        认识缓冲区大小带来的影响\n        高效使用tcpdump、traceroute、netstat和ping","price":"55.00元"},{"rating":{"max":10,"numRaters":73,"average":"8.5","min":0},"subtitle":"","author":["[美] Martin Logan","[美] Eric Merritt","[瑞典] Richard Carlsson"],"pubdate":"2012-8","tags":[{"count":114,"name":"erlang","title":"erlang"},{"count":66,"name":"并发编程","title":"并发编程"},{"count":58,"name":"Erlang\/OTP","title":"Erlang\/OTP"},{"count":28,"name":"Erlang","title":"Erlang"},{"count":27,"name":"编程","title":"编程"},{"count":22,"name":"计算机","title":"计算机"},{"count":19,"name":"函数式编程","title":"函数式编程"},{"count":13,"name":"程序设计","title":"程序设计"}],"origin_title":"Erlang and OTP in Action","image":"http:\/\/img3.douban.com\/mpic\/s10457041.jpg","binding":"平装","translator":["连　城"],"catalog":"目　　录\n\n第一部分　Erlang起步：OTP基础\n第1章　Erlang\/OTP平台\t2\n1.1　基于进程的并发编程\t3\n1.1.1　理解并发\t3\n1.1.2　Erlang的进程模型\t4\n1.1.3　4种进程通信范式\t5\n1.1.4　用Erlang进程编程\t8\n1.2　Erlang的容错架构\t10\n1.2.1　进程链接如何工作\t10\n1.2.2　监督与退出信号捕捉\t10\n1.2.3　进程的分层容错\t12\n1.3　分布式Erlang\t13\n1.4　Erlang运行时系统和虚拟机\t13\n1.4.1　调度器\t14\n1.4.2　I\/O与调度\t15\n1.4.3　进程隔离与垃圾回收器\t15\n1.5　函数式编程：Erlang的处世之道\t16\n1.6　小结\t16\n第2章　Erlang语言精要\t18\n2.1　Erlang shell\t19\n2.1.1　启动shell\t19\n2.1.2　输入表达式\t20\n2.1.3　shell函数\t21\n2.1.4　退出shell\t21\n2.1.5　任务控制基础\t22\n2.2　Erlang的数据类型\t23\n2.2.1　数值与算术运算\t24\n2.2.2　二进制串与位串\t25\n2.2.3　原子\t26\n2.2.4　元组\t27\n2.2.5　列表\t27\n2.2.6　字符串\t28\n2.2.7　pid、端口和引用\t29\n2.2.8　将函数视作数据：fun函数\t30\n2.2.9　项式的比较\t30\n2.2.10　解读列表\t31\n2.3　模块和函数\t33\n2.3.1　调用其他模块中的函数（远程调用）\t33\n2.3.2　不同元数的函数\t34\n2.3.3　内置函数和标准库模块\t34\n2.3.4　创建模块\t35\n2.3.5　模块的编译和加载\t36\n2.3.6　独立编译器erlc\t37\n2.3.7　已编译模块与在shell中求值\t37\n2.4　变量与模式匹配\t38\n2.4.1　变量的语法\t39\n2.4.2　单次赋值\t39\n2.4.3　模式匹配：加强版的赋值\t41\n2.4.4　解读模式\t42\n2.5　函数与子句\t44\n2.5.1　带副作用的函数：文本打印\t44\n2.5.2　用模式匹配在多个子句中进行选择\t45\n2.5.3　保护式\t46\n2.5.4　模式、子句和变量作用域\t47\n2.6　Case和if表达式\t48\n2.6.1　Erlang的布尔型if-then-else\n分支选择\t48\n2.6.2　If表达式\t49\n2.7　fun函数\t49\n2.7.1　作为现有函数别名的fun函数\t49\n2.7.2　匿名fun函数\t50\n2.8　异常与try\/catch\t52\n2.8.1　抛出（触发）异常\t52\n2.8.2　运用try...catch\t53\n2.8.3　try...of...catch\t53\n2.8.4　after\t54\n2.8.5　获取栈轨迹\t54\n2.8.6　重抛异常\t55\n2.8.7　传统的catch\t55\n2.9　列表速构\t56\n2.9.1　列表速构记法\t56\n2.9.2　映射、过滤和模式匹配\t56\n2.10　比特位语法与位串速构\t57\n2.10.1　构造位串\t57\n2.10.2　比特位语法中的模式匹配\t58\n2.10.3　位串速构\t59\n2.11　记录语法\t59\n2.11.1　记录声明\t60\n2.11.2　创建记录\t60\n2.11.3　记录的字段以及模式匹配\t60\n2.11.4　更新记录字段\t60\n2.11.5　记录声明应该放在哪儿\t61\n2.12　预处理与文件包含\t61\n2.12.1　宏的定义和使用\t61\n2.12.2　文件包含\t62\n2.12.3　条件编译\t63\n2.13　进程\t64\n2.13.1　操纵进程\t64\n2.13.2　消息接收与选择性接收\t65\n2.13.3　注册进程\t66\n2.13.4　消息投递与信号\t67\n2.13.5　进程字典\t67\n2.14　ETS表\t68\n2.14.1　为何ETS表被设计成这样\t68\n2.14.2　ETS表的基本用法\t68\n2.15　以递归代替循环\t69\n2.15.1　从迭代到递归\t69\n2.15.2　理解尾递归\t71\n2.15.3　累加器参数\t72\n2.15.4　谈谈效率\t72\n2.15.5　编写递归函数的窍门\t73\n2.16　Erlang编程资源\t78\n2.16.1　图书\t78\n2.16.2　在线资料\t79\n2.17　小结\t79\n第3章　开发基于TCP的RPC服务\t80\n3.1　你所创建的是什么\t81\n3.1.1　基础知识提醒\t82\n3.1.2　行为模式基础\t82\n3.2　实现RPC服务器\t85\n3.2.1　行为模式实现模块的典型布局\t85\n3.2.2　模块首部\t85\n3.2.3　API段\t88\n3.2.4　回调函数段\t92\n3.3　运行RPC服务器\t98\n3.4　浅谈测试\t99\n3.5　小结\t100\n第4章　OTP应用与监督机制\t101\n4.1　OTP应用\t101\n4.1.1　OTP应用的组织形式\t102\n4.1.2　为应用添加元数据\t103\n4.1.3　应用行为模式\t104\n4.1.4　应用结构小结\t105\n4.2　用监督者实现容错\t105\n4.2.1　实现监督者\t106\n4.2.2　监督者重启策略\t107\n4.2.3　编写子进程规范\t108\n4.3　启动应用\t109\n4.4　生成EDoc文档\t110\n4.5　小结\t110\n第5章　主要图形化监测工具的使用\t112\n5.1　Appmon\t112\n5.1.1　Appmon GUI\t112\n5.1.2　WebTool版Appmon\t115\n5.2　Pman\t116\n5.3　调试器\t118\n5.4　表查看器TV\t121\n5.5　工具栏\t123\n5.6　小结\t123\n第二部分　构建生产系统\n第6章　打造一套缓存系统\t126\n6.1　故事背景\t126\n6.2　缓存的设计\t127\n6.3　创建OTP应用的基本骨架\t130\n6.3.1　应用目录结构的布局\t130\n6.3.2　创建应用元数据\t130\n6.3.3　实现应用行为模式\t131\n6.3.4　实现监督者\t131\n6.4　从应用骨架到五脏俱全的缓存\t133\n6.4.1　编写sc_element进程\t134\n6.4.2　实现sc_store模块\t138\n6.4.3　打造应用层API模块\t142\n6.5　小结\t144\n第7章　Erlang\/OTP中的日志与事件\n处理\t145\n7.1　Erlang\/OTP中的日志\t146\n7.1.1　日志概述\t146\n7.1.2　Erlang\/OTP内置的日志设施\t147\n7.1.3　标准日志函数\t147\n7.1.4　SASL与崩溃报告\t149\n7.2　用gen_event编写自定义事件\n处理器\t153\n7.2.1　gen_event行为模式简介\t153\n7.2.2　事件处理器示例\t154\n7.2.3　处理错误事件\t155\n7.3　为Simple Cache添加自定义事件流\t157\n7.3.1　事件流API\t157\n7.3.2　将处理器整合进Simple Cache\t159\n7.3.3　订阅自定义事件流\t161\n7.4　小结\t162\n第8章　分布式Erlang\/OTP简介\t163\n8.1　Erlang分布式基础\t163\n8.1.1　复制式进程间通信\t164\n8.1.2　位置透明性\t165\n8.2　节点与集群\t166\n8.2.1　节点的启动\t166\n8.2.2　节点的互联\t167\n8.2.3　Erlang节点如何定位其他节点并与之建立通信\t169\n8.2.4　magic cookie安全系统\t170\n8.2.5　互联节点间的消息传递\t171\n8.2.6　使用远程shell\t173\n8.3　资源探测攻略\t175\n8.3.1　术语\t175\n8.3.2　算法\t176\n8.3.3　实现资源探测应用\t177\n8.4　小结\t182\n第9章　用Mnesia为cache增加分布\n式支持\t183\n9.1　分布式缓存\t184\n9.1.1　选取通信策略\t184\n9.1.2　同步缓存和异步缓存\t186\n9.1.3　分布式表\t188\n9.2　用Mnesia实现分布式数据存储\t189\n9.2.1　建立项目数据库\t189\n9.2.2　初始化数据库\t191\n9.2.3　建表\t192\n9.2.4　向表中录入数据\t195\n9.2.5　执行基本查询\t197\n9.3　基于Mnesia的分布式缓存\t199\n9.3.1　用Mnesia取代ETS\t199\n9.3.2　让缓存识别出其他节点\t202\n9.3.3　用资源探测定位其他缓存\n实例\t205\n9.3.4　动态复制Mnesia表\t206\n9.4　小结\t209\n第10章　打包、服务和部署\t210\n10.1　从系统的角度看应用\t210\n10.1.1　结构\t211\n10.1.2　元数据\t211\n10.1.3　系统如何管理运行中的\n应用\t212\n10.2　制作发布镜像\t213\n10.2.1　发布镜像\t213\n10.2.2　准备发布代码\t214\n10.2.3　发布镜像的元数据文件\t214\n10.2.4　脚本与启动文件\t216\n10.2.5　系统配置\t217\n10.2.6　启动目标系统\t218\n10.3　发布镜像打包\t219\n10.3.1　创建发布镜像包\t219\n10.3.2　发布镜像包的内容\t220\n10.3.3　定制发布镜像包\t222\n10.4　安装发布镜像\t223\n10.5　小结\t223\n第三部分　集成与完善\n第11章　为缓存添加HTTP接口\t226\n11.1　实现TCP服务器\t226\n11.1.1　高效TCP服务器的设计\n模式\t227\n11.1.2　搭建tcp_interface应用的\n骨架\t228\n11.1.3　填充TCP服务器的实现\n逻辑\t228\n11.1.4　简单文本协议\t231\n11.1.5　文本接口实现\t232\n11.2　打造一套全新的Web接口\t234\n11.2.1　HTTP简介\t234\n11.2.2　实现一套通用的Web服务\n器行为模式\t237\n11.2.3　初识REST\t248\n11.2.4　用gen_web_server实现\nREST式协议\t249\n11.3　小结\t252\n第12章　用端口和NIF集成外围代码\t253\n12.1　端口和NIF\t254\n12.1.1　普通端口\t255\n12.1.2　链入式端口驱动\t256\n12.1.3　原生函数（NIF）\t257\n12.2　用端口来集成解析器\t257\n12.2.1　Erlang方面的端口\t257\n12.2.2　C方面的端口\t260\n12.2.3　编译运行\t271\n12.3　开发链入式驱动\t272\n12.3.1　初识链入式驱动\t273\n12.3.2　驱动的C语言部分\t274\n12.3.3　编译驱动代码\t278\n12.3.4　驱动的Erlang部分\t279\n12.4　将解析器实现为NIF\t280\n12.4.1　NIF的Erlang部分\t280\n12.4.2　NIF的C代码部分\t281\n12.4.3　编译与运行代码\t287\n12.5　小结\t288\n第13章　用Jinterface实现Erlang和\nJava间的通信\t289\n13.1　利用Jinterface在Erlang中集成\nJava\t290\n13.1.1　OtpNode类\t290\n13.1.2　OtpMbox类\t291\n13.1.3　Erlang数据结构的Java\n映射\t291\n13.1.4　示例：Java中的消息处理\t292\n13.1.5　在Erlang中与Java节点\n通信\t294\n13.2　安装和配置HBase\t296\n13.2.1　下载和安装\t296\n13.2.2　配置HBase\t296\n13.3　为Simple Cache和HBase牵线\n搭桥\t297\n13.3.1　Erlang方面：sc_hbase.erl\t298\n13.3.2　HBaseConnector类\t299\n13.3.3　Java中的消息处理\t301\n13.3.4　HBaseTask类\t304\n13.4　在Simple Cache中整合HBase\t306\n13.4.1　查询\t306\n13.4.2　插入\t307\n13.4.3　删除\t307\n13.5　运行集成系统\t308\n13.6　小结\t310\n第14章　优化与性能\t311\n14.1　如何进行性能调优\t312\n14.1.1　设定性能目标\t312\n14.1.2　设定基线\t313\n14.1.3　系统性能分析\t313\n14.1.4　确定需要解决的问题\t313\n14.1.5　测定优化成果\t313\n14.2　Erlang代码性能分析\t314\n14.2.1　用cprof计算调用次数\t314\n14.2.2　用fprof测定执行时间\t316\n14.3　Erlang编程语言的缺陷\t320\n14.3.1　基本数据类型的性能特点\t321\n14.3.2　内置函数和运算符的性能\t324\n14.3.3　函数\t325\n14.3.4　进程\t327\n14.4　小结\t329\n附录A　安装Erlang\t330\n附录B　列表与引用透明性\t332\n","pages":"333","images":{"small":"http:\/\/img3.douban.com\/spic\/s10457041.jpg","large":"http:\/\/img3.douban.com\/lpic\/s10457041.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s10457041.jpg"},"alt":"http:\/\/book.douban.com\/subject\/10863118\/","id":"10863118","publisher":"人民邮电出版社","isbn10":"7115285594","isbn13":"9787115285591","title":"Erlang\/OTP并发编程实战","url":"http:\/\/api.douban.com\/v2\/book\/10863118","alt_title":"Erlang and OTP in Action","author_intro":"作者简介：\nMartin Logan 从1999年开始活跃于Erlang社区，后来全职从事Erlang研发。目前任职于全球最大的在线旅游公司Orbitz Worldwide，为基于大规模分布式服务的基础设施开发解决方案。Erlware联合创始人，核心开发人员，Erlang\/OTP软件包管理系统Faxien的主要开发者。\nEric Merritt 专注并发编程和分布式系统。曾任职于Amazon.com，现为eCD Market软件工程师。Erlware联合创始人，Erlang芝加哥用户组核心成员。Erlware团队开源产品核心开发人员，Erlang\/OTP构建系统Sinan的主要开发者。\nRichard Carlsson  瑞典乌普萨拉大学高性能Erlang计划（HiPE）早期成员，研究Erlang技术达17年，曾为标准库、Erlang编译器、运行时系统和Erlang语言本身都作出过不少贡献。此外，他还是Erlang文档系统EDoc和单元测试框架EUnit的创建者。目前加入了Kreditor，致力于高可用性支付系统的Erlang开发。\n译者简介：\n连城\n百度资深软件工程师，《Erlang并发编程（第一部分）》社区翻译项目组织者及主要译者。对分布式存储、分布式消息系统、程序语言设计实现抱有浓厚兴趣。","summary":"内容简介：\n通过提高CPU时钟频率来制造更快的单核芯片的技术已经到达了极限。多核、并发、分布式等概念和技术也随之走出象牙塔，成为每个一线开发者的必备技能。由通信巨头爱立信研发的Erlang\/OTP大放异彩，二十多年来，在传统电信领域高并发、高可靠、高容错的严酷环境下，Erlang语言和OTP平台被锻炼得坚如磐石，浓郁的函数式特质更是恰到好处地弥补了传统命令式语言在并发编程上的固有缺陷，大大降低了构筑并发、容错、分布式应用的门槛。\n如果将Erlang语言看成才华横溢的钢琴家，那么OTP平台就是一架能让钢琴家把才能发挥得淋漓尽致的钢琴。本书除了全面介绍Erlang语言和OTP平台的基础知识外，还通过一系列实用案例引领你深入了解OTP的高级特性，一步步构建一个大型生产系统，并加以优化和完善。三位作者在Erlang领域拥有极其丰富的实战经验，细致入微地剖析了OTP开发与部署的全过程。要想真刀真枪地上战场，本书才是你明智的选择！","price":"79.00元"},{"rating":{"max":10,"numRaters":56,"average":"8.2","min":0},"subtitle":"","author":["布克兰德"],"pubdate":"2006-5","tags":[{"count":74,"name":"游戏开发","title":"游戏开发"},{"count":67,"name":"人工智能","title":"人工智能"},{"count":67,"name":"AI","title":"AI"},{"count":31,"name":"编程","title":"编程"},{"count":24,"name":"计算机","title":"计算机"},{"count":22,"name":"游戏","title":"游戏"},{"count":13,"name":"游戏编程","title":"游戏编程"},{"count":11,"name":"算法","title":"算法"}],"origin_title":"AI Techniques for Game Programming","image":"http:\/\/img3.douban.com\/mpic\/s1722354.jpg","binding":"平装","translator":["吴祖增"],"catalog":"","pages":"296","images":{"small":"http:\/\/img3.douban.com\/spic\/s1722354.jpg","large":"http:\/\/img3.douban.com\/lpic\/s1722354.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s1722354.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1831698\/","id":"1831698","publisher":"清华大学出版社","isbn10":"7302125996","isbn13":"9787302125990","title":"游戏编程中的人工智能技术","url":"http:\/\/api.douban.com\/v2\/book\/1831698","alt_title":"AI Techniques for Game Programming","author_intro":"","summary":"《游戏编程中的人工智能技术》是人工智能游戏编程的一本指南性读物，介绍在游戏开发中怎样应用遗传算法和人工神经网络来创建电脑游戏中所需要的人工智能。书中包含了许多实用例子，所有例子的完整源码和可执行程序都能在随书附带的光盘上找到。光盘中还有不少其他方面的游戏开发资料和一个赛车游戏演示软件。    《游戏编程中的人工智能技术》适合遗传算法和人工神经网络等人工智能技术的各行业人员，特别是要实际动手做应用开发的人员阅读参考。","price":"39.0"},{"rating":{"max":10,"numRaters":51,"average":"9.3","min":0},"subtitle":"进程间通信","author":["(美)W. Richard Stevens"],"pubdate":"2010-7","tags":[{"count":108,"name":"UNIX","title":"UNIX"},{"count":74,"name":"网络编程","title":"网络编程"},{"count":35,"name":"编程","title":"编程"},{"count":27,"name":"网络","title":"网络"},{"count":21,"name":"计算机","title":"计算机"},{"count":20,"name":"Network","title":"Network"},{"count":15,"name":"linux","title":"linux"},{"count":12,"name":"Linux","title":"Linux"}],"origin_title":"UNIX Network Programming, Volume 2: Interprocess Communications (2nd Edition)","image":"http:\/\/img3.douban.com\/mpic\/s4408012.jpg","binding":"平装","translator":[],"catalog":"第一部分 简介\n第1章 简介 2\n1.1 概述 2\n1.2 进程、线程与信息共享 3\n1.3 IPC对象的持续性 4\n1.4 名字空间 5\n1.5 fork、exec和exit对IPC对象的影响 7\n1.6 出错处理：包裹函数 8\n1.7 Unix标准 9\n1.8 书中IPC例子索引表 11\n1.9 小结 13\n习题 13\n第2章 Posix IPC 14\n2.1 概述 14\n2.2 IPC名字 14\n2.3 创建与打开IPC通道 16\n2.4 IPC权限 18\n2.5 小结 19\n习题 19\n第3章 System V IPC 20\n.3.1 概述 20\n3.2 key_t键和ftok函数 20\n3.3 ipc_perm结构 22\n3.4 创建与打开IPC通道 22\n3.5 IPC权限 24\n3.6 标识符重用 25\n3.7 ipcs和ipcrm程序 27\n3.8 内核限制 27\n3.9 小结 28\n习题 29\n第二部分 消息传递\n第4章 管道和FIFO 32\n4.1 概述 32\n4.2 一个简单的客户-服务器例子 32\n4.3 管道 32\n4.4 全双工管道 37\n4.5 popen和pclose函数 39\n4.6 FIFO 40\n4.7 管道和FIFO的额外属性 44\n4.8 单个服务器，多个客户 46\n4.9 对比迭代服务器与并发服务器 50\n4.10 字节流与消息 51\n4.11 管道和FIFO限制 55\n4.12 小结 56\n习题 57\n第5章 Posix消息队列 58\n5.1 概述 58\n5.2 mq_open、mq_close和mq_unlink函数 59\n5.3 mq_getattr和mq_setattr函数 61\n5.4 mq_send和mq_receive函数 64\n5.5 消息队列限制 67\n5.6 mq_notify函数 68\n5.7 Posix实时信号 78\n5.8 使用内存映射I\/O实现Posix消息队列 85\n5.9 小结 101\n习题 101\n第6章 System V消息队列 103\n6.1 概述 103\n6.2 msgget函数 104\n6.3 msgsnd函数 104\n6.4 msgrcv函数 105\n6.5 msgctl函数 106\n6.6 简单的程序 107\n6.7 客户-服务器例子 112\n6.8 复用消息 113\n6.9 消息队列上使用select和poll 121\n6.10 消息队列限制 122\n6.11 小结 124\n习题 124\n第三部分 同步\n第7章 互斥锁和条件变量 126\n7.1 概述 126\n7.2 互斥锁：上锁与解锁 126\n7.3 生产者-消费者问题 127\n7.4 对比上锁与等待 131\n7.5 条件变量：等待与信号发送 132\n7.6 条件变量：定时等待和广播 136\n7.7 互斥锁和条件变量的属性 136\n7.8 小结 139\n习题 139\n第8章 读写锁 140\n8.1 概述 140\n8.2 获取与释放读写锁 140\n8.3 读写锁属性 141\n8.4 使用互斥锁和条件变量实现读写锁 142\n8.5 线程取消 148\n8.6 小结 153\n习题 153\n第9章 记录上锁 154\n9.1 概述 154\n9.2 对比记录上锁与文件上锁 157\n9.3 Posix fcntl记录上锁 158\n9.4 劝告性上锁 162\n9.5 强制性上锁 164\n9.6 读出者和写入者的优先级 166\n9.7 启动一个守护进程的唯一副本 170\n9.8 文件作锁用 171\n9.9 NFS上锁 173\n9.10 小结 173\n习题 174\n第10章 Posix信号量 175\n10.1 概述 175\n10.2 sem_open、sem_close和sem_\nunlink函数 179\n10.3 sem_wait和sem_trywait函数 180\n10.4 sem_post和sem_getvalue函数 180\n10.5 简单的程序 181\n10.6 生产者-消费者问题 186\n10.7 文件上锁 190\n10.8 sem_init和sem_destroy函数 191\n10.9 多个生产者，单个消费者 193\n10.10 多个生产者，多个消费者 196\n10.11 多个缓冲区 199\n10.12 进程间共享信号量 205\n10.13 信号量限制 206\n10.14 使用FIFO实现信号量 206\n10.15 使用内存映射I\/O实现信号量 210\n10.16 使用System V信号量实现Posix信号量 218\n10.17 小结 224\n习题 225\n第11章 System V 信号量 226\n11.1 概述 226\n11.2 semget函数 227\n11.3 semop函数 229\n11.4 semctl函数 231\n11.5 简单的程序 232\n11.6 文件上锁 237\n11.7 信号量限制 238\n11.8 小结 242\n习题 242\n第四部分 共享内存区\n第12章 共享内存区介绍 244\n12.1 概述 244\n12.2 mmap、munmap和msync函数 247\n12.3 在内存映射文件中给计数器持续加1 250\n12.4 4.4BSD匿名内存映射 254\n12.5 SVR4 \/dev\/zero内存映射 255\n12.6 访问内存映射的对象 255\n12.7 小结 259\n习题 260\n第13章 Posix共享内存区 261\n13.1 概述 261\n13.2 shm_open和shm_unlink函数 261\n13.3 ftruncate和fstat函数 262\n13.4 简单的程序 263\n13.5 给一个共享的计数器持续加1 267\n13.6 向一个服务器发送消息 270\n13.7 小结 275\n习题 275\n第14章 System V共享内存区 276\n14.1 概述 276\n14.2 shmget函数 276\n14.3 shmat函数 277\n14.4 shmdt函数 277\n14.5 shmctl函数 277\n14.6 简单的程序 278\n14.7 共享内存区限制 281\n14.8 小结 282\n习题 283\n第五部分 远程过程调用\n第15章 门 286\n15.1 概述 286\n15.2 door_call函数 291\n15.3 door_create函数 292\n15.4 door_return函数 293\n15.5 door_cred函数 294\n15.6 door_info函数 294\n15.7 例子 295\n15.8 描述符传递 306\n15.9 door_sever_create函数 310\n15.10 door_bind、door_unbind和door_revoke函数 315\n15.11 客户或服务器的过早终止 315\n15.12 小结 321\n习题 322\n第16章 Sun RPC 323\n16.1 概述 323\n16.2 多线程化 330\n16.3 服务器捆绑 333\n16.4 认证 336\n16.5 超时和重传 338\n16.6 调用语义 342\n16.7 客户或服务器的过早终止 343\n16.8 XDR：外部数据表示 345\n16.9 RPC分组格式 361\n16.10 小结 365\n习题 366\n后记 368\n附录A 性能测量 371\n附录B 线程入门 406\n附录C 杂凑的源代码 409\n附录D 精选习题解答 417\n参考文献 433\n索引 435","pages":"454","images":{"small":"http:\/\/img3.douban.com\/spic\/s4408012.jpg","large":"http:\/\/img3.douban.com\/lpic\/s4408012.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s4408012.jpg"},"alt":"http:\/\/book.douban.com\/subject\/4886882\/","id":"4886882","publisher":"人民邮电出版社","isbn10":"7115230285","isbn13":"9787115230287","title":"UNIX网络编程 : 第2版. 第2卷， 进程间通信(中文版)","url":"http:\/\/api.douban.com\/v2\/book\/4886882","alt_title":"UNIX Network Programming, Volume 2: Interprocess Communications (2nd Edition)","author_intro":"W. Richard Stevens 国际知名的UNIX和网络专家，备受赞誉的技术作家。他1951年2月5日出生于赞比亚，后随父母回到美国。中学时就读于弗吉尼亚菲什伯恩军事学校，1973年获得密歇根大学航空和航天工程学士学位。1975年至1982年，他在亚利桑那州图森市的基特峰国家天文台从事计算机编程工作，业余时间喜爱飞行运动，做过兼职飞行教练。这期间他分别在1978年和1982年获得亚利桑那大学系统工程硕士和博士学位。此后他去康涅狄格州纽黑文的健康系统国际公司任主管计算机服务的副总裁。","summary":"两卷本的《UNIX网络编程》是已故著名技术作家W. Richard Stevens的传世之作。卷2着重讨论如何让应用程序与在其他机器上的应用程序进行对话。良好的进程间通信（IPC）机制是提高UNIX程序性能的关键。本书全面深入地讲解了各种进程间通信形式，包括消息传递、同步、共享内存及远程调用（RPC）。书中包含了大量经过优化的源代码，帮助读者加深理解。这些源代码可以从图灵网站本书网页免费注册下载。\n本书是网络研究和开发人员公认的权威参考书，深入理解本书内容，方能设计出良好的UNIX软件。","price":"89.00元"},{"rating":{"max":10,"numRaters":84,"average":"8.1","min":0},"subtitle":"","author":["杰弗雷﹒詹姆斯"],"pubdate":"1999-05","tags":[{"count":58,"name":"编程","title":"编程"},{"count":31,"name":"哲学","title":"哲学"},{"count":29,"name":"计算机","title":"计算机"},{"count":25,"name":"编程艺术","title":"编程艺术"},{"count":17,"name":"程序设计","title":"程序设计"},{"count":15,"name":"Programming","title":"Programming"},{"count":13,"name":"程序之道","title":"程序之道"},{"count":11,"name":"寓言","title":"寓言"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s1261335.jpg","binding":"平装","translator":[],"catalog":"目录\n前言\n第一篇 静寂的空宇\n第二篇 古代的大师\n第三篇 设计\n第四篇 编码\n第五篇 维护\n第六篇 管理\n第七篇 公司里的学问\n第八篇 硬件和软件\n第九篇 尾声\n","pages":"56","images":{"small":"http:\/\/img3.douban.com\/spic\/s1261335.jpg","large":"http:\/\/img3.douban.com\/lpic\/s1261335.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s1261335.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1271597\/","id":"1271597","publisher":"清华大学出版社","isbn10":"7302036128","isbn13":"9787302036128","title":"编程之道","url":"http:\/\/api.douban.com\/v2\/book\/1271597","alt_title":"","author_intro":"杰弗雷・詹姆斯（GeoffreyJames）毕业于加利福尼亚大\n学，是一位资深的程序设计师，他目前主要的工作是研究\n如何把最好的管理技术与最成功的高科技企业相结合。在\n畅销书《编程之道》中，酷爱东方哲学的杰弗雷模仿《道\n德经》、禅宗公案和古代寓言的形式，给我们讲了一个个\n看似简单实则深藏玄机的故事。据他本人说，他当初写这\n本书的时候，其灵感的产生和构思的形成，得益于每天早\n晨练完太极拳后的那种玄妙的感觉。\n","summary":"本书出自美国一位善于进行哲学思考、有十多年工作经验的程序设计师——杰弗雷·詹姆斯之手，他以一种敏锐的眼光审视着发生在程序设计室里的各种各样的小故事，并利用古老的道家思想对其进行分析。简单的故事蕴含深奥的道理，是本书的最大特色。本书语言优美，比喻生动，可读性极强。","price":"18.00元"},{"rating":{"max":10,"numRaters":29,"average":"8.2","min":0},"subtitle":"","author":["（美）Mike McShaffry"],"pubdate":"2006-1","tags":[{"count":72,"name":"游戏开发","title":"游戏开发"},{"count":49,"name":"游戏编程","title":"游戏编程"},{"count":37,"name":"游戏","title":"游戏"},{"count":23,"name":"编程","title":"编程"},{"count":10,"name":"计算机","title":"计算机"},{"count":10,"name":"game","title":"game"},{"count":6,"name":"游戏设计","title":"游戏设计"},{"count":5,"name":"Programming","title":"Programming"}],"origin_title":"Game Coding Complete","image":"http:\/\/img5.douban.com\/mpic\/s9076436.jpg","binding":"平装","translator":[],"catalog":"第一部分 游戏编程基础\n第1章 游戏编程很奇怪，因为\n1．1 好的方面.\n1．2 坏的地方\n1．3 恶心之处\n1．4 这一切都值得，对吗?\n第2章 游戏中有什么\n2．1 显示技术：快速概述\n2．2 混合2d和3d技术\n2．3 我必须用directx吗\n2．4 用户界面编码\n2．5 资源缓冲\n2．6 主循环\n2．7 其他\n第3章 所有游戏程序员都应该了解的“简单东西”\n3．1 不可或缺的设计实践\n3．2 智能指针和裸指针\n3．3 正确使用内存\n3．4 游戏脚本语言\n3．5 mike一背包的好东西\n.3．6 这并不是那么简单\n第二部分 让游戏跑起来\n第4章 build游戏\n4．3 源代码仓库和版本控制\n4．4 build游戏：一门黑色艺术?\n4．5 创建build脚本\n4．6 多个项目和共享代码\n4．7 最后的建议\n第5章 用户界面编程和输入设备\n5．1 获取设备状态\n5．2 使用鼠标(和游戏杆)\n5．3 使用键盘\n5．4 用户界面组件\n5．5 更多控件属性\n5．6 最后的用户界面提示\n第6章 每一个游戏开发者都应该掌握的2d知识\n6．1 2d绘制和directx\n6．2 基本2d绘制概念\n6．3 绘制文本\n6．4 使用精灵(sprite)\n6．5 图形文件格式\n6．6 结论\n第7章 初始化和主循环\n7．1 初始化101\n7．2 c++初始化中的一些缺陷\n7．3 初始化游戏..\n7．4 主循环\n7．5 平稳着陆：干净漂亮地退出\n7．6 我现在就可以做游戏了吗\n第8章 载入并缓冲资源\n8．1 图形和音乐的格式\n8．2 资源文件\n8．3 数据压缩\n8．4 ipac：一个资源文件生成器\n8．5 资源高速缓存\n8．6 世界设计和缓存预测\n8．7 我的缓存不够了\n第三部分 构建你的游戏\n第9章 所有游戏程序员必须掌握的3d图形学知识\n9．1 3d图形流水线\n9．2 你的directx 9试练场\n9．3 3d数学101\n9．4 我受够数学了——请停下来\n9．5 3d图形——它那么容易\n第10章 3d引擎\n10．1 建立项目\n10．2 使用场景图\n10．3 遗漏了什么?\n10．4 3d中间件回顾\n10．5 开发自己的3d引擎\n10．6 物理引擎\n10．7 还没满足?\n第11章 开发windows游戏需要特殊考虑的事项\n11．1 microsoft foundation class(mfc)到底怎么样\n]1．2 窗口模式和全屏幕模式\n11．3 操作系统相关的内容\n11．4 “专为windows设计(designed for windows)”标志认证程序\n11．5 结论\n第12章 调试游戏\n12．] 处理失败的艺术\n12．2 调试基础\n12．3 调试技巧\n12．4 各种各样的bus\n12．5 结束小思\n第四部分 专业游戏制作\n第13章 进度计划的艺术\n13．1 好进度、坏进度\n13．2 所有进度计划的关键：里程碑\n13．3 做计划前需要懂得的事情\n13．4 创建进度计划\n13．5 把事情做对\n第14章 测试须知\n14．1 游戏为什么有bug\n14．2 测试计划\n14．3 安排测试\n14．4 自动化的测试\n14．5 bug数据库\n14．6 哪些bug得到修正\n14．7 对bug数据库的静态分析\n14．8 测试组\n14．9 beta公测\n14．10 结束语\n第15章 驶向结束\n15．1 结束时的问题...\n15．2 应付大麻烦\n15．3 光明就在前方——毕竟不是一场训练","pages":"387","images":{"small":"http:\/\/img5.douban.com\/spic\/s9076436.jpg","large":"http:\/\/img5.douban.com\/lpic\/s9076436.jpg","medium":"http:\/\/img5.douban.com\/mpic\/s9076436.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1454723\/","id":"1454723","publisher":"人民邮电出版社","isbn10":"7115132194","isbn13":"9787115132192","title":"游戏编程全接触","url":"http:\/\/api.douban.com\/v2\/book\/1454723","alt_title":"Game Coding Complete","author_intro":"Mike McShaffry，在游戏界众人皆知的\"Mr. Mike\"，参加了创世纪7、8、9和UO（网络创世纪）的开发和项目管理工作。Mike的游戏开发经验以非凡的方式覆盖了整个领域。当团队只有十来个人时他就在那里，然后经历了20、30、50人的团队阶段。他经历过创业，也为业界最大的发行商工作过，开发过从“传统”到绝对“非传统”的游戏——从《创世纪》到Blackjack，单机、多人、在线、离线等你能够想到的任何东西。对于PC游戏，他能以每种权威身份发言——程序员、设计师、项目主管、开发主管、工作室领导……","summary":"本书从游戏是怎样一个行业到游戏业中形形色色的人；从细琐的技巧和算法，到游戏的结构和架构；从调试技巧到进度里程碑的创建和项目进度的管理，共15章，分成四大部分：“游戏编程基础”、“让游戏跑起来”、“构建你的游戏”、“专业游戏制作”，展示了实际的开发游戏过程，从进度安排到测试，到最终的游戏交付。    无论对于游戏项目经理，游戏程序员，还是一名对游戏充满好奇心的狂热爱好者，本书都将让读者受益匪浅。","price":"48.00元"},{"rating":{"max":10,"numRaters":114,"average":"8.1","min":0},"subtitle":"","author":["(美国)霍尔等著、赵学良译"],"pubdate":"2004-06-01","tags":[{"count":67,"name":"Servlet","title":"Servlet"},{"count":57,"name":"java","title":"java"},{"count":31,"name":"Jsp","title":"Jsp"},{"count":25,"name":"jsp","title":"jsp"},{"count":24,"name":"web","title":"web"},{"count":16,"name":"Java","title":"Java"},{"count":16,"name":"计算机","title":"计算机"},{"count":11,"name":"编程","title":"编程"}],"origin_title":"","image":"http:\/\/img3.douban.com\/mpic\/s1224323.jpg","binding":"平装","translator":["霍尔"],"catalog":"\n      ","pages":"475","images":{"small":"http:\/\/img3.douban.com\/spic\/s1224323.jpg","large":"http:\/\/img3.douban.com\/lpic\/s1224323.jpg","medium":"http:\/\/img3.douban.com\/mpic\/s1224323.jpg"},"alt":"http:\/\/book.douban.com\/subject\/1173876\/","id":"1173876","publisher":"清华大学出版社","isbn10":"7302086273","isbn13":"9787302086277","title":"Servlet与JSP核心编程","url":"http:\/\/api.douban.com\/v2\/book\/1173876","alt_title":"","author_intro":"","summary":"《Servlet与JSP核心编程》(第2版)叙述详尽，条理清晰。对于初学者来说是一本不可多得的入门书籍，经验丰富的Servelet和JSP开发人员也可以通过阅读《Servlet与JSP核心编程》(第2版)得到巩固和提高。","price":"59.0"}]}